<!-- doc/src/sgml/limits.sgml -->

<appendix id="limits">
 <title><productname>PostgreSQL</productname> Limitations</title>

 <para>
  Practical limits, such as performance limitations or available disk space
  may apply before absolute hard limits are reached.  However, with those
  aside, the following table describes the hard limits of
  <productname>PostgreSQL</productname>.
 </para>

<table id="limits-table">
 <title><productname>PostgreSQL</productname> limitations</title>
 <tgroup cols="3">
  <thead>
   <row>
    <entry>Item</entry>
    <entry>Upper Limit</entry>
    <entry>Comment</entry>
   </row>
  </thead>

  <tbody>
   <row>
    <entry>Database size</entry>
    <entry>Unlimited</entry>
    <entry></entry>
   </row>

   <row>
    <entry>Number of databases</entry>
    <!-- 2^32 - FirstNormalObjectId - 1 -->
    <entry>4,294,950,911</entry>
    <entry></entry>
   </row>

   <row>
    <entry>Relations per database</entry>
    <!-- (2^32 - FirstNormalObjectId - 1) / 3 (3 because of the table and the
    two types that are created to go with it) -->
    <entry>1,431,650,303</entry>
    <entry></entry>
   </row>

   <row>
    <entry>Relation size</entry>
    <entry>32 TB</entry>
    <entry>Assuming the default BLCKSZ of 8192 bytes</entry>
   </row>

   <row>
    <entry>Rows per table</entry>
    <entry>Limited by the number of tuples that can fit onto 4,294,967,295 pages</entry>
    <entry></entry>
   </row>

   <row>
    <entry>Columns per table</entry>
    <entry>1600</entry>
    <entry>Further limited by tuple size fitting on a single page. See note
    below</entry>
   </row>

   <row>
    <entry>Field size</entry>
    <entry>1 GB</entry>
    <entry></entry>
   </row>

   <row>
    <entry>Identifier length</entry>
    <entry>63 bytes</entry>
    <entry>Can be increased by recompiling
    <productname>PostgreSQL</productname></entry>
   </row>

   <row>
    <entry>Indexes per table</entry>
    <entry>Unlimited</entry>
    <entry>Constrained by maximum relations per database</entry>
   </row>

   <row>
    <entry>Columns per index</entry>
    <entry>32</entry>
    <entry>Can be increased by recompiling
    <productname>PostgreSQL</productname></entry>
   </row>

   <row>
    <entry>Partition keys</entry>
    <entry>32</entry>
    <entry>Can be increased by recompiling
    <productname>PostgreSQL</productname></entry>
   </row>
  </tbody>
 </tgroup>
</table>

  <note>
    <para>
     The maximum number of columns for a table is further reduced as the tuple
     being stored must fit on a single heap page.  Variable length fields such
     as <literal>TEXT</literal>, <literal>VARCHAR</literal> and
     <literal>CHAR</literal> can have their values stored out of line in the
     table's TOAST table when the values are large enough to require it.  Only
     an 18 byte pointer must remain inside the tuple in the table's heap.  For
     shorter length variable length fields either a 4 byte or 1 byte field
     header is used, and the value is stored inside the heap tuple.  Often
     this can mean the actual maximum number of columns that you can store
     inside a table is further reduced as the tuple can become too large to
     fit inside a single 8192 byte heap page.  For example, excluding the
     tuple header, a tuple made up of 1600 <literal>INT</literal> columns
     would consume 6400 bytes and could be stored in a heap page, but a tuple
     of 1600 <literal>BIGINT</literal> columns would consume 12800 bytes,
     therefore not fit inside a heap page.
    </para>

    <para>
     Columns which have been dropped from the table also contribute to the
     maximum column limit.  Moreover, although the dropped column values for
     newly created tuples are internally marked as NULL in the tuple's null
     bitmap, the null bitmap also occupies space.
    </para>
  </note>

</appendix>
