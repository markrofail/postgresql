<!-- doc/src/sgml/pageinspect.sgml -->

<sect1 id="pageinspect" xreflabel="pageinspect">
 <title>pageinspect</title>

 <indexterm zone="pageinspect">
  <primary>pageinspect</primary>
 </indexterm>

 <para>
  The <filename>pageinspect</> module provides functions that allow you to
  inspect the contents of database pages at a low level, which is useful for
  debugging purposes.  All of these functions may be used only by superusers.
 </para>

 <sect2>
  <title>General Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>get_raw_page(relname text, fork text, blkno int) returns bytea</function>
     <indexterm>
      <primary>get_raw_page</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>get_raw_page</function> reads the specified block of the named
      relation and returns a copy as a <type>bytea</> value.  This allows a
      single time-consistent copy of the block to be obtained.
      <replaceable>fork</replaceable> should be <literal>'main'</literal> for
      the main data fork, <literal>'fsm'</literal> for the free space map,
      <literal>'vm'</literal> for the visibility map, or <literal>'init'</literal>
      for the initialization fork.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>get_raw_page(relname text, blkno int) returns bytea</function>
    </term>

    <listitem>
     <para>
      A shorthand version of <function>get_raw_page</function>, for reading
      from the main fork.  Equivalent to
      <literal>get_raw_page(relname, 'main', blkno)</literal>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>page_header(page bytea) returns record</function>
     <indexterm>
      <primary>page_header</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>page_header</function> shows fields that are common to all
      <productname>PostgreSQL</> heap and index pages.
     </para>

     <para>
      A page image obtained with <function>get_raw_page</function> should be
      passed as argument.  For example:
<screen>
test=# SELECT * FROM page_header(get_raw_page('pg_class', 0));
    lsn    | checksum | flags  | lower | upper | special | pagesize | version | prune_xid
-----------+----------+--------+-------+-------+---------+----------+---------+-----------
 0/24A1B50 |        0 |      1 |   232 |   368 |    8192 |     8192 |       4 |         0
</screen>
      The returned columns correspond to the fields in the
      <structname>PageHeaderData</> struct.
      See <filename>src/include/storage/bufpage.h</> for details.
     </para>

     <para>
      The <structfield>checksum</structfield> field is the checksum stored in
      the page, which might be incorrect if the page is somehow corrupted.  If
      data checksums are not enabled for this instance, then the value stored
      is meaningless.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>page_checksum(page bytea, blkno int4) returns smallint</function>
     <indexterm>
      <primary>page_checksum</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>page_checksum</function> computes the checksum for the page, as if
      it was located at the given block.
     </para>

     <para>
      A page image obtained with <function>get_raw_page</function> should be
      passed as argument.  For example:
<screen>
test=# SELECT page_checksum(get_raw_page('pg_class', 0), 0);
 page_checksum
---------------
         13443
</screen>
      Note that the checksum depends on the block number, so matching block
      numbers should be passed (except when doing esoteric debugging).
     </para>

     <para>
      The checksum computed with this function can be compared with
      the <structfield>checksum</structfield> result field of the
      function <function>page_header</function>.  If data checksums are
      enabled for this instance, then the two values should be equal.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>heap_page_items(page bytea) returns setof record</function>
     <indexterm>
      <primary>heap_page_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>heap_page_items</function> shows all line pointers on a heap
      page.  For those line pointers that are in use, tuple headers as well
      as tuple raw data are also shown. All tuples are shown, whether or not
      the tuples were visible to an MVCC snapshot at the time the raw page
      was copied.
     </para>
     <para>
      A heap page image obtained with <function>get_raw_page</function> should
      be passed as argument.  For example:
<screen>
test=# SELECT * FROM heap_page_items(get_raw_page('pg_class', 0));
</screen>
      See <filename>src/include/storage/itemid.h</> and
      <filename>src/include/access/htup_details.h</> for explanations of the fields
      returned.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 integer, t_bits text [, do_detoast bool]) returns bytea[]</function>
     <indexterm>
      <primary>tuple_data_split</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      <function>tuple_data_split</function> splits tuple data into attributes
      in the same way as backend internals.
<screen>
test=# SELECT tuple_data_split('pg_class'::regclass, t_data, t_infomask, t_infomask2, t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));
</screen>
      This function should be called with the same arguments as the return
      attributes of <function>heap_page_items</function>.
     </para>
     <para>
      If <parameter>do_detoast</parameter> is <literal>true</literal>,
      attribute that will be detoasted as needed. Default value is
      <literal>false</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns bytea[]</function>
     <indexterm>
      <primary>heap_page_item_attrs</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      <function>heap_page_item_attrs</function> is equivalent to
      <function>heap_page_items</function> except that it returns
      tuple raw data as an array of attributes that can optionally
      be detoasted by <parameter>do_detoast</parameter> which is
      <literal>false</literal> by default.
     </para>
     <para>
      A heap page image obtained with <function>get_raw_page</function> should
      be passed as argument.  For example:
<screen>
test=# SELECT * FROM heap_page_item_attrs(get_raw_page('pg_class', 0), 'pg_class'::regclass);
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>fsm_page_contents(page bytea) returns text</function>
     <indexterm>
      <primary>fsm_page_contents</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>fsm_page_contents</function> shows the internal node structure
      of a FSM page. The output is a multiline string, with one line per
      node in the binary tree within the page. Only those nodes that are not
      zero are printed. The so-called "next" pointer, which points to the
      next slot to be returned from the page, is also printed.
     </para>
     <para>
      See <filename>src/backend/storage/freespace/README</> for more
      information on the structure of an FSM page.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>B-tree Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>bt_metap(relname text) returns record</function>
     <indexterm>
      <primary>bt_metap</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_metap</function> returns information about a B-tree
      index's metapage.  For example:
<screen>
test=# SELECT * FROM bt_metap('pg_cast_oid_index');
-[ RECORD 1 ]-----
magic     | 340322
version   | 2
root      | 1
level     | 0
fastroot  | 1
fastlevel | 0
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>bt_page_stats(relname text, blkno int) returns record</function>
     <indexterm>
      <primary>bt_page_stats</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_page_stats</function> returns summary information about
      single pages of B-tree indexes.  For example:
<screen>
test=# SELECT * FROM bt_page_stats('pg_cast_oid_index', 1);
-[ RECORD 1 ]-+-----
blkno         | 1
type          | l
live_items    | 256
dead_items    | 0
avg_item_size | 12
page_size     | 8192
free_size     | 4056
btpo_prev     | 0
btpo_next     | 0
btpo          | 0
btpo_flags    | 3
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>bt_page_items(relname text, blkno int) returns setof record</function>
     <indexterm>
      <primary>bt_page_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>bt_page_items</function> returns detailed information about
      all of the items on a B-tree index page.  For example:
<screen>
test=# SELECT * FROM bt_page_items('pg_cast_oid_index', 1);
 itemoffset |  ctid   | itemlen | nulls | vars |    data
------------+---------+---------+-------+------+-------------
          1 | (0,1)   |      12 | f     | f    | 23 27 00 00
          2 | (0,2)   |      12 | f     | f    | 24 27 00 00
          3 | (0,3)   |      12 | f     | f    | 25 27 00 00
          4 | (0,4)   |      12 | f     | f    | 26 27 00 00
          5 | (0,5)   |      12 | f     | f    | 27 27 00 00
          6 | (0,6)   |      12 | f     | f    | 28 27 00 00
          7 | (0,7)   |      12 | f     | f    | 29 27 00 00
          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00
</screen>
      In a B-tree leaf page, <structfield>ctid</> points to a heap tuple.
      In an internal page, the block number part of <structfield>ctid</>
      points to another page in the index itself, while the offset part
      (the second number) is ignored and is usually 1.
     </para>
     <para>
      Note that the first item on any non-rightmost page (any page with
      a non-zero value in the <structfield>btpo_next</> field) is the
      page's <quote>high key</quote>, meaning its <structfield>data</>
      serves as an upper bound on all items appearing on the page, while
      its <structfield>ctid</> field is meaningless.  Also, on non-leaf
      pages, the first real data item (the first item that is not a high
      key) is a <quote>minus infinity</quote> item, with no actual value
      in its <structfield>data</> field.  Such an item does have a valid
      downlink in its <structfield>ctid</> field, however.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>bt_page_items(page bytea) returns setof record</function>
     <indexterm>
      <primary>bt_page_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      It is also possible to pass a page to <function>bt_page_items</function>
      as a <type>bytea</> value.  A page image obtained
      with <function>get_raw_page</function> should be passed as argument.  So
      the last example could also be rewritten like this:
<screen>
test=# SELECT * FROM bt_page_items(get_raw_page('pg_cast_oid_index', 1));
 itemoffset |  ctid   | itemlen | nulls | vars |    data
------------+---------+---------+-------+------+-------------
          1 | (0,1)   |      12 | f     | f    | 23 27 00 00
          2 | (0,2)   |      12 | f     | f    | 24 27 00 00
          3 | (0,3)   |      12 | f     | f    | 25 27 00 00
          4 | (0,4)   |      12 | f     | f    | 26 27 00 00
          5 | (0,5)   |      12 | f     | f    | 27 27 00 00
          6 | (0,6)   |      12 | f     | f    | 28 27 00 00
          7 | (0,7)   |      12 | f     | f    | 29 27 00 00
          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00
</screen>
      All the other details are the same as explained in the previous item.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>BRIN Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>brin_page_type(page bytea) returns text</function>
     <indexterm>
      <primary>brin_page_type</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>brin_page_type</function> returns the page type of the given
      <acronym>BRIN</acronym> index page, or throws an error if the page is
      not a valid <acronym>BRIN</acronym> page.  For example:
<screen>
test=# SELECT brin_page_type(get_raw_page('brinidx', 0));
 brin_page_type 
----------------
 meta
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>brin_metapage_info(page bytea) returns record</function>
     <indexterm>
      <primary>brin_metapage_info</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>brin_metapage_info</function> returns assorted information
      about a <acronym>BRIN</acronym> index metapage.  For example:
<screen>
test=# SELECT * FROM brin_metapage_info(get_raw_page('brinidx', 0));
   magic    | version | pagesperrange | lastrevmappage 
------------+---------+---------------+----------------
 0xA8109CFA |       1 |             4 |              2
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>brin_revmap_data(page bytea) returns setof tid</function>
     <indexterm>
      <primary>brin_revmap_data</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>brin_revmap_data</function> returns the list of tuple
      identifiers in a <acronym>BRIN</acronym> index range map page.
      For example:
<screen>
test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) LIMIT 5;
  pages  
---------
 (6,137)
 (6,138)
 (6,139)
 (6,140)
 (6,141)
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>brin_page_items(page bytea, index oid) returns setof record</function>
     <indexterm>
      <primary>brin_page_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>brin_page_items</function> returns the data stored in the
      <acronym>BRIN</acronym> data page.  For example:
<screen>
test=# SELECT * FROM brin_page_items(get_raw_page('brinidx', 5),
                                     'brinidx')
       ORDER BY blknum, attnum LIMIT 6;
 itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |    value     
------------+--------+--------+----------+----------+-------------+--------------
        137 |      0 |      1 | t        | f        | f           | 
        137 |      0 |      2 | f        | f        | f           | {1 .. 88}
        138 |      4 |      1 | t        | f        | f           | 
        138 |      4 |      2 | f        | f        | f           | {89 .. 176}
        139 |      8 |      1 | t        | f        | f           | 
        139 |      8 |      2 | f        | f        | f           | {177 .. 264}
</screen>
      The returned columns correspond to the fields in the
      <structname>BrinMemTuple</> and <structname>BrinValues</> structs.
      See <filename>src/include/access/brin_tuple.h</> for details.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>GIN Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>gin_value_count(gin_index text) returns setof record</function>
     <indexterm>
      <primary>gin_value_count</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_value_count</function> prints estimated counts for each
      indexed value. The single argument version will return results for the first
      column of an index. For example:
<screen>
test=# SELECT * FROM gin_value_count('gin_idx') as t(value int, nrow int) where nrow > 250;
 value | nrow
 -------+------
    31 |  254
    47 |  251
    52 |  257
    59 |  259
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gin_value_count(gin_index text, colnumber int) returns setof record</function>
     <indexterm>
      <primary>gin_value_count</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_value_count</function> prints estimated counts for each
      indexed value for a given column (starting form zero). For example:
<screen>
test=# SELECT * FROM gin_value_count('gin_idx', 0) as t(value int, nrow int) where nrow > 250;
 value | nrow
 -------+------
    31 |  254
    47 |  251
    52 |  257
    59 |  259
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gin_count_estimate(gin_index text, query tsquery) returns bigint</function>
     <indexterm>
      <primary>gin_count_estimate</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_count_estimate</function> outputs the number of indexed
     rows matched by a query. It doesn't touch heap at all. For example:
<screen>
test=# select gin_count_estimate('qq', 'star');
 gin_count_estimate
--------------------
                 790
</screen>
     </para>
    </listitem>
   </varlistentry>


   <varlistentry>
    <term>
     <function>gin_stats(gin_index text) returns text</function>
     <indexterm>
      <primary>gin_stats</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_stats</function> Prints various statistics about index
      internals. For example:
<screen>
test=# SELECT gin_stats('gin_idx');
         gin_stats
------------------------------
 totalPages:            32   +
 dataPages:             1    +
 dataInnerPages:        0    +
 dataLeafPages:         1    +
 dataInnerFreeSpace:    0    +
 dataLeafFreeSpace:     4454 +
 dataInnerTuplesCount:  0    +
 dataLeafIptrsCount:    3600 +
 entryPages:            31   +
 entryInnerPages:       21   +
 entryLeafPages:        10   +
 entryInnerFreeSpace:   15160+
 entryLeafFreeSpace:    32788+
 entryInnerTuplesCount: 7810 +
 entryLeafTuplesCount:  305  +
 entryPostingSize:      42122+
 entryPostingCount:     96759+
 entryAttrSize:         64924+
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gin_metapage_info(page bytea) returns record</function>
     <indexterm>
      <primary>gin_metapage_info</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_metapage_info</function> returns information about
      a <acronym>GIN</acronym> index metapage.  For example:
<screen>
test=# SELECT * FROM gin_metapage_info(get_raw_page('gin_index', 0));
-[ RECORD 1 ]----+-----------
pending_head     | 4294967295
pending_tail     | 4294967295
tail_free_size   | 0
n_pending_pages  | 0
n_pending_tuples | 0
n_total_pages    | 7
n_entry_pages    | 6
n_data_pages     | 0
n_entries        | 693
version          | 2
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gin_page_opaque_info(page bytea) returns record</function>
     <indexterm>
      <primary>gin_page_opaque_info</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_page_opaque_info</function> returns information about
      a <acronym>GIN</acronym> index opaque area, like the page type.
      For example:
<screen>
test=# SELECT * FROM gin_page_opaque_info(get_raw_page('gin_index', 2));
 rightlink | maxoff |         flags
-----------+--------+------------------------
         5 |      0 | {data,leaf,compressed}
(1 row)
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gin_leafpage_items(page bytea) returns setof record</function>
     <indexterm>
      <primary>gin_leafpage_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gin_leafpage_items</function> returns information about
      the data stored in a <acronym>GIN</acronym> leaf page.  For example:
<screen>
test=# SELECT first_tid, nbytes, tids[0:5] AS some_tids
        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));
 first_tid | nbytes |                        some_tids
-----------+--------+----------------------------------------------------------
 (8,41)    |    244 | {"(8,41)","(8,43)","(8,44)","(8,45)","(8,46)"}
 (10,45)   |    248 | {"(10,45)","(10,46)","(10,47)","(10,48)","(10,49)"}
 (12,52)   |    248 | {"(12,52)","(12,53)","(12,54)","(12,55)","(12,56)"}
 (14,59)   |    320 | {"(14,59)","(14,60)","(14,61)","(14,62)","(14,63)"}
 (167,16)  |    376 | {"(167,16)","(167,17)","(167,18)","(167,19)","(167,20)"}
 (170,30)  |    376 | {"(170,30)","(170,31)","(170,32)","(170,33)","(170,34)"}
 (173,44)  |    197 | {"(173,44)","(173,45)","(173,46)","(173,47)","(173,48)"}
(7 rows)
</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>Hash Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>hash_page_type(page bytea) returns text</function>
     <indexterm>
      <primary>hash_page_type</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>hash_page_type</function> returns page type of
      the given <acronym>HASH</acronym> index page.  For example:
<screen>
test=# SELECT hash_page_type(get_raw_page('con_hash_index', 0));
 hash_page_type 
----------------
 metapage
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>hash_page_stats(page bytea) returns setof record</function>
     <indexterm>
      <primary>hash_page_stats</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>hash_page_stats</function> returns information about
      a bucket or overflow page of a <acronym>HASH</acronym> index.
      For example:
<screen>
test=# SELECT * FROM hash_page_stats(get_raw_page('con_hash_index', 1));
-[ RECORD 1 ]---+-----------
live_items      | 407
dead_items      | 0
page_size       | 8192
free_size       | 8
hasho_prevblkno | 4096
hasho_nextblkno | 8474
hasho_bucket    | 0
hasho_flag      | 66
hasho_page_id   | 65408
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>hash_page_items(page bytea) returns setof record</function>
     <indexterm>
      <primary>hash_page_items</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>hash_page_items</function> returns information about
      the data stored in a bucket or overflow page of a <acronym>HASH</acronym>
      index page.  For example:
<screen>
test=# SELECT * FROM hash_page_items(get_raw_page('con_hash_index', 1)) LIMIT 5;
 itemoffset |   ctid    |    data    
------------+-----------+------------
          1 | (899,77)  | 1053474816
          2 | (897,29)  | 1053474816
          3 | (894,207) | 1053474816
          4 | (892,159) | 1053474816
          5 | (890,111) | 1053474816
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>hash_bitmap_info(index oid, blkno int) returns record</function>
     <indexterm>
      <primary>hash_bitmap_info</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>hash_bitmap_info</function> shows the status of a bit
      in the bitmap page for a particular overflow page of <acronym>HASH</acronym>
      index. For example:
<screen>
test=# SELECT * FROM hash_bitmap_info('con_hash_index', 2052);
 bitmapblkno | bitmapbit | bitstatus 
-------------+-----------+-----------
          65 |         3 | t
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>hash_metapage_info(page bytea) returns record</function>
     <indexterm>
      <primary>hash_metapage_info</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>hash_metapage_info</function> returns information stored
      in meta page of a <acronym>HASH</acronym> index.  For example:
<screen>
test=# SELECT magic, version, ntuples, ffactor, bsize, bmsize, bmshift,
test-#     maxbucket, highmask, lowmask, ovflpoint, firstfree, nmaps, procid,
test-#     regexp_replace(spares::text, '(,0)*}', '}') as spares,
test-#     regexp_replace(mapp::text, '(,0)*}', '}') as mapp
test-# FROM hash_metapage_info(get_raw_page('con_hash_index', 0));
-[ RECORD 1 ]-------------------------------------------------------------------------------
spares    | {0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}
magic     | 105121344
version   | 3
ntuples   | 500500
ffactor   | 40
bsize     | 8152
bmsize    | 4096
bmshift   | 15
maxbucket | 12512
highmask  | 16383
lowmask   | 8191
ovflpoint | 28
firstfree | 1204
nmaps     | 1
procid    | 450
spares    | {0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,4,4,4,45,55,58,59,508,567,628,704,1193,1202,1204}
mapp      | {65}
</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>GiST Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>gist_stats(indexname text) returns text</function>
     <indexterm>
      <primary>gist_stats</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>gist_stats</function> returns information about
      a <acronym>GiST</acronym> index. For example:
<screen>
test=# SELECT gist_stats('gist_index');
               gist_stats
-----------------------------------------
 Number of levels:          2           +
 Number of pages:           29          +
 Number of leaf pages:      28          +
 Number of tuples:          3406        +
 Number of invalid tuples:  0           +
 Number of leaf tuples:     3378        +
 Total size of tuples:      143516 bytes+
 Total size of leaf tuples: 142296 bytes+
 Total size of index:       237568 bytes+
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gist_tree(indexname text, maxlevel int4) returns text</function>
     <indexterm>
      <primary>gist_tree</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      <function>gist_tree</function> shows <acronym>GiST</acronym> tree up to
      <parameter>maxlevel</parameter>. For example:
<screen>
test=# SELECT gist_tree('gist_index', 0);
 0(l:0) blk: 0 numTuple: 29 free: 6888b(15.63%)
</screen>
      Designation (from left to right):
      <itemizedlist>
       <listitem>
        <para>0 - page number</para>
       </listitem>
      <listitem>
       <para>(l:0) - tree level</para>
      </listitem>
       <listitem>
        <para>blk: 0 - block number</para>
       </listitem>
       <listitem>
        <para>numTuple: 29 - the number of tuples</para>
       </listitem>
       <listitem>
        <para>free: 6888b - free space in bytes</para>
       </listitem>
       <listitem>
        <para>(15.63%) - occupied space in percents</para>
       </listitem>
      </itemizedlist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gist_tree(indexname text) returns text</function>
     <indexterm>
      <primary>gist_tree</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      <function>gist_tree</function> shows full <acronym>GiST</acronym> tree.
      For example:
<screen>
test=# SELECT gist_tree('gist_index');
 0(l:0) blk: 0 numTuple: 29 free: 6888b(15.63%)
 1(l:1) blk: 13 numTuple: 180 free: 244b(97.01%)
 2(l:1) blk: 11 numTuple: 175 free: 464b(94.32%)
 3(l:1) blk: 2 numTuple: 101 free: 3720b(54.43%)
 4(l:1) blk: 17 numTuple: 111 free: 3280b(59.82%)
 5(l:1) blk: 18 numTuple: 101 free: 3720b(54.43%)
 6(l:1) blk: 10 numTuple: 98 free: 3852b(52.82%)
 7(l:1) blk: 19 numTuple: 111 free: 3280b(59.82%)
 8(l:1) blk: 9 numTuple: 97 free: 3896b(52.28%)
 9(l:1) blk: 20 numTuple: 104 free: 3588b(56.05%)
 10(l:1) blk: 14 numTuple: 96 free: 3940b(51.74%)
 11(l:1) blk: 21 numTuple: 106 free: 3500b(57.13%)
 12(l:1) blk: 7 numTuple: 103 free: 3632b(55.51%)
 13(l:1) blk: 1 numTuple: 101 free: 3720b(54.43%)
 14(l:1) blk: 16 numTuple: 97 free: 3896b(52.28%)
 15(l:1) blk: 24 numTuple: 103 free: 3632b(55.51%)
 16(l:1) blk: 4 numTuple: 98 free: 3852b(52.82%)
 17(l:1) blk: 25 numTuple: 98 free: 3852b(52.82%)
 18(l:1) blk: 3 numTuple: 97 free: 3896b(52.28%)
 19(l:1) blk: 26 numTuple: 96 free: 3940b(51.74%)
 20(l:1) blk: 6 numTuple: 103 free: 3632b(55.51%)
 21(l:1) blk: 8 numTuple: 162 free: 1036b(87.31%)
 22(l:1) blk: 23 numTuple: 94 free: 4028b(50.66%)
 23(l:1) blk: 12 numTuple: 82 free: 4556b(44.19%)
 24(l:1) blk: 27 numTuple: 105 free: 3544b(56.59%)
 25(l:1) blk: 5 numTuple: 90 free: 4204b(48.51%)
 26(l:1) blk: 28 numTuple: 100 free: 3764b(53.90%)
 27(l:1) blk: 22 numTuple: 101 free: 3720b(54.43%)
 28(l:1) blk: 15 numTuple: 95 free: 3984b(51.20%)
 29(l:1) blk: 29 numTuple: 95 free: 3984b(51.20%)
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>gist_print(indexname text) returns setof record</function>
     <indexterm>
      <primary>gist_print</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
      <function>gist_print</function> prints objects stored in a
      <acronym>GiST</acronym> tree. It works only if the objects in the index have
      textual representation (<function>type_out</function> functions should be
      implemented for the given object type). It's known to work with R-tree
      <acronym>GiST</acronym> based indexes. Note: in example below, objects are
      of type box. For example:
<screen>
test=# SELECT * FROM gist_print('gist_index') AS t(level int, valid bool, a box) WHERE level = 1;
 level | valid |              a
-------+-------+-----------------------------
     1 | t     | (37357,50073),(34242,357)
     1 | t     | (43499,49770),(40358,43)
     1 | t     | (31193,24679),(25047,12410)
     1 | t     | (31018,12142),(25083,6)
     1 | t     | (49944,25174),(43471,12802)
     1 | t     | (12577,49757),(6302,37534)
     1 | t     | (12528,37333),(6171,24861)
     1 | t     | (50027,49751),(46817,25462)
     1 | t     | (46870,49912),(43664,25722)
     1 | t     | (24855,25574),(12447,19263)
     1 | t     | (25054,19126),(12403,12796)
     1 | t     | (32737,49923),(31178,1038)
     1 | t     | (3184,24465),(15,81)
     1 | t     | (24951,49983),(12740,44000)
     1 | t     | (24919,43956),(12617,37901)
     1 | t     | (40387,49852),(37338,25217)
     1 | t     | (40325,24963),(37375,491)
     1 | t     | (24919,12698),(12654,6518)
     1 | t     | (25002,6338),(12350,51)
     1 | t     | (49985,12554),(43447,222)
     1 | t     | (25003,37769),(12552,25573)
     1 | t     | (34270,49382),(32763,594)
     1 | t     | (6205,50012),(3,37527)
     1 | t     | (6163,37358),(120,25034)
     1 | t     | (12343,24542),(9295,294)
     1 | t     | (9308,24151),(6234,620)
     1 | t     | (6230,24629),(3169,108)
     1 | t     | (31179,50040),(28113,25556)
     1 | t     | (28048,49694),(25000,25000)
</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
  <title>SP-GiST Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>spgist_stats(indexname text) returns text</function>
     <indexterm>
      <primary>spgist_stats</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>spgist_stats</function> returns information about
      a <acronym>SP-GiST</acronym> index. For example:
<screen>
test=# SELECT spgist_stats('spgist_idx');
           spgist_stats
----------------------------------
 totalPages:        21           +
 deletedPages:      0            +
 innerPages:        3            +
 leafPages:         18           +
 emptyPages:        1            +
 usedSpace:         121.27 kbytes+
 freeSpace:         46.07 kbytes +
 fillRatio:         72.47%       +
 leafTuples:        3669         +
 innerTuples:       20           +
 innerAllTheSame:   0            +
 leafPlaceholders:  569          +
 innerPlaceholders: 0            +
 leafRedirects:     0            +
 innerRedirects:    0            +
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>spgist_print(indexname text) returns setof record</function>
     <indexterm>
      <primary>spgist_print</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>spgist_print</function> prints objects stored in a
      <acronym>SP-GiST</acronym> tree. It works only if the objects in the index have
      textual representation (<function>type_out</function> functions should
      be implemented for the given object type).
      <itemizedlist>
       <listitem>
        <para>
         Note 1. in the example below we used quad_point_ops which uses point
         for leaf and prefix value, but doesn't use node_label at all.
         Use type 'int' as dummy type for prefix or/and node_label.
        </para>
       </listitem>
       <listitem>
        <para>
         Note 2.
<screen>
 quad_point_ops: prefix point, node_label int,  leaf_value point
 kd_point_ops:   prefix float, node_label int,  leaf_value point
 text_ops:       prefix text,  node_label char, leaf_value text
</screen>
        </para>
       </listitem>
      </itemizedlist>
      For example:
<screen>
test=# SELECT * FROM spgist_print('spgist_idx') as t
        (
            tid tid,
            allthesame bool,
            node_n int,
            level int,
            tid_pointer tid,
            prefix point,
            node_label int,
            leaf_value point
        ) where level = 1;
  tid  | allthesame | node_n | level | tid_pointer |               prefix                | node_label | leaf_value
-------+------------+--------+-------+-------------+-------------------------------------+------------+------------
 (1,1) | f          |      0 |     1 | (5,4)       | (24530.2070484581,23595.7092511013) |            |
 (1,1) | f          |      1 |     1 | (5,3)       | (24530.2070484581,23595.7092511013) |            |
 (1,1) | f          |      2 |     1 | (5,2)       | (24530.2070484581,23595.7092511013) |            |
 (1,1) | f          |      3 |     1 | (5,1)       | (24530.2070484581,23595.7092511013) |            |

</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

</sect1>
