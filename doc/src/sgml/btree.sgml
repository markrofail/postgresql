<!-- doc/src/sgml/btree.sgml -->

<chapter id="btree">
<title>B-Tree Indexes</title>

   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>

<sect1 id="btree-intro">
 <title>Introduction</title>

 <para>
  <productname>PostgreSQL</productname> includes an implementation of the
  standard <acronym>btree</acronym> (multi-way balanced tree) index data
  structure.  Any data type that can be sorted into a well-defined linear
  order can be indexed by a btree index.  The only limitation is that an
  index entry cannot exceed approximately one-third of a page (after TOAST
  compression, if applicable).
 </para>

 <para>
  Because each btree operator class imposes a sort order on its data type,
  btree operator classes (or, really, operator families) have come to be
  used as <productname>PostgreSQL</productname>'s general representation
  and understanding of sorting semantics.  Therefore, they've acquired
  some features that go beyond what would be needed just to support btree
  indexes, and parts of the system that are quite distant from the
  btree AM make use of them.
 </para>

</sect1>

<sect1 id="btree-behavior">
 <title>Behavior of B-Tree Operator Classes</title>

 <para>
  As shown in <xref linkend="xindex-btree-strat-table"/>, a btree operator
  class must provide five comparison operators,
  <literal>&lt;</literal>,
  <literal>&lt;=</literal>,
  <literal>=</literal>,
  <literal>&gt;=</literal> and
  <literal>&gt;</literal>.
  One might expect that <literal>&lt;&gt;</literal> should also be part of
  the operator class, but it is not, because it would almost never be
  useful to use a <literal>&lt;&gt;</literal> WHERE clause in an index
  search.  (For some purposes, the planner treats <literal>&lt;&gt;</literal>
  as associated with a btree operator class; but it finds that operator via
  the <literal>=</literal> operator's negator link, rather than
  from <structname>pg_amop</structname>.)
 </para>

 <para>
  When several data types share near-identical sorting semantics, their
  operator classes can be grouped into an operator family.  Doing so is
  advantageous because it allows the planner to make deductions about
  cross-type comparisons.  Each operator class within the family should
  contain the single-type operators (and associated support functions)
  for its input data type, while cross-type comparison operators and
  support functions are <quote>loose</quote> in the family.  It is
  recommendable that a complete set of cross-type operators be included
  in the family, thus ensuring that the planner can represent any
  comparison conditions that it deduces from transitivity.
 </para>

 <para>
  There are some basic assumptions that a btree operator family must
  satisfy:
 </para>

 <itemizedlist>
  <listitem>
   <para>
    An <literal>=</literal> operator must be an equivalence relation; that
    is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable> of the
    data type:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>reflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable>,
       then <replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>
       (<firstterm>symmetric law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable> and <replaceable>B</replaceable>
       <literal>=</literal> <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
    A <literal>&lt;</literal> operator must be a strong ordering relation;
    that is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is false
       (<firstterm>irreflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>
       and <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
   <para>
    Furthermore, the ordering is total; that is, for all non-null
    values <replaceable>A</replaceable>, <replaceable>B</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       exactly one of <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>, <replaceable>A</replaceable>
       <literal>=</literal> <replaceable>B</replaceable>, and
       <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>trichotomy law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>

    (The trichotomy law justifies the definition of the comparison support
    function, of course.)
   </para>
  </listitem>
 </itemizedlist>

 <para>
  The other three operators are defined in terms of <literal>=</literal>
  and <literal>&lt;</literal> in the obvious way, and must act consistently
  with them.
 </para>

 <para>
  For an operator family supporting multiple data types, the above laws must
  hold when <replaceable>A</replaceable>, <replaceable>B</replaceable>,
  <replaceable>C</replaceable> are taken from any data types in the family.
  The transitive laws are the trickiest to ensure, as in cross-type
  situations they represent statements that the behaviors of two or three
  different operators are consistent.
  As an example, it would not work to put <type>float8</type>
  and <type>numeric</type> into the same operator family, at least not with
  the current semantics that <type>numeric</type> values are converted
  to <type>float8</type> for comparison to a <type>float8</type>.  Because
  of the limited accuracy of <type>float8</type>, this means there are
  distinct <type>numeric</type> values that will compare equal to the
  same <type>float8</type> value, and thus the transitive law would fail.
 </para>

 <para>
  Another requirement for a multiple-data-type family is that any implicit
  or binary-coercion casts that are defined between data types included in
  the operator family must not change the associated sort ordering.
 </para>

 <para>
  It should be fairly clear why a btree index requires these laws to hold
  within a single data type: without them there is no ordering to arrange
  the keys with.  Also, index searches using a comparison key of a
  different data type require comparisons to behave sanely across two
  data types.  The extensions to three or more data types within a family
  are not strictly required by the btree index mechanism itself, but the
  planner relies on them for optimization purposes.
 </para>

</sect1>

<sect1 id="btree-support-funcs">
 <title>B-Tree Support Functions</title>

 <para>
  As shown in <xref linkend="xindex-btree-support-table"/>, btree defines
  one required and three optional support functions.  The four
  user-defined methods are:
 </para>
 <variablelist>
  <varlistentry>
   <term><function>order</function></term>
   <listitem>
    <para>
     For each combination of data types that a btree operator family
     provides comparison operators for, it must provide a comparison
     support function, registered in
     <structname>pg_amproc</structname> with support function number 1
     and
     <structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>
     equal to the left and right data types for the comparison (i.e.,
     the same data types that the matching operators are registered
     with in <structname>pg_amop</structname>).  The comparison
     function must take two non-null values
     <replaceable>A</replaceable> and <replaceable>B</replaceable> and
     return an <type>int32</type> value that is
     <literal>&lt;</literal> <literal>0</literal>,
     <literal>0</literal>, or <literal>&gt;</literal>
     <literal>0</literal> when <replaceable>A</replaceable>
     <literal>&lt;</literal> <replaceable>B</replaceable>,
     <replaceable>A</replaceable> <literal>=</literal>
     <replaceable>B</replaceable>, or <replaceable>A</replaceable>
     <literal>&gt;</literal> <replaceable>B</replaceable>,
     respectively.  A null result is disallowed: all values of the
     data type must be comparable.  See
     <filename>src/backend/access/nbtree/nbtcompare.c</filename> for
     examples.
    </para>

    <para>
     If the compared values are of a collatable data type, the
     appropriate collation OID will be passed to the comparison
     support function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>sortsupport</function></term>
   <listitem>
    <para>
     Optionally, a btree operator family may provide <firstterm>sort
      support</firstterm> function(s), registered under support
     function number 2.  These functions allow implementing
     comparisons for sorting purposes in a more efficient way than
     naively calling the comparison support function.  The APIs
     involved in this are defined in
     <filename>src/include/utils/sortsupport.h</filename>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>inrange</function></term>
   <listitem>
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>

    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
    <para>
     Optionally, a btree operator family may provide
     <firstterm>in_range</firstterm> support function(s), registered
     under support function number 3.  These are not used during btree
     index operations; rather, they extend the semantics of the
     operator family so that it can support window clauses containing
     the <literal>RANGE</literal> <replaceable>offset</replaceable>
     <literal>PRECEDING</literal> and <literal>RANGE</literal>
     <replaceable>offset</replaceable> <literal>FOLLOWING</literal>
     frame bound types (see <xref
      linkend="syntax-window-functions"/>).  Fundamentally, the extra
     information provided is how to add or subtract an
     <replaceable>offset</replaceable> value in a way that is
     compatible with the family's data ordering.
    </para>

    <para>
     An <function>in_range</function> function must have the signature
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
     <replaceable>val</replaceable> and
     <replaceable>base</replaceable> must be of the same type, which
     is one of the types supported by the operator family (i.e., a
     type for which it provides an ordering).  However,
     <replaceable>offset</replaceable> could be of a different type,
     which might be one otherwise unsupported by the family.  An
     example is that the built-in <literal>time_ops</literal> family
     provides an <function>in_range</function> function that has
     <replaceable>offset</replaceable> of type <type>interval</type>.
     A family can provide <function>in_range</function> functions for
     any of its supported types and one or more
     <replaceable>offset</replaceable> types.  Each
     <function>in_range</function> function should be entered in
     <structname>pg_amproc</structname> with
     <structfield>amproclefttype</structfield> equal to
     <type>type1</type> and <structfield>amprocrighttype</structfield>
     equal to <type>type2</type>.
    </para>

    <para>
     The essential semantics of an <function>in_range</function>
     function depend on the two Boolean flag parameters.  It should
     add or subtract <replaceable>base</replaceable> and
     <replaceable>offset</replaceable>, then compare
     <replaceable>val</replaceable> to the result, as follows:
     <itemizedlist>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
     </itemizedlist>
     Before doing so, the function should check the sign of
     <replaceable>offset</replaceable>: if it is less than zero, raise
     error
     <literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal>
     (22013) with error text like <quote>invalid preceding or
      following size in window function</quote>.  (This is required by
     the SQL standard, although nonstandard operator families might
     perhaps choose to ignore this restriction, since there seems to
     be little semantic necessity for it.) This requirement is
     delegated to the <function>in_range</function> function so that
     the core code needn't understand what <quote>less than
      zero</quote> means for a particular data type.
    </para>

    <para>
     An additional expectation is that <function>in_range</function>
     functions should, if practical, avoid throwing an error if
     <replaceable>base</replaceable> <literal>+</literal>
     <replaceable>offset</replaceable> or
     <replaceable>base</replaceable> <literal>-</literal>
     <replaceable>offset</replaceable> would overflow.  The correct
     comparison result can be determined even if that value would be
     out of the data type's range.  Note that if the data type
     includes concepts such as <quote>infinity</quote> or
     <quote>NaN</quote>, extra care may be needed to ensure that
     <function>in_range</function>'s results agree with the normal
     sort order of the operator family.
    </para>

    <para>
     The results of the <function>in_range</function> function must be
     consistent with the sort ordering imposed by the operator family.
     To be precise, given any fixed values of
     <replaceable>offset</replaceable> and
     <replaceable>sub</replaceable>, then:
     <itemizedlist>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be true for every
        <replaceable>val2</replaceable> <literal>&lt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be false for every
        <replaceable>val2</replaceable> <literal>&gt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be true for every
        <replaceable>base2</replaceable> <literal>&gt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be false for every
        <replaceable>base2</replaceable> <literal>&lt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
     </itemizedlist>
     Analogous statements with inverted conditions hold when
     <replaceable>less</replaceable> = false.
    </para>

    <para>
     If the type being ordered (<type>type1</type>) is collatable, the
     appropriate collation OID will be passed to the
     <function>in_range</function> function, using the standard
     PG_GET_COLLATION() mechanism.
    </para>

    <para>
     <function>in_range</function> functions need not handle NULL
     inputs, and typically will be marked strict.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>equalimage</function></term>
   <listitem>
    <para>
     Optionally, a btree operator family may provide
     <function>equalimage</function> (<quote>equality is image
      equality</quote>) support functions, registered under support
     function number 4.  These functions allow the implementation to
     determine when it is safe to apply the btree deduplication
     optimization.  Currently, <function>equalimage</function>
     functions are only called when building or rebuilding an index.
    </para>
    <para>
     An <function>equalimage</function> function must have the
     signature
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
     The return value is static information about an operator class
     and collation.  Returning <literal>true</literal> indicates that
     any two non-null values that could possibly be used as arguments
     to the <function>order</function>/comparison function must be
     equivalent in every way if and only if the return value is
     <literal>0</literal>.  This condition implies that deduplication
     is safe, provided that there is no other factor that makes
     deduplication unsafe.  Not registering an
     <function>equalimage</function> function or returning
     <literal>false</literal> indicates that deduplication is unsafe.
     Every column in an index must have an
     <function>equalimage</function> function that returns
     <literal>true</literal> before deduplication can be used.
    </para>
    <para>
     The <replaceable>opcintype</replaceable> argument is the
     <literal><structname>pg_type</structname>.oid</literal> of the
     data type that is indexed.  This is a convenience that allows
     reuse of the same underlying <function>equalimage</function>
     function across operator classes.  If the indexed values are of a
     collatable data type, the appropriate collation OID will be
     passed to the <function>equalimage</function> function, using the
     standard <function>PG_GET_COLLATION()</function> mechanism.
    </para>
    <para>
     The convention followed by all operator classes with an
     <function>equalimage</function> function that are included with
     the core distribution is to register one of two generic
     functions, rather than registering their own custom function.
     Most register <function>btequalimage()</function>, which
     unconditionally indicates that deduplication is safe.  Operator
     classes for collatable data types such as <type>text</type>
     register the generic <function>btvarstrequalimage()</function>
     function to indicate that deduplication is safe with
     deterministic collations.  Best practice for third-party
     extensions is to register their own custom function to retain
     control.
    </para>
    <para>
     <quote>Image</quote> equality is <emphasis>almost</emphasis> the
     same condition as simple bitwise equality.  There is one subtle
     difference.  When indexing a varlena data type, the on-disk
     representation of two image equal datums may not be bitwise equal
     due to inconsistent application of <acronym>TOAST</acronym>
     compression on input.  Formally, when an operator class's
     <function>equalimage</function> function returns
     <literal>true</literal>, it is safe to assume that the
     <literal>datum_image_eq()</literal> C function will always agree
     with the operator class's <function>order</function> function
     (provided that the same collation OID is passed to both the
     <function>equalimage</function> and <function>order</function>
     functions).
    </para>
    <para>
     It is not possible for the core system to deduce anything about
     an operator class within a multiple-data-type family based only
     on the fact that some other operator class in the same family has
     an <function>equalimage</function> function.  It is not sensible
     to provide a cross-type <function>equalimage</function> function,
     and attempting to do so will result in an error (that is,
     <function>equalimage</function> functions cannot be
     <quote>loose</quote> within an operator family).
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="btree-implementation">
 <title>Implementation</title>

 <para>
  This section covers B-Tree index implementation details that may be
  of use to advanced users.  See
  <filename>src/backend/access/nbtree/README</filename> in the source
  distribution for a much more detailed, internals-focused description
  of the B-Tree implementation.
 </para>
 <sect2 id="btree-structure">
  <title>Structure</title>
  <para>
   <productname>PostgreSQL</productname> B-Tree indexes are
   multi-level tree structures, where each level of the tree can be
   used as a doubly-linked list of pages.  A single metapage is stored
   in a fixed position at the start of the first segment file of the
   index.  All other pages are either leaf pages or internal pages.
   Leaf pages are the pages on the lowest level of the tree.  All
   other levels consist of internal pages.  Each leaf page contains
   tuples that point to table entries using a heap item pointer.  Each
   internal page contains tuples that point to the next level down in
   the tree.  Typically, over 99% of all pages are leaf pages.  Both
   internal pages and leaf pages use the standard page format
   described in <xref linkend="storage-page-layout"/>.
  </para>
  <para>
   New pages are added to a B-Tree index when an existing page becomes
   full.  A <firstterm>page split</firstterm> is performed, which
   makes room for items that belong on the overflowing page by moving
   a portion of the items to a new page.  Splits in leaf pages insert
   a new tuple into the original page's parent page, which may cause
   the parent page to split in turn.  Page splits <quote>cascade
    upwards</quote> in a recursive fashion.  When the root page cannot
   fit a new item, a <firstterm>root page split</firstterm> is
   performed.  This adds a new level to the tree structure.
  </para>
 </sect2>

 <sect2 id="btree-deduplication">
  <title>Deduplication</title>
  <para>
   A duplicate is a tuple where <emphasis>all</emphasis> indexed key
   columns have values that match corresponding column values from at
   least one other tuple in the same index.  In practice, duplicate
   tuples are quite common.  B-Tree has an optimization that stores
   duplicates using a space efficient representation: deduplication.
   Deduplication periodically replaces each contiguous group of
   duplicate tuples with a single equivalent posting list tuple.  The
   keys appear only once in this representation, followed by a sorted
   array of heap item pointers.  This significantly reduces the
   storage size of indexes where each value (or each distinct set of
   column values) appears several times on average.  The latency of
   queries can be reduced significantly.  Overall query throughput may
   increase significantly.  The overhead of routine index vacuuming
   may also be significantly reduced.
  </para>
  <note>
   <para>
    While NULL is generally not considered to be equal to any other
    value, including NULL, NULL is nevertheless treated as just
    another value from the domain of indexed values by the
    B-Tree implementation.  B-Tree deduplication is just as effective
    with <quote>duplicates</quote> that contain a NULL value.
   </para>
  </note>
  <para>
   The deduplication process occurs <quote>lazily</quote>, when a new
   item is inserted that cannot fit on an existing leaf page.  This
   prevents (or at least delays) leaf page splits.  Unlike GIN posting
   list tuples, B-Tree posting list tuples do not need to expand every
   time a new duplicate is inserted; they are merely an alternative
   physical representation of the original logical contents found on
   the page.  B-Tree indexes can store duplicates efficiently, without
   adding overhead to read operators or to most individual write
   operations.
  </para>
  <para>
   Workloads that don't benefit from deduplication due to having no
   duplicate values in indexes will incur a small, fixed performance
   penalty with write heavy workloads (unless deduplication is
   explicitly disabled).  The <literal>deduplicate_items</literal>
   storage parameter can be used to disable deduplication within
   individual indexes.  See <xref
    linkend="sql-createindex-storage-parameters"/> from the
   <command>CREATE INDEX</command> documentation for details.  There
   is never any performance penalty with read-only workloads, since
   reading from posting lists is at least as efficient as reading the
   standard index tuple representation.
  </para>
  <para>
   <productname>PostgreSQL</productname> uses <acronym>MVCC</acronym>
   to maintain data consistency.  This impacts nearly every major
   subsystem, including the B-Tree index access method.  B-Tree
   indexes may contain multiple physical tuples for the same logical
   table row, even in unique indexes.  Note that
   <command>UPDATE</command> statements that avoid modifying most (but
   not all) of the columns that are covered by indexes will generally
   still need succesor index tuples that point to a new physical row
   version <emphasis>for each and every index</emphasis>.  These
   implementation-level duplicates are sometimes a significant source
   of index bloat.
  </para>
  <para>
   Deduplication tends to avoid page splits that are only needed due
   to a short-term increase in <quote>duplicate</quote> tuples that
   all point to different versions of the same logical table row.
   <command>VACUUM</command> or autovacuum will eventually remove dead
   versions of tuples from every index in any case, but
   <command>VACUUM</command> usually cannot reverse page splits (in
   general, a leaf page must be completely empty before
   <command>VACUUM</command> can <quote>delete</quote> it).  In
   effect, deduplication delays <quote>version driven</quote> page
   splits, which may give VACUUM enough time to run and prevent the
   splits entirely.  Unique indexes make use of deduplication for this
   reason.  Also, even unique indexes can have a set of
   <quote>duplicate</quote> rows that are all visible to a given
   <acronym>MVCC</acronym> snapshot, provided at least one column has
   a NULL value.  In general, the implementation considers tuples with
   NULL values to be duplicates for the purposes of deduplication.
  </para>
  <para>
   Unique indexes can only contain non-NULL duplicates because of
   version churn.  The implementation applies a special heuristic when
   considering whether to attempt deduplication in a unique index.
   This heuristic virtually avoids the possibility of a performance
   penalty in unique indexes.
  </para>
  <note>
   <para>
    Like all <productname>PostgreSQL</productname> index access
    methods, B-Tree does not have direct access to visibility
    information.  B-Tree deduplication does not distinguish duplicates
    caused by <command>UPDATE</command> statements (that needed
    successor versions) from duplicates that were created by
    <command>INSERT</command> statements.
   </para>
  </note>
  <para>
   Typically, most B-Tree indexes can make use of deduplication
   without any special configuration on the administrator's part.
   Note, however, that deduplication cannot be used in all cases.
   Deduplication is only deemed safe when <emphasis>all</emphasis>
   indexed columns use an operator class that has an
   <function>equalimage</function> function, and the function returns
   <literal>true</literal>.  Deduplication safety is determined when
   <command>CREATE INDEX</command> or <command>REINDEX</command> run.
   Note that deduplication cannot be used in the following cases:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <type>text</type>, <type>varchar</type>, <type>bpchar</type> and
      <type>name</type> cannot use deduplication when the collation is
      a <emphasis>nondeterministic</emphasis> collation.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>numeric</type> cannot use deduplication.  In general, a
      pair of equal <type>numeric</type> datums may still have
      different <quote>display scales</quote>.  These differences must
      be preserved.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>jsonb</type> cannot use deduplication, since the
      <type>jsonb</type> B-Tree operator class uses
      <type>numeric</type> internally.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>float4</type>, <type>float8</type> and <type>money</type>
      cannot use deduplication.  Each of these types has
      representations for both <literal>-0</literal> and
      <literal>0</literal> that are treated as equal.
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   There are several implementation-level restriction that may be
   lifted in a future version of
   <productname>PostgreSQL</productname>:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      enum types cannot use deduplication.
     </para>
    </listitem>

    <listitem>
     <para>
      Container types (such as composite types, arrays, or range
      types) cannot use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   There is a further implementation-level restriction that prevents
   the use of deduplication, regardless of the types, operator
   classes, or collations that are used by an index:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>INCLUDE</literal> indexes can never use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect2>
</sect1>

</chapter>
