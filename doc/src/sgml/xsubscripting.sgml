<!-- doc/src/sgml/xsubscripting.sgml -->

 <sect1 id="xsubscripting">
  <title>User-defined subscripting procedure</title>

  <indexterm zone="xsubscripting">
    <primary>custom subscripting</primary>
  </indexterm>
  <para>
  When you define a new base type, you can also specify a custom procedures to
  handle subscripting expressions. They must contain logic for verification and
  evaluation of this expression, i.e. fetching or updating some data in this
  data type. For instance:
</para>
<programlisting><![CDATA[
typedef struct Custom
{
    int first;
    int second;
}   Custom;

PG_FUNCTION_INFO_V1(custom_subscripting_handler);

Datum
custom_subscripting_handler(PG_FUNCTION_ARGS)
{
    SubscriptRoutines *sbsroutines = (SubscriptRoutines *)
                                     palloc(sizeof(SubscriptRoutines));
    sbsroutines->prepare = custom_subscript_prepare;
    sbsroutines->validate = custom_subscript_validate;
    sbsroutines->fetch = custom_subscript_fetch;
    sbsroutines->assign = custom_subscript_assign;

    PG_RETURN_POINTER(sbsroutines);
}

SubscriptingRef *
custom_subscript_prepare(bool isAssignment, SubscriptingRef *sbsref)
{
    sbsref->refelemtype = someType;
    sbsref->refassgntype = someType;

    return sbsref;
}

SubscriptingRef *
custom_subscript_validate(bool isAssignment, SubscriptingRef *sbsref,
                          ParseState *pstate)
{
    // some validation and coercion logic

    return sbsref;
}

Datum
custom_subscript_assign(Datum containerSource, SubscriptingRefState *sbstate)
{
    // Some assignment logic

    return newContainer;
}

Datum
custom_subscript_fetch(Datum containerSource, SubscriptingRefState *sbstate)
{
    // Some fetch logic based on sbsdata
}]]>
</programlisting>

<para>
    Then you can define a subscripting procedures and a custom data type:
</para>
<programlisting>
CREATE FUNCTION custom_subscripting_handler(internal)
    RETURNS internal
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE TYPE custom (
   internallength = 4,
   input = custom_in,
   output = custom_out,
   subscripting_handler = custom_subscripting_handler,
);
</programlisting>

<para>
    and use it as usual:
</para>
<programlisting>
CREATE TABLE test_subscripting (
    data    custom
);

INSERT INTO test_subscripting VALUES ('(1, 2)');

SELECT data[0] from test_subscripting;

UPDATE test_subscripting SET data[1] = 3;
</programlisting>


  <para>
   The examples of custom subscripting implementation can be found in
   <filename>subscripting.sql</filename> and <filename>subscripting.c</filename>
   in the <filename>src/tutorial</filename> directory of the source distribution.
   See the <filename>README</filename> file in that directory for instructions
   about running the examples.
  </para>

</sect1>
