-- Perform tests on the Result Cache node.
-- Ensure we get the expected plan with sub plans.
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT unique1, (SELECT count(*) FROM tenk1 t2 WHERE t2.twenty = t1.twenty) FROM tenk1 t1;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Seq Scan on tenk1 t1 (actual rows=10000 loops=1)
   SubPlan 1
     ->  Result Cache (actual rows=1 loops=10000)
           Cache Key: t1.twenty
           Cache Hits: 9980  Cache Misses: 20 Cache Evictions: 0  Cache Overflows: 0
           ->  Aggregate (actual rows=1 loops=20)
                 ->  Seq Scan on tenk1 t2 (actual rows=500 loops=20)
                       Filter: (twenty = t1.twenty)
                       Rows Removed by Filter: 9500
(9 rows)

EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT unique1, (SELECT count(*) FROM tenk1 t2 WHERE t2.thousand = t1.thousand) FROM tenk1 t1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1 t1 (actual rows=10000 loops=1)
   SubPlan 1
     ->  Result Cache (actual rows=1 loops=10000)
           Cache Key: t1.thousand
           Cache Hits: 9000  Cache Misses: 1000 Cache Evictions: 0  Cache Overflows: 0
           ->  Aggregate (actual rows=1 loops=1000)
                 ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t2 (actual rows=10 loops=1000)
                       Index Cond: (thousand = t1.thousand)
                       Heap Fetches: 0
(9 rows)

-- Reduce work_mem so that we see some cache evictions
SET work_mem TO '64kB';
-- Ensure we get some evitions.  The number is likely to vary on different machines, so
-- XXX I'll likely need to think about how to check this better.
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT unique1, (SELECT count(*) FROM tenk1 t2 WHERE t2.thousand = t1.thousand) FROM tenk1 t1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Seq Scan on tenk1 t1 (actual rows=10000 loops=1)
   SubPlan 1
     ->  Result Cache (actual rows=1 loops=10000)
           Cache Key: t1.thousand
           Cache Hits: 5339  Cache Misses: 4661 Cache Evictions: 4056  Cache Overflows: 0
           ->  Aggregate (actual rows=1 loops=4661)
                 ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t2 (actual rows=10 loops=4661)
                       Index Cond: (thousand = t1.thousand)
                       Heap Fetches: 0
(9 rows)

RESET work_mem;
-- Ensure the cache works as expected with a parallel scan.
SET min_parallel_table_scan_size TO 0;
SET parallel_setup_cost TO 0;
SET parallel_tuple_cost TO 0;
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT unique1, (SELECT count(*) FROM tenk1 t2 WHERE t2.thousand = t1.thousand) FROM tenk1 t1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather (actual rows=10000 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on tenk1 t1 (actual rows=3333 loops=3)
   SubPlan 1
     ->  Result Cache (actual rows=1 loops=10000)
           Cache Key: t1.thousand
           Cache Hits: 9000  Cache Misses: 1000 Cache Evictions: 0  Cache Overflows: 0
           ->  Aggregate (actual rows=1 loops=1000)
                 ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t2 (actual rows=10 loops=1000)
                       Index Cond: (thousand = t1.thousand)
                       Heap Fetches: 0
(12 rows)

RESET min_parallel_table_scan_size;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
-- Ensure we get a result cache on the inner side of the nested loop
EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF, SUMMARY OFF)
SELECT COUNT(*),AVG(t1.unique1) FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.twenty;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Nested Loop (actual rows=10000 loops=1)
         ->  Seq Scan on tenk1 t2 (actual rows=10000 loops=1)
         ->  Result Cache (actual rows=1 loops=10000)
               Cache Key: t2.twenty
               Cache Hits: 9980  Cache Misses: 20 Cache Evictions: 0  Cache Overflows: 0
               ->  Index Only Scan using tenk1_unique1 on tenk1 t1 (actual rows=1 loops=20)
                     Index Cond: (unique1 = t2.twenty)
                     Heap Fetches: 0
(9 rows)

-- And check we get the expected results.
SELECT COUNT(*),AVG(t1.unique1) FROM tenk1 t1 INNER JOIN tenk1 t2 ON t1.unique1 = t2.twenty;
 count |        avg         
-------+--------------------
 10000 | 9.5000000000000000
(1 row)

