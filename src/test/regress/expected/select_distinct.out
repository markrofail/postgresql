--
-- SELECT_DISTINCT
--
--
-- awk '{print $3;}' onek.data | sort -n | uniq
--
SELECT DISTINCT two FROM tmp ORDER BY 1;
 two 
-----
   0
   1
(2 rows)

--
-- awk '{print $5;}' onek.data | sort -n | uniq
--
SELECT DISTINCT ten FROM tmp ORDER BY 1;
 ten 
-----
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
(10 rows)

--
-- awk '{print $16;}' onek.data | sort -d | uniq
--
SELECT DISTINCT string4 FROM tmp ORDER BY 1;
 string4 
---------
 AAAAxx
 HHHHxx
 OOOOxx
 VVVVxx
(4 rows)

--
-- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
-- sort +0n -1 +1d -2 +2n -3
--
SELECT DISTINCT two, string4, ten
   FROM tmp
   ORDER BY two using <, string4 using <, ten using <;
 two | string4 | ten 
-----+---------+-----
   0 | AAAAxx  |   0
   0 | AAAAxx  |   2
   0 | AAAAxx  |   4
   0 | AAAAxx  |   6
   0 | AAAAxx  |   8
   0 | HHHHxx  |   0
   0 | HHHHxx  |   2
   0 | HHHHxx  |   4
   0 | HHHHxx  |   6
   0 | HHHHxx  |   8
   0 | OOOOxx  |   0
   0 | OOOOxx  |   2
   0 | OOOOxx  |   4
   0 | OOOOxx  |   6
   0 | OOOOxx  |   8
   0 | VVVVxx  |   0
   0 | VVVVxx  |   2
   0 | VVVVxx  |   4
   0 | VVVVxx  |   6
   0 | VVVVxx  |   8
   1 | AAAAxx  |   1
   1 | AAAAxx  |   3
   1 | AAAAxx  |   5
   1 | AAAAxx  |   7
   1 | AAAAxx  |   9
   1 | HHHHxx  |   1
   1 | HHHHxx  |   3
   1 | HHHHxx  |   5
   1 | HHHHxx  |   7
   1 | HHHHxx  |   9
   1 | OOOOxx  |   1
   1 | OOOOxx  |   3
   1 | OOOOxx  |   5
   1 | OOOOxx  |   7
   1 | OOOOxx  |   9
   1 | VVVVxx  |   1
   1 | VVVVxx  |   3
   1 | VVVVxx  |   5
   1 | VVVVxx  |   7
   1 | VVVVxx  |   9
(40 rows)

--
-- awk '{print $2;}' person.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
-- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
-- sort -n -r | uniq
--
SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
 age 
-----
  98
  88
  78
  68
  60
  58
  50
  48
  40
  38
  34
  30
  28
  25
  24
  23
  20
  19
  18
   8
(20 rows)

--
-- Check mentioning same column more than once
--
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  HashAggregate
         Output: tenk1.two, tenk1.four, tenk1.two
         Group Key: tenk1.two, tenk1.four, tenk1.two
         ->  Seq Scan on public.tenk1
               Output: tenk1.two, tenk1.four, tenk1.two
(7 rows)

SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
 count 
-------
     4
(1 row)

--
-- Compare results between plans using sorting and plans using hash
-- aggregation. Force spilling in both cases by setting work_mem low.
--
SET work_mem='64kB';
-- Produce results with sorting.
SET enable_hashagg=FALSE;
SET jit_above_cost=0;
EXPLAIN (costs off)
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
                   QUERY PLAN                   
------------------------------------------------
 Unique
   ->  Sort
         Sort Key: ((g % 1000))
         ->  Function Scan on generate_series g
(4 rows)

CREATE TABLE distinct_group_1 AS
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
SET jit_above_cost TO DEFAULT;
CREATE TABLE distinct_group_2 AS
SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
SET enable_hashagg=TRUE;
-- Produce results with hash aggregation.
SET enable_sort=FALSE;
SET jit_above_cost=0;
EXPLAIN (costs off)
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
                QUERY PLAN                
------------------------------------------
 HashAggregate
   Group Key: (g % 1000)
   ->  Function Scan on generate_series g
(3 rows)

CREATE TABLE distinct_hash_1 AS
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
SET jit_above_cost TO DEFAULT;
CREATE TABLE distinct_hash_2 AS
SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
SET enable_sort=TRUE;
SET work_mem TO DEFAULT;
-- Compare results
(SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
  UNION ALL
(SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
 ?column? 
----------
(0 rows)

(SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
  UNION ALL
(SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
 ?column? 
----------
(0 rows)

DROP TABLE distinct_hash_1;
DROP TABLE distinct_hash_2;
DROP TABLE distinct_group_1;
DROP TABLE distinct_group_2;
--
-- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
-- very own regression file.
--
CREATE TEMP TABLE disttable (f1 integer);
INSERT INTO DISTTABLE VALUES(1);
INSERT INTO DISTTABLE VALUES(2);
INSERT INTO DISTTABLE VALUES(3);
INSERT INTO DISTTABLE VALUES(NULL);
-- basic cases
SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
 f1 | not 2 
----+-------
  1 | t
  2 | f
  3 | t
    | t
(4 rows)

SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
 f1 | false 
----+-------
  1 | f
  2 | f
  3 | f
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

-- check that optimizer constant-folds it properly
SELECT 1 IS DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

SELECT null IS DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

-- negated form
SELECT 1 IS NOT DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS NOT DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

SELECT null IS NOT DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

CREATE TABLE uqk1(a int, pk int primary key, c int,  d int);
CREATE TABLE uqk2(a int, pk int primary key, c int,  d int);
INSERT INTO uqk1 VALUES(1, 1, 1, 1), (2, 2, 2, 2), (3, 3, 3, 3);
INSERT INTO uqk2 VALUES(1, 1, 1, 1), (4, 4, 4, 4), (5, 5, 5, 5);
ANALYZE uqk1;
ANALYZE uqk2;
-- Test single table
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM uqk1;
    QUERY PLAN    
------------------
 Seq Scan on uqk1
(1 row)

EXPLAIN (COSTS OFF) SELECT DISTINCT c, d FROM uqk1;
          QUERY PLAN          
------------------------------
 Unique
   ->  Sort
         Sort Key: c, d
         ->  Seq Scan on uqk1
(4 rows)

CREATE UNIQUE INDEX uqk1_ukcd ON uqk1(c, d);
EXPLAIN (COSTS OFF) SELECT DISTINCT c, d FROM uqk1;
          QUERY PLAN          
------------------------------
 Unique
   ->  Sort
         Sort Key: c, d
         ->  Seq Scan on uqk1
(4 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT c, d FROM uqk1 WHERE c is NOT NULL;
              QUERY PLAN               
---------------------------------------
 Unique
   ->  Sort
         Sort Key: c, d
         ->  Seq Scan on uqk1
               Filter: (c IS NOT NULL)
(5 rows)

ALTER TABLE uqk1 ALTER COLUMN d SET NOT NULL;
EXPLAIN (COSTS OFF) SELECT DISTINCT c, d FROM uqk1 WHERE c is NOT NULL;
        QUERY PLAN         
---------------------------
 Seq Scan on uqk1
   Filter: (c IS NOT NULL)
(2 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT d FROM uqk1 WHERE c is NOT NULL;
           QUERY PLAN            
---------------------------------
 HashAggregate
   Group Key: d
   ->  Seq Scan on uqk1
         Filter: (c IS NOT NULL)
(4 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT a FROM uqk1 WHERE pk = 1;
     QUERY PLAN     
--------------------
 Seq Scan on uqk1
   Filter: (pk = 1)
(2 rows)

-- Test join
-- both uqk1 (c, d) and uqk2(pk) are unique key, so distinct is not needed.
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.c, uqk1.d FROM uqk1, uqk2
WHERE uqk1.c is NOT NULL AND uqk1.a = uqk2.pk;
           QUERY PLAN            
---------------------------------
 Hash Join
   Hash Cond: (uqk1.a = uqk2.pk)
   ->  Seq Scan on uqk1
         Filter: (c IS NOT NULL)
   ->  Hash
         ->  Seq Scan on uqk2
(6 rows)

-- Distinct is needed since the outer join allows multi null values.
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.pk FROM uqk1 RIGHT JOIN uqk2 ON (uqk1.a = uqk2.pk)
order BY 1;
                 QUERY PLAN                  
---------------------------------------------
 Unique
   ->  Sort
         Sort Key: uqk1.pk
         ->  Hash Right Join
               Hash Cond: (uqk1.a = uqk2.pk)
               ->  Seq Scan on uqk1
               ->  Hash
                     ->  Seq Scan on uqk2
(8 rows)

SELECT DISTINCT uqk1.pk FROM uqk1 RIGHT JOIN uqk2 ON (uqk1.a = uqk2.pk) order BY 1;
 pk 
----
  1
   
(2 rows)

-- Distinct is not needed since uqk1 is the left table in outer join
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.c, uqk1.d FROM uqk1 LEFT JOIN uqk2 ON (uqk1.a = uqk2.pk)
WHERE uqk1.c is NOT NULL order BY 1, 2;
           QUERY PLAN            
---------------------------------
 Sort
   Sort Key: uqk1.c, uqk1.d
   ->  Seq Scan on uqk1
         Filter: (c IS NOT NULL)
(4 rows)

SELECT DISTINCT uqk1.c, uqk1.d FROM uqk1 LEFT JOIN uqk2 ON (uqk1.a = uqk2.pk)
WHERE uqk1.c is NOT NULL order BY 1, 2;
 c | d 
---+---
 1 | 1
 2 | 2
 3 | 3
(3 rows)

-- The combination of UniqueKey is still unique no mather the join clause
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM uqk1, uqk2;
          QUERY PLAN          
------------------------------
 Nested Loop
   ->  Seq Scan on uqk1
   ->  Materialize
         ->  Seq Scan on uqk2
(4 rows)

SELECT DISTINCT * FROM uqk1, uqk2 order BY 1, 2, 3, 4, 5, 6;
 a | pk | c | d | a | pk | c | d 
---+----+---+---+---+----+---+---
 1 |  1 | 1 | 1 | 1 |  1 | 1 | 1
 1 |  1 | 1 | 1 | 4 |  4 | 4 | 4
 1 |  1 | 1 | 1 | 5 |  5 | 5 | 5
 2 |  2 | 2 | 2 | 1 |  1 | 1 | 1
 2 |  2 | 2 | 2 | 4 |  4 | 4 | 4
 2 |  2 | 2 | 2 | 5 |  5 | 5 | 5
 3 |  3 | 3 | 3 | 1 |  1 | 1 | 1
 3 |  3 | 3 | 3 | 4 |  4 | 4 | 4
 3 |  3 | 3 | 3 | 5 |  5 | 5 | 5
(9 rows)

-- Test Semi/Anti JOIN
EXPLAIN (COSTS OFF) SELECT DISTINCT pk FROM uqk1 WHERE d in (SELECT d FROM uqk2);
           QUERY PLAN           
--------------------------------
 Hash Semi Join
   Hash Cond: (uqk1.d = uqk2.d)
   ->  Seq Scan on uqk1
   ->  Hash
         ->  Seq Scan on uqk2
(5 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT pk FROM uqk1 WHERE d NOT in (SELECT d FROM uqk2);
             QUERY PLAN             
------------------------------------
 Seq Scan on uqk1
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Seq Scan on uqk2
(4 rows)

-- Test Unique Key FOR one-row case, DISTINCT is NOT needed as well.
-- uqk1.d is the a uniquekey due to onerow rule. uqk2.pk is pk
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.d FROM uqk1, uqk2 WHERE uqk1.pk = 2 AND uqk1.d = uqk2.pk;
            QUERY PLAN             
-----------------------------------
 Nested Loop
   Join Filter: (uqk1.d = uqk2.pk)
   ->  Seq Scan on uqk1
         Filter: (pk = 2)
   ->  Seq Scan on uqk2
(5 rows)

SELECT DISTINCT uqk1.d FROM uqk1, uqk2 WHERE uqk1.pk = 2 AND uqk1.d = uqk2.pk order BY 1;
 d 
---
(0 rows)

-- Both uqk1.d AND uqk2.c are the a uniquekey due to onerow rule
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.d FROM uqk1, uqk2 WHERE uqk1.pk = 2
AND uqk2.pk = 1 AND uqk1.d = uqk2.d ;
            QUERY PLAN            
----------------------------------
 Nested Loop
   Join Filter: (uqk1.d = uqk2.d)
   ->  Seq Scan on uqk1
         Filter: (pk = 2)
   ->  Seq Scan on uqk2
         Filter: (pk = 1)
(6 rows)

SELECT DISTINCT uqk1.d FROM uqk1, uqk2 WHERE uqk1.pk = 2 AND uqk2.pk = 1
AND uqk1.d = uqk2.d order BY 1;
 d 
---
(0 rows)

-- Both UniqueKey in targetList, so distinct is not needed.
EXPLAIN (COSTS OFF) SELECT DISTINCT uqk1.c, uqk2.c FROM uqk1, uqk2 WHERE uqk1.pk = 2 AND uqk2.pk = 1;
        QUERY PLAN        
--------------------------
 Nested Loop
   ->  Seq Scan on uqk1
         Filter: (pk = 2)
   ->  Seq Scan on uqk2
         Filter: (pk = 1)
(5 rows)

SELECT DISTINCT uqk1.c, uqk2.c FROM uqk1, uqk2 WHERE uqk1.pk = 2 AND uqk2.pk = 1 order BY 1, 2;
 c | c 
---+---
 2 | 1
(1 row)

-- Test SubQuery
-- t2(a, c) is UNIQUE key because of group by
EXPLAIN (COSTS OFF) SELECT DISTINCT t2.a, t2.c FROM uqk1 t1 inner JOIN
(SELECT a, c, sum(pk) as t2b FROM uqk2 group BY a, c) t2
ON (t2.t2b = t1.pk);
              QUERY PLAN               
---------------------------------------
 Hash Join
   Hash Cond: ((sum(uqk2.pk)) = t1.pk)
   ->  HashAggregate
         Group Key: uqk2.a, uqk2.c
         ->  Seq Scan on uqk2
   ->  Hash
         ->  Seq Scan on uqk1 t1
(7 rows)

-- Test partitioned TABLE
CREATE TABLE dist_p (a int, b int NOT NULL, c int NOT NULL, d int) PARTITION BY RANGE (b);
CREATE TABLE dist_p0 PARTITION OF dist_p FOR VALUES FROM (1) to (10);
CREATE TABLE dist_p1 PARTITION OF dist_p FOR VALUES FROM (11) to (20);
-- create unique index on dist_p
CREATE UNIQUE INDEX dist_p_uk_b_c ON dist_p(b, c);
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM dist_p;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on dist_p0 dist_p_1
   ->  Seq Scan on dist_p1 dist_p_2
(3 rows)

DROP INDEX dist_p_uk_b_c;
-- we also support create unqiue index on each child tables
CREATE UNIQUE INDEX dist_p0_uk_bc ON dist_p0(b, c);
-- NOT ok, since dist_p1 have no such INDEX
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM dist_p;
                     QUERY PLAN                      
-----------------------------------------------------
 HashAggregate
   Group Key: dist_p.a, dist_p.b, dist_p.c, dist_p.d
   ->  Append
         ->  Seq Scan on dist_p0 dist_p_1
         ->  Seq Scan on dist_p1 dist_p_2
(5 rows)

CREATE UNIQUE INDEX dist_p1_uk_bc ON dist_p1(b, c);
-- OK now
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM dist_p;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on dist_p0 dist_p_1
   ->  Seq Scan on dist_p1 dist_p_2
(3 rows)

DROP TABLE dist_p;
-- Test partition with different order.
CREATE TABLE p (a INT NOT NULL, b DATE NOT NULL,c INT NOT NULL, d VARCHAR(5) NOT NULL) PARTITION BY LIST (a);
-- First partition with different attr order.
CREATE TABLE p1(d VARCHAR(5) NOT NULL, c INT NOT NULL, b DATE NOT NULL, a INT NOT NULL);
ALTER TABLE p ATTACH PARTITION p1 FOR VALUES IN (1);
-- 2nd partition
CREATE TABLE p2 PARTITION OF p FOR VALUES IN (2);
-- Unique Index locally without partition key.
CREATE UNIQUE index p1_unq_d ON p1(d);
CREATE UNIQUE index p2_unq_d ON p2(d);
-- Unique Index with
CREATE UNIQUE index p_unq_ac ON  p(a, c);
ANALYZE p;
-- d is unique for its owner partition only.
EXPLAIN (COSTS OFF) SELECT DISTINCT d FROM P;
              QUERY PLAN              
--------------------------------------
 Unique
   ->  Sort
         Sort Key: p.d
         ->  Append
               ->  Seq Scan on p1 p_1
               ->  Seq Scan on p2 p_2
(6 rows)

-- d is unique for its owner partition, but this query only talk to one partition.
EXPLAIN (COSTS OFF) SELECT DISTINCT d FROM p WHERE a = 1;
    QUERY PLAN     
-------------------
 Seq Scan on p1 p
   Filter: (a = 1)
(2 rows)

-- (a,c) in unique locally, but constains the partition key.
EXPLAIN (COSTS OFF) SELECT DISTINCT a, c FROM p WHERE a = 1;
    QUERY PLAN     
-------------------
 Seq Scan on p1 p
   Filter: (a = 1)
(2 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT c FROM p WHERE a = 1;
    QUERY PLAN     
-------------------
 Seq Scan on p1 p
   Filter: (a = 1)
(2 rows)

EXPLAIN (COSTS OFF) SELECT DISTINCT a FROM p WHERE c = 1;
        QUERY PLAN        
--------------------------
 Append
   ->  Seq Scan on p1 p_1
         Filter: (c = 1)
   ->  Seq Scan on p2 p_2
         Filter: (c = 1)
(5 rows)

DROP TABLE p;
-- Test some VIEW
CREATE VIEW distinct_v1 as SELECT DISTINCT c, d FROM uqk1 WHERE c is NOT NULL;
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM distinct_v1;
        QUERY PLAN         
---------------------------
 Seq Scan on uqk1
   Filter: (c IS NOT NULL)
(2 rows)

ALTER TABLE uqk1 ALTER COLUMN d DROP NOT NULL;
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM distinct_v1;
              QUERY PLAN               
---------------------------------------
 Unique
   ->  Sort
         Sort Key: uqk1.c, uqk1.d
         ->  Seq Scan on uqk1
               Filter: (c IS NOT NULL)
(5 rows)

-- Test generic plan
ALTER TABLE uqk1 ALTER COLUMN d SET NOT NULL;
prepare pt as SELECT * FROM distinct_v1;
EXPLAIN (COSTS OFF)  execute pt;
        QUERY PLAN         
---------------------------
 Seq Scan on uqk1
   Filter: (c IS NOT NULL)
(2 rows)

ALTER TABLE uqk1 ALTER COLUMN d DROP NOT NULL;
EXPLAIN (COSTS OFF) execute pt;
              QUERY PLAN               
---------------------------------------
 Unique
   ->  Sort
         Sort Key: uqk1.c, uqk1.d
         ->  Seq Scan on uqk1
               Filter: (c IS NOT NULL)
(5 rows)

DEALLOCATE pt;
DROP VIEW distinct_v1;
DROP TABLE uqk1;
DROP TABLE uqk2;
-- Test Whole Row Not NULL cases
CREATE TABLE x (a int UNIQUE);
EXPLAIN (COSTS OFF) SELECT DISTINCT * FROM x WHERE x = '(1)'::x;
         QUERY PLAN         
----------------------------
 Seq Scan on x
   Filter: (x.* = '(1)'::x)
(2 rows)

DROP TABLE x;
