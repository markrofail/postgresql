--
-- SELECT_DISTINCT
--
--
-- awk '{print $3;}' onek.data | sort -n | uniq
--
SELECT DISTINCT two FROM tmp ORDER BY 1;
 two 
-----
   0
   1
(2 rows)

--
-- awk '{print $5;}' onek.data | sort -n | uniq
--
SELECT DISTINCT ten FROM tmp ORDER BY 1;
 ten 
-----
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
(10 rows)

--
-- awk '{print $16;}' onek.data | sort -d | uniq
--
SELECT DISTINCT string4 FROM tmp ORDER BY 1;
 string4 
---------
 AAAAxx
 HHHHxx
 OOOOxx
 VVVVxx
(4 rows)

--
-- awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
-- sort +0n -1 +1d -2 +2n -3
--
SELECT DISTINCT two, string4, ten
   FROM tmp
   ORDER BY two using <, string4 using <, ten using <;
 two | string4 | ten 
-----+---------+-----
   0 | AAAAxx  |   0
   0 | AAAAxx  |   2
   0 | AAAAxx  |   4
   0 | AAAAxx  |   6
   0 | AAAAxx  |   8
   0 | HHHHxx  |   0
   0 | HHHHxx  |   2
   0 | HHHHxx  |   4
   0 | HHHHxx  |   6
   0 | HHHHxx  |   8
   0 | OOOOxx  |   0
   0 | OOOOxx  |   2
   0 | OOOOxx  |   4
   0 | OOOOxx  |   6
   0 | OOOOxx  |   8
   0 | VVVVxx  |   0
   0 | VVVVxx  |   2
   0 | VVVVxx  |   4
   0 | VVVVxx  |   6
   0 | VVVVxx  |   8
   1 | AAAAxx  |   1
   1 | AAAAxx  |   3
   1 | AAAAxx  |   5
   1 | AAAAxx  |   7
   1 | AAAAxx  |   9
   1 | HHHHxx  |   1
   1 | HHHHxx  |   3
   1 | HHHHxx  |   5
   1 | HHHHxx  |   7
   1 | HHHHxx  |   9
   1 | OOOOxx  |   1
   1 | OOOOxx  |   3
   1 | OOOOxx  |   5
   1 | OOOOxx  |   7
   1 | OOOOxx  |   9
   1 | VVVVxx  |   1
   1 | VVVVxx  |   3
   1 | VVVVxx  |   5
   1 | VVVVxx  |   7
   1 | VVVVxx  |   9
(40 rows)

--
-- awk '{print $2;}' person.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
-- awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
-- awk 'BEGIN{FS="      ";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
-- sort -n -r | uniq
--
SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
 age 
-----
  98
  88
  78
  68
  60
  58
  50
  48
  40
  38
  34
  30
  28
  25
  24
  23
  20
  19
  18
   8
(20 rows)

--
-- Check mentioning same column more than once
--
EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  HashAggregate
         Output: tenk1.two, tenk1.four, tenk1.two
         Group Key: tenk1.two, tenk1.four, tenk1.two
         ->  Seq Scan on public.tenk1
               Output: tenk1.two, tenk1.four, tenk1.two
(7 rows)

SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss;
 count 
-------
     4
(1 row)

--
-- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
-- very own regression file.
--
CREATE TEMP TABLE disttable (f1 integer);
INSERT INTO DISTTABLE VALUES(1);
INSERT INTO DISTTABLE VALUES(2);
INSERT INTO DISTTABLE VALUES(3);
INSERT INTO DISTTABLE VALUES(NULL);
-- basic cases
SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
 f1 | not 2 
----+-------
  1 | t
  2 | f
  3 | t
    | t
(4 rows)

SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
 f1 | false 
----+-------
  1 | f
  2 | f
  3 | f
    | f
(4 rows)

SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
 f1 | not null 
----+----------
  1 | t
  2 | t
  3 | t
    | f
(4 rows)

-- check that optimizer constant-folds it properly
SELECT 1 IS DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

SELECT null IS DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

-- negated form
SELECT 1 IS NOT DISTINCT FROM 2 as "no";
 no 
----
 f
(1 row)

SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
 yes 
-----
 t
(1 row)

SELECT 2 IS NOT DISTINCT FROM null as "no";
 no 
----
 f
(1 row)

SELECT null IS NOT DISTINCT FROM null as "yes";
 yes 
-----
 t
(1 row)

-- index only skip scan
SELECT DISTINCT four FROM tenk1;
 four 
------
    0
    1
    2
    3
(4 rows)

SELECT DISTINCT four FROM tenk1 WHERE four = 1;
 four 
------
    1
(1 row)

SELECT DISTINCT four FROM tenk1 ORDER BY four DESC;
 four 
------
    3
    2
    1
    0
(4 rows)

CREATE TABLE distinct_a (a int, b int, c int);
INSERT INTO distinct_a (
    SELECT five, hundred, 10 FROM
    generate_series(1, 5) five,
    generate_series(1, 10000) hundred
);
CREATE INDEX ON distinct_a (a, b);
ANALYZE distinct_a;
-- test index skip scan with a condition on a non unique field
SELECT DISTINCT ON (a) a, b FROM distinct_a WHERE b = 2;
 a | b 
---+---
 1 | 2
 2 | 2
 3 | 2
 4 | 2
 5 | 2
(5 rows)

-- test index skip scan backwards
SELECT DISTINCT ON (a) a, b FROM distinct_a ORDER BY a DESC, b DESC;
 a |   b   
---+-------
 5 | 10000
 4 | 10000
 3 | 10000
 2 | 10000
 1 | 10000
(5 rows)

-- test opposite scan/index directions inside a cursor
-- forward/backward
BEGIN;
DECLARE c SCROLL CURSOR FOR
SELECT DISTINCT ON (a) a,b FROM distinct_a ORDER BY a, b;
FETCH FROM c;
 a | b 
---+---
 1 | 1
(1 row)

FETCH BACKWARD FROM c;
 a | b 
---+---
(0 rows)

FETCH 6 FROM c;
 a | b 
---+---
 1 | 1
 2 | 1
 3 | 1
 4 | 1
 5 | 1
(5 rows)

FETCH BACKWARD 6 FROM c;
 a | b 
---+---
 5 | 1
 4 | 1
 3 | 1
 2 | 1
 1 | 1
(5 rows)

FETCH 6 FROM c;
 a | b 
---+---
 1 | 1
 2 | 1
 3 | 1
 4 | 1
 5 | 1
(5 rows)

FETCH BACKWARD 6 FROM c;
 a | b 
---+---
 5 | 1
 4 | 1
 3 | 1
 2 | 1
 1 | 1
(5 rows)

END;
-- backward/forward
BEGIN;
DECLARE c SCROLL CURSOR FOR
SELECT DISTINCT ON (a) a,b FROM distinct_a ORDER BY a DESC, b DESC;
FETCH FROM c;
 a |   b   
---+-------
 5 | 10000
(1 row)

FETCH BACKWARD FROM c;
 a | b 
---+---
(0 rows)

FETCH 6 FROM c;
 a |   b   
---+-------
 5 | 10000
 4 | 10000
 3 | 10000
 2 | 10000
 1 | 10000
(5 rows)

FETCH BACKWARD 6 FROM c;
 a |   b   
---+-------
 1 | 10000
 2 | 10000
 3 | 10000
 4 | 10000
 5 | 10000
(5 rows)

FETCH 6 FROM c;
 a |   b   
---+-------
 5 | 10000
 4 | 10000
 3 | 10000
 2 | 10000
 1 | 10000
(5 rows)

FETCH BACKWARD 6 FROM c;
 a |   b   
---+-------
 1 | 10000
 2 | 10000
 3 | 10000
 4 | 10000
 5 | 10000
(5 rows)

END;
DROP TABLE distinct_a;
-- test missing values and skipping from the end
CREATE TABLE distinct_abc(a int, b int, c int);
CREATE INDEX ON distinct_abc(a, b, c);
INSERT INTO distinct_abc
	VALUES (1, 1, 1),
		   (1, 1, 2),
		   (1, 2, 2),
		   (1, 2, 3),
		   (2, 2, 1),
		   (2, 2, 3),
		   (3, 1, 1),
		   (3, 1, 2),
		   (3, 2, 2),
		   (3, 2, 3);
EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (a) a,b,c FROM distinct_abc WHERE c = 2;
                          QUERY PLAN                          
--------------------------------------------------------------
 Index Only Scan using distinct_abc_a_b_c_idx on distinct_abc
   Skip scan mode: true
   Index Cond: (c = 2)
(3 rows)

BEGIN;
DECLARE c SCROLL CURSOR FOR
SELECT DISTINCT ON (a) a,b,c FROM distinct_abc WHERE c = 2;
FETCH ALL FROM c;
 a | b | c 
---+---+---
 1 | 1 | 2
 3 | 1 | 2
(2 rows)

FETCH BACKWARD ALL FROM c;
 a | b | c 
---+---+---
 3 | 1 | 2
 1 | 1 | 2
(2 rows)

END;
EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (a) a,b,c FROM distinct_abc WHERE c = 2
ORDER BY a DESC, b DESC;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Index Only Scan Backward using distinct_abc_a_b_c_idx on distinct_abc
   Skip scan mode: true
   Index Cond: (c = 2)
(3 rows)

BEGIN;
DECLARE c SCROLL CURSOR FOR
SELECT DISTINCT ON (a) a,b,c FROM distinct_abc WHERE c = 2
ORDER BY a DESC, b DESC;
FETCH ALL FROM c;
 a | b | c 
---+---+---
 3 | 2 | 2
 1 | 2 | 2
(2 rows)

FETCH BACKWARD ALL FROM c;
 a | b | c 
---+---+---
 1 | 2 | 2
 3 | 2 | 2
(2 rows)

END;
DROP TABLE distinct_abc;
-- index skip scan
SELECT DISTINCT ON (four) four, ten
FROM tenk1 ORDER BY four;
 four | ten 
------+-----
    0 |   0
    1 |   9
    2 |   0
    3 |   1
(4 rows)

SELECT DISTINCT ON (four) four, ten
FROM tenk1 WHERE four = 1 ORDER BY four;
 four | ten 
------+-----
    1 |   9
(1 row)

EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (four) four, ten
FROM tenk1 ORDER BY four;
              QUERY PLAN              
--------------------------------------
 Index Scan using tenk1_four on tenk1
   Skip scan mode: true
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (four) four, ten
FROM tenk1 WHERE four = 1 ORDER BY four;
                    QUERY PLAN                     
---------------------------------------------------
 Result
   ->  Unique
         ->  Bitmap Heap Scan on tenk1
               Recheck Cond: (four = 1)
               ->  Bitmap Index Scan on tenk1_four
                     Index Cond: (four = 1)
(6 rows)

-- check colums order
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

CREATE INDEX tenk1_four_ten on tenk1 (four, ten);
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE four = 0;
 four | ten 
------+-----
    0 |   0
    0 |   2
    0 |   4
    0 |   6
    0 |   8
(5 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_four_ten on tenk1
   Skip scan mode: true
   Index Cond: (ten = 2)
(3 rows)

-- test uniq_distinct_pathkeys
EXPLAIN (COSTS OFF)
SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE four = 0;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_four_ten on tenk1
   Skip scan mode: true
   Index Cond: (four = 0)
(3 rows)

DROP INDEX tenk1_four_ten;
CREATE INDEX tenk1_ten_four on tenk1 (ten, four);
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
 four 
------
    0
    2
(2 rows)

SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE ten = 2;
 four | ten 
------+-----
    0 |   2
    2 |   2
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE ten = 2;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_ten_four on tenk1
   Skip scan mode: true
   Index Cond: (ten = 2)
(3 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT on (four, ten) four, ten FROM tenk1 WHERE ten = 2;
                  QUERY PLAN                   
-----------------------------------------------
 Index Only Scan using tenk1_ten_four on tenk1
   Skip scan mode: true
   Index Cond: (ten = 2)
(3 rows)

DROP INDEX tenk1_ten_four;
-- check projection case
SELECT DISTINCT four, four FROM tenk1 WHERE ten = 2;
 four | four 
------+------
    0 |    0
    2 |    2
(2 rows)

SELECT DISTINCT four, 1 FROM tenk1 WHERE ten = 2;
 four | ?column? 
------+----------
    2 |        1
    0 |        1
(2 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1;
                QUERY PLAN                 
-------------------------------------------
 Index Only Scan using tenk1_four on tenk1
   Skip scan mode: true
(2 rows)

-- test cursor forward/backward movements
BEGIN;
DECLARE c SCROLL CURSOR FOR SELECT DISTINCT four FROM tenk1;
FETCH FROM c;
 four 
------
    0
(1 row)

FETCH BACKWARD FROM c;
 four 
------
(0 rows)

FETCH 5 FROM c;
 four 
------
    0
    1
    2
    3
(4 rows)

FETCH BACKWARD 5 FROM c;
 four 
------
    3
    2
    1
    0
(4 rows)

FETCH 5 FROM c;
 four 
------
    0
    1
    2
    3
(4 rows)

FETCH BACKWARD 5 FROM c;
 four 
------
    3
    2
    1
    0
(4 rows)

END;
-- test tuples visibility
CREATE TABLE distinct_visibility (a int, b int);
INSERT INTO distinct_visibility (select a, b from generate_series(1,5) a, generate_series(1, 10000) b);
CREATE INDEX ON distinct_visibility (a, b);
ANALYZE distinct_visibility;
SELECT DISTINCT ON (a) a, b FROM distinct_visibility ORDER BY a, b;
 a | b 
---+---
 1 | 1
 2 | 1
 3 | 1
 4 | 1
 5 | 1
(5 rows)

DELETE FROM distinct_visibility WHERE a = 2 and b = 1;
SELECT DISTINCT ON (a) a, b FROM distinct_visibility ORDER BY a, b;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 1
 4 | 1
 5 | 1
(5 rows)

SELECT DISTINCT ON (a) a, b FROM distinct_visibility ORDER BY a DESC, b DESC;
 a |   b   
---+-------
 5 | 10000
 4 | 10000
 3 | 10000
 2 | 10000
 1 | 10000
(5 rows)

DELETE FROM distinct_visibility WHERE a = 2 and b = 10000;
SELECT DISTINCT ON (a) a, b FROM distinct_visibility ORDER BY a DESC, b DESC;
 a |   b   
---+-------
 5 | 10000
 4 | 10000
 3 | 10000
 2 |  9999
 1 | 10000
(5 rows)

DROP TABLE distinct_visibility;
-- test page boundaries
CREATE TABLE distinct_boundaries AS
    SELECT a, b::int2 b, (b % 2)::int2 c FROM
        generate_series(1, 5) a,
        generate_series(1,366) b;
CREATE INDEX ON distinct_boundaries (a, b, c);
ANALYZE distinct_boundaries;
EXPLAIN (COSTS OFF)
SELECT DISTINCT ON (a) a, b, c from distinct_boundaries
WHERE b >= 1 and c = 0 ORDER BY a, b;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Index Only Scan using distinct_boundaries_a_b_c_idx on distinct_boundaries
   Skip scan mode: true
   Index Cond: ((b >= 1) AND (c = 0))
(3 rows)

SELECT DISTINCT ON (a) a, b, c from distinct_boundaries
WHERE b >= 1 and c = 0 ORDER BY a, b;
 a | b | c 
---+---+---
 1 | 2 | 0
 2 | 2 | 0
 3 | 2 | 0
 4 | 2 | 0
 5 | 2 | 0
(5 rows)

DROP TABLE distinct_boundaries;
