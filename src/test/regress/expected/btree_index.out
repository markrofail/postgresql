--
-- BTREE_INDEX
-- test retrieval of min/max keys for each index
--
SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno < 1;
 seqno |   random   
-------+------------
     0 | 1935401906
(1 row)

SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno >= 9999;
 seqno |   random   
-------+------------
  9999 | 1227676208
(1 row)

SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno = 4500;
 seqno |   random   
-------+------------
  4500 | 2080851358
(1 row)

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno < '1'::name;
 seqno |   random   
-------+------------
 0     | 1935401906
(1 row)

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno >= '9999'::name;
 seqno |   random   
-------+------------
 9999  | 1227676208
(1 row)

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno = '4500'::name;
 seqno |   random   
-------+------------
 4500  | 2080851358
(1 row)

SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno < '1'::text;
 seqno |   random   
-------+------------
 0     | 1935401906
(1 row)

SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno >= '9999'::text;
 seqno |   random   
-------+------------
 9999  | 1227676208
(1 row)

SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno = '4500'::text;
 seqno |   random   
-------+------------
 4500  | 2080851358
(1 row)

SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno < '1'::float8;
 seqno |   random   
-------+------------
     0 | 1935401906
(1 row)

SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno >= '9999'::float8;
 seqno |   random   
-------+------------
  9999 | 1227676208
(1 row)

SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno = '4500'::float8;
 seqno |   random   
-------+------------
  4500 | 2080851358
(1 row)

--
-- Check correct optimization of LIKE (special index operator support)
-- for both indexscan and bitmapscan cases
--
set enable_seqscan to false;
set enable_indexscan to true;
set enable_bitmapscan to false;
explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Only Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= 'RI_FKey'::text) AND (proname < 'RI_FKez'::text))
   Filter: (proname ~~ 'RI\_FKey%del'::text)
(3 rows)

select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
        proname         
------------------------
 RI_FKey_cascade_del
 RI_FKey_noaction_del
 RI_FKey_restrict_del
 RI_FKey_setdefault_del
 RI_FKey_setnull_del
(5 rows)

explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Index Only Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= '00'::text) AND (proname < '01'::text))
   Filter: (proname ~~* '00%foo'::text)
(3 rows)

select proname from pg_proc where proname ilike '00%foo' order by 1;
 proname 
---------
(0 rows)

explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Index Only Scan using pg_proc_proname_args_nsp_index on pg_proc
   Filter: (proname ~~* 'ri%foo'::text)
(2 rows)

set enable_indexscan to false;
set enable_bitmapscan to true;
explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Sort
   Sort Key: proname
   ->  Bitmap Heap Scan on pg_proc
         Filter: (proname ~~ 'RI\_FKey%del'::text)
         ->  Bitmap Index Scan on pg_proc_proname_args_nsp_index
               Index Cond: ((proname >= 'RI_FKey'::text) AND (proname < 'RI_FKez'::text))
(6 rows)

select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1;
        proname         
------------------------
 RI_FKey_cascade_del
 RI_FKey_noaction_del
 RI_FKey_restrict_del
 RI_FKey_setdefault_del
 RI_FKey_setnull_del
(5 rows)

explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Sort Key: proname
   ->  Bitmap Heap Scan on pg_proc
         Filter: (proname ~~* '00%foo'::text)
         ->  Bitmap Index Scan on pg_proc_proname_args_nsp_index
               Index Cond: ((proname >= '00'::text) AND (proname < '01'::text))
(6 rows)

select proname from pg_proc where proname ilike '00%foo' order by 1;
 proname 
---------
(0 rows)

explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Index Only Scan using pg_proc_proname_args_nsp_index on pg_proc
   Filter: (proname ~~* 'ri%foo'::text)
(2 rows)

reset enable_seqscan;
reset enable_indexscan;
reset enable_bitmapscan;
--
-- Test B-tree fast path (cache rightmost leaf page) optimization.
--
-- First create a tree that's at least three levels deep (i.e. has one level
-- between the root and leaf levels). The text inserted is long.  It won't be
-- compressed because we use plain storage in the table.  Only a few index
-- tuples fit on each internal page, allowing us to get a tall tree with few
-- pages.  (A tall tree is required to trigger caching.)
--
-- The text column must be the leading column in the index, since suffix
-- truncation would otherwise truncate tuples on internal pages, leaving us
-- with a short tree.
create table btree_tall_tbl(id int4, t text);
alter table btree_tall_tbl alter COLUMN t set storage plain;
create index btree_tall_idx on btree_tall_tbl (t, id) with (fillfactor = 10);
insert into btree_tall_tbl select g, repeat('x', 250)
from generate_series(1, 130) g;
--
-- Test vacuum_cleanup_index_scale_factor
--
-- Simple create
create table btree_test(a int);
create index btree_idx1 on btree_test(a) with (vacuum_cleanup_index_scale_factor = 40.0);
select reloptions from pg_class WHERE oid = 'btree_idx1'::regclass;
                reloptions                
------------------------------------------
 {vacuum_cleanup_index_scale_factor=40.0}
(1 row)

-- Fail while setting improper values
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = -10.0);
ERROR:  value -10.0 out of bounds for option "vacuum_cleanup_index_scale_factor"
DETAIL:  Valid values are between "0.000000" and "10000000000.000000".
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = 100.0);
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = 'string');
ERROR:  invalid value for floating point option "vacuum_cleanup_index_scale_factor": string
create index btree_idx_err on btree_test(a) with (vacuum_cleanup_index_scale_factor = true);
ERROR:  invalid value for floating point option "vacuum_cleanup_index_scale_factor": true
-- Simple ALTER INDEX
alter index btree_idx1 set (vacuum_cleanup_index_scale_factor = 70.0);
select reloptions from pg_class WHERE oid = 'btree_idx1'::regclass;
                reloptions                
------------------------------------------
 {vacuum_cleanup_index_scale_factor=70.0}
(1 row)

--
-- Test for multilevel page deletion
--
CREATE TABLE delete_test_table (a bigint, b bigint, c bigint, d bigint);
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,80000) i;
ALTER TABLE delete_test_table ADD PRIMARY KEY (a,b,c,d);
-- Delete most entries, and vacuum, deleting internal pages and creating "fast
-- root"
DELETE FROM delete_test_table WHERE a < 79990;
VACUUM delete_test_table;
--
-- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
-- WAL record type). This happens when a "fast root" page is split.  This
-- also creates coverage for nbtree FSM page recycling.
--
-- The vacuum above should've turned the leaf page into a fast root. We just
-- need to insert some rows to cause the fast root page to split.
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,1000) i;
---
--- Test B-tree distance ordering
---
SET enable_bitmapscan = OFF;
-- temporarily disable bt_i4_index index on bt_i4_heap(seqno)
UPDATE pg_index SET indisvalid = false WHERE indexrelid = 'bt_i4_index'::regclass;
CREATE INDEX bt_i4_heap_random_idx ON bt_i4_heap USING btree(random, seqno);
-- test unsupported orderings (by non-first index attribute or by more than one order keys)
EXPLAIN (COSTS OFF) SELECT * FROM bt_i4_heap ORDER BY seqno <-> 0;
          QUERY PLAN          
------------------------------
 Sort
   Sort Key: ((seqno <-> 0))
   ->  Seq Scan on bt_i4_heap
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM bt_i4_heap ORDER BY random <-> 0, seqno <-> 0;
                  QUERY PLAN                   
-----------------------------------------------
 Sort
   Sort Key: ((random <-> 0)), ((seqno <-> 0))
   ->  Seq Scan on bt_i4_heap
(3 rows)

EXPLAIN (COSTS OFF) SELECT * FROM bt_i4_heap ORDER BY random <-> 0, random <-> 1;
                   QUERY PLAN                   
------------------------------------------------
 Sort
   Sort Key: ((random <-> 0)), ((random <-> 1))
   ->  Seq Scan on bt_i4_heap
(3 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 4000000;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Index Only Scan using bt_i4_heap_random_idx on bt_i4_heap
   Index Cond: ((random > 1000000) AND (ROW(random, seqno) < ROW(6000000, 0)))
   Order By: (random <-> 4000000)
(3 rows)

SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 4000000;
 seqno | random  
-------+---------
  6448 | 4157193
  9004 | 3783884
  4408 | 4488889
  8391 | 4825069
  8984 | 3148979
  1829 | 3053937
  6262 | 3013326
  5380 | 3000193
  9142 | 2847247
  8411 | 2809541
  2859 | 5224694
  6320 | 5257716
  2126 | 2648497
  8729 | 5450460
  6862 | 5556001
  1836 | 5593978
  2681 | 2321799
  2893 | 1919087
   210 | 1809552
(19 rows)

SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 10000000;
 seqno | random  
-------+---------
  1836 | 5593978
  6862 | 5556001
  8729 | 5450460
  6320 | 5257716
  2859 | 5224694
  8391 | 4825069
  4408 | 4488889
  6448 | 4157193
  9004 | 3783884
  8984 | 3148979
  1829 | 3053937
  6262 | 3013326
  5380 | 3000193
  9142 | 2847247
  8411 | 2809541
  2126 | 2648497
  2681 | 2321799
  2893 | 1919087
   210 | 1809552
(19 rows)

SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 0;
 seqno | random  
-------+---------
   210 | 1809552
  2893 | 1919087
  2681 | 2321799
  2126 | 2648497
  8411 | 2809541
  9142 | 2847247
  5380 | 3000193
  6262 | 3013326
  1829 | 3053937
  8984 | 3148979
  9004 | 3783884
  6448 | 4157193
  4408 | 4488889
  8391 | 4825069
  2859 | 5224694
  6320 | 5257716
  8729 | 5450460
  6862 | 5556001
  1836 | 5593978
(19 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM bt_i4_heap
WHERE
	random > 1000000 AND (random, seqno) < (6000000, 0) AND
	random IN (1809552, 1919087, 2321799, 2648497, 3000193, 3013326, 4157193, 4488889, 5257716, 5593978, NULL)
ORDER BY random <-> 3000000;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using bt_i4_heap_random_idx on bt_i4_heap
   Index Cond: ((random > 1000000) AND (ROW(random, seqno) < ROW(6000000, 0)) AND (random = ANY ('{1809552,1919087,2321799,2648497,3000193,3013326,4157193,4488889,5257716,5593978,NULL}'::integer[])))
   Order By: (random <-> 3000000)
(3 rows)

SELECT * FROM bt_i4_heap
WHERE
	random > 1000000 AND (random, seqno) < (6000000, 0) AND
	random IN (1809552, 1919087, 2321799, 2648497, 3000193, 3013326, 4157193, 4488889, 5257716, 5593978, NULL)
ORDER BY random <-> 3000000;
 seqno | random  
-------+---------
  5380 | 3000193
  6262 | 3013326
  2126 | 2648497
  2681 | 2321799
  2893 | 1919087
  6448 | 4157193
   210 | 1809552
  4408 | 4488889
  6320 | 5257716
  1836 | 5593978
(10 rows)

DROP INDEX bt_i4_heap_random_idx;
CREATE INDEX bt_i4_heap_random_idx ON bt_i4_heap USING btree(random DESC, seqno);
SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 4000000;
 seqno | random  
-------+---------
  6448 | 4157193
  9004 | 3783884
  4408 | 4488889
  8391 | 4825069
  8984 | 3148979
  1829 | 3053937
  6262 | 3013326
  5380 | 3000193
  9142 | 2847247
  8411 | 2809541
  2859 | 5224694
  6320 | 5257716
  2126 | 2648497
  8729 | 5450460
  6862 | 5556001
  1836 | 5593978
  2681 | 2321799
  2893 | 1919087
   210 | 1809552
(19 rows)

SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 10000000;
 seqno | random  
-------+---------
  1836 | 5593978
  6862 | 5556001
  8729 | 5450460
  6320 | 5257716
  2859 | 5224694
  8391 | 4825069
  4408 | 4488889
  6448 | 4157193
  9004 | 3783884
  8984 | 3148979
  1829 | 3053937
  6262 | 3013326
  5380 | 3000193
  9142 | 2847247
  8411 | 2809541
  2126 | 2648497
  2681 | 2321799
  2893 | 1919087
   210 | 1809552
(19 rows)

SELECT * FROM bt_i4_heap
WHERE random > 1000000 AND (random, seqno) < (6000000, 0)
ORDER BY random <-> 0;
 seqno | random  
-------+---------
   210 | 1809552
  2893 | 1919087
  2681 | 2321799
  2126 | 2648497
  8411 | 2809541
  9142 | 2847247
  5380 | 3000193
  6262 | 3013326
  1829 | 3053937
  8984 | 3148979
  9004 | 3783884
  6448 | 4157193
  4408 | 4488889
  8391 | 4825069
  2859 | 5224694
  6320 | 5257716
  8729 | 5450460
  6862 | 5556001
  1836 | 5593978
(19 rows)

DROP INDEX bt_i4_heap_random_idx;
-- test parallel KNN scan
-- Serializable isolation would disable parallel query, so explicitly use an
-- arbitrary other level.
BEGIN ISOLATION LEVEL REPEATABLE READ;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET max_parallel_workers = 4;
SET max_parallel_workers_per_gather = 4;
SET cpu_operator_cost = 0;
RESET enable_indexscan;
\set bt_knn_row_count 100000
CREATE TABLE bt_knn_test AS SELECT i * 10 AS i FROM generate_series(1, :bt_knn_row_count) i;
CREATE INDEX bt_knn_test_idx ON bt_knn_test (i);
ALTER TABLE bt_knn_test SET (parallel_workers = 4);
ANALYZE bt_knn_test;
-- set the point inside the range
\set bt_knn_point (4 * :bt_knn_row_count + 3)
CREATE TABLE bt_knn_test2 AS
	SELECT row_number() OVER (ORDER BY i * 10 <-> :bt_knn_point) AS n, i * 10 AS i
	FROM generate_series(1, :bt_knn_row_count) i;
SET enable_sort = OFF;
EXPLAIN (COSTS OFF)
WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.n = t2.n)
   Join Filter: (t1.i <> t2.i)
   ->  Subquery Scan on t1
         ->  WindowAgg
               ->  Gather Merge
                     Workers Planned: 4
                     ->  Parallel Index Only Scan using bt_knn_test_idx on bt_knn_test
                           Order By: (i <-> 400003)
   ->  Hash
         ->  Gather
               Workers Planned: 4
               ->  Parallel Seq Scan on bt_knn_test2 t2
(13 rows)

WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
 n | i | i 
---+---+---
(0 rows)

RESET enable_sort;
DROP TABLE bt_knn_test2;
-- set the point to the right of the range
\set bt_knn_point (11 * :bt_knn_row_count)
CREATE TABLE bt_knn_test2 AS
	SELECT row_number() OVER (ORDER BY i * 10 <-> :bt_knn_point) AS n, i * 10 AS i
	FROM generate_series(1, :bt_knn_row_count) i;
SET enable_sort = OFF;
EXPLAIN (COSTS OFF)
WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.n = t2.n)
   Join Filter: (t1.i <> t2.i)
   ->  Subquery Scan on t1
         ->  WindowAgg
               ->  Gather Merge
                     Workers Planned: 4
                     ->  Parallel Index Only Scan using bt_knn_test_idx on bt_knn_test
                           Order By: (i <-> 1100000)
   ->  Hash
         ->  Gather
               Workers Planned: 4
               ->  Parallel Seq Scan on bt_knn_test2 t2
(13 rows)

WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
 n | i | i 
---+---+---
(0 rows)

RESET enable_sort;
DROP TABLE bt_knn_test2;
-- set the point to the left of the range
\set bt_knn_point (-:bt_knn_row_count)
CREATE TABLE bt_knn_test2 AS
	SELECT row_number() OVER (ORDER BY i * 10 <-> :bt_knn_point) AS n, i * 10 AS i
	FROM generate_series(1, :bt_knn_row_count) i;
SET enable_sort = OFF;
EXPLAIN (COSTS OFF)
WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.n = t2.n)
   Join Filter: (t1.i <> t2.i)
   ->  Subquery Scan on t1
         ->  WindowAgg
               ->  Gather Merge
                     Workers Planned: 4
                     ->  Parallel Index Only Scan using bt_knn_test_idx on bt_knn_test
                           Order By: (i <-> '-100000'::integer)
   ->  Hash
         ->  Gather
               Workers Planned: 4
               ->  Parallel Seq Scan on bt_knn_test2 t2
(13 rows)

WITH bt_knn_test1 AS (
	SELECT row_number() OVER (ORDER BY i <-> :bt_knn_point) AS n, i FROM bt_knn_test
)
SELECT * FROM bt_knn_test1 t1 JOIN bt_knn_test2 t2 USING (n) WHERE t1.i <> t2.i;
 n | i | i 
---+---+---
(0 rows)

RESET enable_sort;
DROP TABLE bt_knn_test;
\set knn_row_count 30000
CREATE TABLE bt_knn_test AS SELECT i FROM generate_series(1, 10) i, generate_series(1, :knn_row_count) j;
CREATE INDEX bt_knn_test_idx ON bt_knn_test (i);
ALTER TABLE bt_knn_test SET (parallel_workers = 4);
ANALYZE bt_knn_test;
SET enable_sort = OFF;
EXPLAIN (COSTS OFF)
WITH
t1 AS (
	SELECT row_number() OVER () AS n, i
	FROM bt_knn_test
	WHERE i IN (3, 4, 7, 8, 2)
	ORDER BY i <-> 4
),
t2 AS (
	SELECT i * :knn_row_count + j AS n, (ARRAY[4, 3, 2, 7, 8])[i + 1] AS i
	FROM generate_series(0, 4) i, generate_series(1, :knn_row_count) j
)
SELECT * FROM t1 JOIN t2 USING (n) WHERE t1.i <> t2.i;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (t1.n = ((i.i * 30000) + j.j))
   Join Filter: (t1.i <> ('{4,3,2,7,8}'::integer[])[(i.i + 1)])
   ->  Subquery Scan on t1
         ->  WindowAgg
               ->  Gather Merge
                     Workers Planned: 4
                     ->  Parallel Index Only Scan using bt_knn_test_idx on bt_knn_test
                           Index Cond: (i = ANY ('{3,4,7,8,2}'::integer[]))
                           Order By: (i <-> 4)
   ->  Hash
         ->  Nested Loop
               ->  Function Scan on generate_series i
               ->  Function Scan on generate_series j
(14 rows)

WITH
t1 AS (
	SELECT row_number() OVER () AS n, i
	FROM bt_knn_test
	WHERE i IN (3, 4, 7, 8, 2)
	ORDER BY i <-> 4
),
t2 AS (
	SELECT i * :knn_row_count + j AS n, (ARRAY[4, 3, 2, 7, 8])[i + 1] AS i
	FROM generate_series(0, 4) i, generate_series(1, :knn_row_count) j
)
SELECT * FROM t1 JOIN t2 USING (n) WHERE t1.i <> t2.i;
 n | i | i 
---+---+---
(0 rows)

RESET enable_sort;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
RESET min_parallel_table_scan_size;
RESET max_parallel_workers;
RESET max_parallel_workers_per_gather;
RESET cpu_operator_cost;
ROLLBACK;
-- enable bt_i4_index index on bt_i4_heap(seqno)
UPDATE pg_index SET indisvalid = true WHERE indexrelid = 'bt_i4_index'::regclass;
CREATE TABLE tenk3 AS SELECT thousand, tenthous FROM tenk1;
INSERT INTO tenk3 VALUES (NULL, 1), (NULL, 2), (NULL, 3);
-- Test distance ordering by ASC index
CREATE INDEX tenk3_idx ON tenk3 USING btree(thousand, tenthous);
EXPLAIN (COSTS OFF)
SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000)
ORDER BY thousand <-> 998;
                        QUERY PLAN                         
-----------------------------------------------------------
 Index Only Scan using tenk3_idx on tenk3
   Index Cond: (ROW(thousand, tenthous) >= ROW(997, 5000))
   Order By: (thousand <-> 998)
(3 rows)

SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000)
ORDER BY thousand <-> 998;
 thousand | tenthous 
----------+----------
      998 |      998
      998 |     1998
      998 |     2998
      998 |     3998
      998 |     4998
      998 |     5998
      998 |     6998
      998 |     7998
      998 |     8998
      998 |     9998
      999 |      999
      999 |     1999
      999 |     2999
      999 |     3999
      999 |     4999
      999 |     5999
      999 |     6999
      999 |     7999
      999 |     8999
      999 |     9999
      997 |     9997
      997 |     8997
      997 |     7997
      997 |     6997
      997 |     5997
(25 rows)

SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000)
ORDER BY thousand <-> 0;
 thousand | tenthous 
----------+----------
      997 |     5997
      997 |     6997
      997 |     7997
      997 |     8997
      997 |     9997
      998 |      998
      998 |     1998
      998 |     2998
      998 |     3998
      998 |     4998
      998 |     5998
      998 |     6998
      998 |     7998
      998 |     8998
      998 |     9998
      999 |      999
      999 |     1999
      999 |     2999
      999 |     3999
      999 |     4999
      999 |     5999
      999 |     6999
      999 |     7999
      999 |     8999
      999 |     9999
(25 rows)

SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000) AND thousand < 1000
ORDER BY thousand <-> 10000;
 thousand | tenthous 
----------+----------
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
      998 |     9998
      998 |     8998
      998 |     7998
      998 |     6998
      998 |     5998
      998 |     4998
      998 |     3998
      998 |     2998
      998 |     1998
      998 |      998
      997 |     9997
      997 |     8997
      997 |     7997
      997 |     6997
      997 |     5997
(25 rows)

SELECT thousand, tenthous FROM tenk3
ORDER BY thousand <-> 500
OFFSET 9970;
 thousand | tenthous 
----------+----------
      999 |      999
      999 |     1999
      999 |     2999
      999 |     3999
      999 |     4999
      999 |     5999
      999 |     6999
      999 |     7999
      999 |     8999
      999 |     9999
        1 |     9001
        1 |     8001
        1 |     7001
        1 |     6001
        1 |     5001
        1 |     4001
        1 |     3001
        1 |     2001
        1 |     1001
        1 |        1
        0 |     9000
        0 |     8000
        0 |     7000
        0 |     6000
        0 |     5000
        0 |     4000
        0 |     3000
        0 |     2000
        0 |     1000
        0 |        0
          |        1
          |        2
          |        3
(33 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM tenk3
WHERE thousand > 100 AND thousand < 800 AND
	thousand = ANY(ARRAY[0, 123, 234, 345, 456, 678, 901, NULL]::int2[])
ORDER BY thousand <-> 300::int8;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tenk3_idx on tenk3
   Index Cond: ((thousand > 100) AND (thousand < 800) AND (thousand = ANY ('{0,123,234,345,456,678,901,NULL}'::smallint[])))
   Order By: (thousand <-> '300'::bigint)
(3 rows)

SELECT * FROM tenk3
WHERE thousand > 100 AND thousand < 800 AND
	thousand = ANY(ARRAY[0, 123, 234, 345, 456, 678, 901, NULL]::int2[])
ORDER BY thousand <-> 300::int8;
 thousand | tenthous 
----------+----------
      345 |      345
      345 |     1345
      345 |     2345
      345 |     3345
      345 |     4345
      345 |     5345
      345 |     6345
      345 |     7345
      345 |     8345
      345 |     9345
      234 |      234
      234 |     1234
      234 |     2234
      234 |     3234
      234 |     4234
      234 |     5234
      234 |     6234
      234 |     7234
      234 |     8234
      234 |     9234
      456 |      456
      456 |     1456
      456 |     2456
      456 |     3456
      456 |     4456
      456 |     5456
      456 |     6456
      456 |     7456
      456 |     8456
      456 |     9456
      123 |      123
      123 |     1123
      123 |     2123
      123 |     3123
      123 |     4123
      123 |     5123
      123 |     6123
      123 |     7123
      123 |     8123
      123 |     9123
      678 |      678
      678 |     1678
      678 |     2678
      678 |     3678
      678 |     4678
      678 |     5678
      678 |     6678
      678 |     7678
      678 |     8678
      678 |     9678
(50 rows)

DROP INDEX tenk3_idx;
-- Test distance ordering by DESC index
CREATE INDEX tenk3_idx ON tenk3 USING btree(thousand DESC, tenthous);
SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000)
ORDER BY thousand <-> 998;
 thousand | tenthous 
----------+----------
      998 |      998
      998 |     1998
      998 |     2998
      998 |     3998
      998 |     4998
      998 |     5998
      998 |     6998
      998 |     7998
      998 |     8998
      998 |     9998
      997 |     5997
      997 |     6997
      997 |     7997
      997 |     8997
      997 |     9997
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
(25 rows)

SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000)
ORDER BY thousand <-> 0;
 thousand | tenthous 
----------+----------
      997 |     9997
      997 |     8997
      997 |     7997
      997 |     6997
      997 |     5997
      998 |     9998
      998 |     8998
      998 |     7998
      998 |     6998
      998 |     5998
      998 |     4998
      998 |     3998
      998 |     2998
      998 |     1998
      998 |      998
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
(25 rows)

SELECT thousand, tenthous FROM tenk3
WHERE (thousand, tenthous) >= (997, 5000) AND thousand < 1000
ORDER BY thousand <-> 10000;
 thousand | tenthous 
----------+----------
      999 |      999
      999 |     1999
      999 |     2999
      999 |     3999
      999 |     4999
      999 |     5999
      999 |     6999
      999 |     7999
      999 |     8999
      999 |     9999
      998 |      998
      998 |     1998
      998 |     2998
      998 |     3998
      998 |     4998
      998 |     5998
      998 |     6998
      998 |     7998
      998 |     8998
      998 |     9998
      997 |     5997
      997 |     6997
      997 |     7997
      997 |     8997
      997 |     9997
(25 rows)

SELECT thousand, tenthous FROM tenk3
ORDER BY thousand <-> 500
OFFSET 9970;
 thousand | tenthous 
----------+----------
        1 |        1
        1 |     1001
        1 |     2001
        1 |     3001
        1 |     4001
        1 |     5001
        1 |     6001
        1 |     7001
        1 |     8001
        1 |     9001
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
        0 |        0
        0 |     1000
        0 |     2000
        0 |     3000
        0 |     4000
        0 |     5000
        0 |     6000
        0 |     7000
        0 |     8000
        0 |     9000
          |        3
          |        2
          |        1
(33 rows)

DROP INDEX tenk3_idx;
DROP TABLE tenk3;
-- Test distance ordering on by-ref types
CREATE TABLE knn_btree_ts (ts timestamp);
INSERT INTO knn_btree_ts
SELECT timestamp '2017-05-03 00:00:00' + tenthous * interval '1 hour'
FROM tenk1;
CREATE INDEX knn_btree_ts_idx ON knn_btree_ts USING btree(ts);
SELECT ts, ts <-> timestamp '2017-05-01 00:00:00' FROM knn_btree_ts ORDER BY 2 LIMIT 20;
            ts            |     ?column?      
--------------------------+-------------------
 Wed May 03 00:00:00 2017 | @ 2 days
 Wed May 03 01:00:00 2017 | @ 2 days 1 hour
 Wed May 03 02:00:00 2017 | @ 2 days 2 hours
 Wed May 03 03:00:00 2017 | @ 2 days 3 hours
 Wed May 03 04:00:00 2017 | @ 2 days 4 hours
 Wed May 03 05:00:00 2017 | @ 2 days 5 hours
 Wed May 03 06:00:00 2017 | @ 2 days 6 hours
 Wed May 03 07:00:00 2017 | @ 2 days 7 hours
 Wed May 03 08:00:00 2017 | @ 2 days 8 hours
 Wed May 03 09:00:00 2017 | @ 2 days 9 hours
 Wed May 03 10:00:00 2017 | @ 2 days 10 hours
 Wed May 03 11:00:00 2017 | @ 2 days 11 hours
 Wed May 03 12:00:00 2017 | @ 2 days 12 hours
 Wed May 03 13:00:00 2017 | @ 2 days 13 hours
 Wed May 03 14:00:00 2017 | @ 2 days 14 hours
 Wed May 03 15:00:00 2017 | @ 2 days 15 hours
 Wed May 03 16:00:00 2017 | @ 2 days 16 hours
 Wed May 03 17:00:00 2017 | @ 2 days 17 hours
 Wed May 03 18:00:00 2017 | @ 2 days 18 hours
 Wed May 03 19:00:00 2017 | @ 2 days 19 hours
(20 rows)

SELECT ts, ts <-> timestamp '2018-01-01 00:00:00' FROM knn_btree_ts ORDER BY 2 LIMIT 20;
            ts            |  ?column?  
--------------------------+------------
 Mon Jan 01 00:00:00 2018 | @ 0
 Mon Jan 01 01:00:00 2018 | @ 1 hour
 Sun Dec 31 23:00:00 2017 | @ 1 hour
 Mon Jan 01 02:00:00 2018 | @ 2 hours
 Sun Dec 31 22:00:00 2017 | @ 2 hours
 Mon Jan 01 03:00:00 2018 | @ 3 hours
 Sun Dec 31 21:00:00 2017 | @ 3 hours
 Mon Jan 01 04:00:00 2018 | @ 4 hours
 Sun Dec 31 20:00:00 2017 | @ 4 hours
 Mon Jan 01 05:00:00 2018 | @ 5 hours
 Sun Dec 31 19:00:00 2017 | @ 5 hours
 Mon Jan 01 06:00:00 2018 | @ 6 hours
 Sun Dec 31 18:00:00 2017 | @ 6 hours
 Mon Jan 01 07:00:00 2018 | @ 7 hours
 Sun Dec 31 17:00:00 2017 | @ 7 hours
 Mon Jan 01 08:00:00 2018 | @ 8 hours
 Sun Dec 31 16:00:00 2017 | @ 8 hours
 Mon Jan 01 09:00:00 2018 | @ 9 hours
 Sun Dec 31 15:00:00 2017 | @ 9 hours
 Mon Jan 01 10:00:00 2018 | @ 10 hours
(20 rows)

DROP TABLE knn_btree_ts;
RESET enable_bitmapscan;
-- Test backward kNN scan
SET enable_sort = OFF;
EXPLAIN (COSTS OFF) SELECT thousand, tenthous FROM tenk1 ORDER BY thousand  <-> 510;
                     QUERY PLAN                      
-----------------------------------------------------
 Index Only Scan using tenk1_thous_tenthous on tenk1
   Order By: (thousand <-> 510)
(2 rows)

BEGIN work;
DECLARE knn SCROLL CURSOR FOR
SELECT thousand, tenthous FROM tenk1 ORDER BY thousand <-> 510;
FETCH LAST FROM knn;
 thousand | tenthous 
----------+----------
        0 |        0
(1 row)

FETCH BACKWARD 15 FROM knn;
 thousand | tenthous 
----------+----------
        0 |     1000
        0 |     2000
        0 |     3000
        0 |     4000
        0 |     5000
        0 |     6000
        0 |     7000
        0 |     8000
        0 |     9000
        1 |        1
        1 |     1001
        1 |     2001
        1 |     3001
        1 |     4001
        1 |     5001
(15 rows)

FETCH RELATIVE -200 FROM knn;
 thousand | tenthous 
----------+----------
       21 |     5021
(1 row)

FETCH BACKWARD 20 FROM knn;
 thousand | tenthous 
----------+----------
       21 |     6021
       21 |     7021
       21 |     8021
       21 |     9021
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
       22 |       22
       22 |     1022
       22 |     2022
       22 |     3022
       22 |     4022
       22 |     5022
(20 rows)

FETCH FIRST FROM knn;
 thousand | tenthous 
----------+----------
      510 |      510
(1 row)

FETCH LAST FROM knn;
 thousand | tenthous 
----------+----------
        0 |        0
(1 row)

FETCH RELATIVE -215 FROM knn;
 thousand | tenthous 
----------+----------
       21 |     5021
(1 row)

FETCH BACKWARD 20 FROM knn;
 thousand | tenthous 
----------+----------
       21 |     6021
       21 |     7021
       21 |     8021
       21 |     9021
      999 |     9999
      999 |     8999
      999 |     7999
      999 |     6999
      999 |     5999
      999 |     4999
      999 |     3999
      999 |     2999
      999 |     1999
      999 |      999
       22 |       22
       22 |     1022
       22 |     2022
       22 |     3022
       22 |     4022
       22 |     5022
(20 rows)

ROLLBACK work;
RESET enable_sort;
