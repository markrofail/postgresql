--
-- SUBSELECT
--
SELECT 1 AS one WHERE 1 IN (SELECT 1);
 one 
-----
   1
(1 row)

SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
 zero 
------
(0 rows)

SELECT 1 AS zero WHERE 1 IN (SELECT 2);
 zero 
------
(0 rows)

-- Check grammar's handling of extra parens in assorted contexts
SELECT * FROM (SELECT 1 AS x) ss;
 x 
---
 1
(1 row)

SELECT * FROM ((SELECT 1 AS x)) ss;
 x 
---
 1
(1 row)

(SELECT 2) UNION SELECT 2;
 ?column? 
----------
        2
(1 row)

((SELECT 2)) UNION SELECT 2;
 ?column? 
----------
        2
(1 row)

SELECT ((SELECT 2) UNION SELECT 2);
 ?column? 
----------
        2
(1 row)

SELECT (((SELECT 2)) UNION SELECT 2);
 ?column? 
----------
        2
(1 row)

SELECT (SELECT ARRAY[1,2,3])[1];
 array 
-------
     1
(1 row)

SELECT ((SELECT ARRAY[1,2,3]))[2];
 array 
-------
     2
(1 row)

SELECT (((SELECT ARRAY[1,2,3])))[3];
 array 
-------
     3
(1 row)

-- Set up some simple test tables
CREATE TABLE SUBSELECT_TBL (
  f1 integer,
  f2 integer,
  f3 float
);
INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
SELECT '' AS eight, * FROM SUBSELECT_TBL;
 eight | f1 | f2 | f3 
-------+----+----+----
       |  1 |  2 |  3
       |  2 |  3 |  4
       |  3 |  4 |  5
       |  1 |  1 |  1
       |  2 |  2 |  2
       |  3 |  3 |  3
       |  6 |  7 |  8
       |  8 |  9 |   
(8 rows)

-- Uncorrelated subselects
SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT 1);
 two | Constant Select 
-----+-----------------
     |               1
     |               1
(2 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL);
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  2
     |                  3
     |                  1
     |                  2
     |                  3
(6 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
    f2 IN (SELECT f1 FROM SUBSELECT_TBL));
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  2
     |                  3
     |                  1
     |                  2
     |                  3
(6 rows)

SELECT '' AS three, f1, f2
  FROM SUBSELECT_TBL
  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                         WHERE f3 IS NOT NULL);
 three | f1 | f2 
-------+----+----
       |  1 |  2
       |  6 |  7
       |  8 |  9
(3 rows)

-- Correlated subselects
SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            2
     |                2 |            3
     |                3 |            4
     |                1 |            1
     |                2 |            2
     |                3 |            3
(6 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN
    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3);
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                2 |            4
     |                3 |            5
     |                1 |            1
     |                2 |            2
     |                3 |            3
(5 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
               WHERE f2 = CAST(f3 AS integer));
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            3
     |                2 |            4
     |                3 |            5
     |                6 |            8
(4 rows)

SELECT '' AS five, f1 AS "Correlated Field"
  FROM SUBSELECT_TBL
  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                     WHERE f3 IS NOT NULL);
 five | Correlated Field 
------+------------------
      |                2
      |                3
      |                1
      |                2
      |                3
(5 rows)

--
-- Use some existing tables in the regression test
--
SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
  FROM SUBSELECT_TBL ss
  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
                   WHERE f1 != ss.f1 AND f1 < 2147483647);
 eight | Correlated Field | Second Field 
-------+------------------+--------------
       |                2 |            4
       |                3 |            5
       |                2 |            2
       |                3 |            3
       |                6 |            8
       |                8 |             
(6 rows)

select q1, float8(count(*)) / (select count(*) from int8_tbl)
from int8_tbl group by q1 order by q1;
        q1        | ?column? 
------------------+----------
              123 |      0.4
 4567890123456789 |      0.6
(2 rows)

-- Unspecified-type literals in output columns should resolve as text
SELECT *, pg_typeof(f1) FROM
  (SELECT 'foo' AS f1 FROM generate_series(1,3)) ss ORDER BY 1;
 f1  | pg_typeof 
-----+-----------
 foo | text
 foo | text
 foo | text
(3 rows)

-- ... unless there's context to suggest differently
explain (verbose, costs off) select '42' union all select '43';
         QUERY PLAN         
----------------------------
 Append
   ->  Result
         Output: '42'::text
   ->  Result
         Output: '43'::text
(5 rows)

explain (verbose, costs off) select '42' union all select 43;
     QUERY PLAN     
--------------------
 Append
   ->  Result
         Output: 42
   ->  Result
         Output: 43
(5 rows)

-- check materialization of an initplan reference (bug #14524)
explain (verbose, costs off)
select 1 = all (select (select 1));
            QUERY PLAN             
-----------------------------------
 Result
   Output: (SubPlan 2)
   SubPlan 2
     ->  Materialize
           Output: ($0)
           InitPlan 1 (returns $0)
             ->  Result
                   Output: 1
           ->  Result
                 Output: $0
(10 rows)

select 1 = all (select (select 1));
 ?column? 
----------
 t
(1 row)

--
-- Check EXISTS simplification with LIMIT
--
explain (costs off)
select * from int4_tbl o where exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit null);
             QUERY PLAN             
------------------------------------
 Hash Semi Join
   Hash Cond: (o.f1 = i.f1)
   ->  Seq Scan on int4_tbl o
   ->  Hash
         ->  Seq Scan on int4_tbl i
(5 rows)

explain (costs off)
select * from int4_tbl o where not exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit 1);
             QUERY PLAN             
------------------------------------
 Hash Anti Join
   Hash Cond: (o.f1 = i.f1)
   ->  Seq Scan on int4_tbl o
   ->  Hash
         ->  Seq Scan on int4_tbl i
(5 rows)

explain (costs off)
select * from int4_tbl o where exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit 0);
              QUERY PLAN              
--------------------------------------
 Seq Scan on int4_tbl o
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Limit
           ->  Seq Scan on int4_tbl i
                 Filter: (f1 = o.f1)
(6 rows)

--
-- Test cases to catch unpleasant interactions between IN-join processing
-- and subquery pullup.
--
select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

--
-- Test cases to check for overenthusiastic optimization of
-- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
-- Luca Pireddu and Michael Fuhr.
--
CREATE TEMP TABLE foo (id integer);
CREATE TEMP TABLE bar (id1 integer, id2 integer);
INSERT INTO foo VALUES (1);
INSERT INTO bar VALUES (1, 1);
INSERT INTO bar VALUES (2, 2);
INSERT INTO bar VALUES (3, 1);
-- These cases require an extra level of distinct-ing above subquery s
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
                      SELECT id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

-- These cases do not
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar UNION
                      SELECT id2 FROM bar) AS s);
 id 
----
  1
(1 row)

--
-- Test case to catch problems with multiply nested sub-SELECTs not getting
-- recalculated properly.  Per bug report from Didier Moens.
--
CREATE TABLE orderstest (
    approver_ref integer,
    po_ref integer,
    ordercanceled boolean
);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 5, false);
INSERT INTO orderstest VALUES (66, 6, false);
INSERT INTO orderstest VALUES (66, 7, false);
INSERT INTO orderstest VALUES (66, 1, true);
INSERT INTO orderstest VALUES (66, 8, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (77, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
CREATE VIEW orders_view AS
SELECT *,
(SELECT CASE
   WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
 END) AS "Approved",
(SELECT CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (SELECT CASE
		WHEN ord.po_ref=1
		THEN
		 (SELECT CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status",
(CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (CASE
		WHEN ord.po_ref=1
		THEN
		 (CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status_OK"
FROM orderstest ord;
SELECT * FROM orders_view;
 approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
--------------+--------+---------------+----------+----------+-----------
            1 |      1 | f             | ---      | ---      | ---
           66 |      5 | f             | Approved | PO       | PO
           66 |      6 | f             | Approved | PO       | PO
           66 |      7 | f             | Approved | PO       | PO
           66 |      1 | t             | Approved | Canceled | Canceled
           66 |      8 | f             | Approved | PO       | PO
           66 |      1 | f             | Approved | Approved | Approved
           77 |      1 | f             | Approved | Approved | Approved
            1 |      1 | f             | ---      | ---      | ---
           66 |      1 | f             | Approved | Approved | Approved
            1 |      1 | f             | ---      | ---      | ---
(11 rows)

DROP TABLE orderstest cascade;
NOTICE:  drop cascades to view orders_view
--
-- Test cases to catch situations where rule rewriter fails to propagate
-- hasSubLinks flag correctly.  Per example from Kyle Bateman.
--
create temp table parts (
    partnum     text,
    cost        float8
);
create temp table shipped (
    ttype       char(2),
    ordnum      int4,
    partnum     text,
    value       float8
);
create temp view shipped_view as
    select * from shipped where ttype = 'wt';
create rule shipped_view_insert as on insert to shipped_view do instead
    insert into shipped values('wt', new.ordnum, new.partnum, new.value);
insert into parts (partnum, cost) values (1, 1234.56);
insert into shipped_view (ordnum, partnum, value)
    values (0, 1, (select cost from parts where partnum = '1'));
select * from shipped_view;
 ttype | ordnum | partnum |  value  
-------+--------+---------+---------
 wt    |      0 | 1       | 1234.56
(1 row)

create rule shipped_view_update as on update to shipped_view do instead
    update shipped set partnum = new.partnum, value = new.value
        where ttype = new.ttype and ordnum = new.ordnum;
update shipped_view set value = 11
    from int4_tbl a join int4_tbl b
      on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))
    where ordnum = a.f1;
select * from shipped_view;
 ttype | ordnum | partnum | value 
-------+--------+---------+-------
 wt    |      0 | 1       |    11
(1 row)

select f1, ss1 as relabel from
    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
     from int4_tbl a) ss;
     f1      |  relabel   
-------------+------------
           0 | 2147607103
      123456 | 2147607103
     -123456 | 2147483647
  2147483647 | 2147483647
 -2147483647 |          0
(5 rows)

--
-- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
-- Per bug report from David Sanchez i Gregori.
--
select * from (
  select max(unique1) from tenk1 as a
  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
) ss;
 max  
------
 9997
(1 row)

select * from (
  select min(unique1) from tenk1 as a
  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
) ss;
 min 
-----
   0
(1 row)

--
-- Test that an IN implemented using a UniquePath does unique-ification
-- with the right semantics, as per bug #4113.  (Unfortunately we have
-- no simple way to ensure that this test case actually chooses that type
-- of plan, but it does in releases 7.4-8.3.  Note that an ordering difference
-- here might mean that some other plan type is being used, rendering the test
-- pointless.)
--
create temp table numeric_table (num_col numeric);
insert into numeric_table values (1), (1.000000000000000000001), (2), (3);
create temp table float_table (float_col float8);
insert into float_table values (1), (2), (3);
select * from float_table
  where float_col in (select num_col from numeric_table);
 float_col 
-----------
         1
         2
         3
(3 rows)

select * from numeric_table
  where num_col in (select float_col from float_table);
         num_col         
-------------------------
                       1
 1.000000000000000000001
                       2
                       3
(4 rows)

--
-- Test case for bug #4290: bogus calculation of subplan param sets
--
create temp table ta (id int primary key, val int);
insert into ta values(1,1);
insert into ta values(2,2);
create temp table tb (id int primary key, aval int);
insert into tb values(1,1);
insert into tb values(2,1);
insert into tb values(3,2);
insert into tb values(4,2);
create temp table tc (id int primary key, aid int);
insert into tc values(1,1);
insert into tc values(2,2);
select
  ( select min(tb.id) from tb
    where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
from tc;
 min_tb_id 
-----------
         1
         3
(2 rows)

--
-- Test case for 8.3 "failed to locate grouping columns" bug
--
create temp table t1 (f1 numeric(14,0), f2 varchar(30));
select * from
  (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs
   from t1 up) ss
group by f1,f2,fs;
 f1 | f2 | fs 
----+----+----
(0 rows)

--
-- Test case for bug #5514 (mishandling of whole-row Vars in subselects)
--
create temp table table_a(id integer);
insert into table_a values (42);
create temp view view_a as select * from table_a;
select view_a from view_a;
 view_a 
--------
 (42)
(1 row)

select (select view_a) from view_a;
 view_a 
--------
 (42)
(1 row)

select (select (select view_a)) from view_a;
 view_a 
--------
 (42)
(1 row)

select (select (a.*)::text) from view_a a;
  a   
------
 (42)
(1 row)

--
-- Check that whole-row Vars reading the result of a subselect don't include
-- any junk columns therein
--
select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
(5 rows)

with q as (select max(f1) from int4_tbl group by f1 order by f1)
  select q from q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
(5 rows)

--
-- Test case for sublinks pulled up into joinaliasvars lists in an
-- inherited update/delete query
--
begin;  --  this shouldn't delete anything, but be safe
delete from road
where exists (
  select 1
  from
    int4_tbl cross join
    ( select f1, array(select q1 from int8_tbl) as arr
      from text_tbl ) ss
  where road.name = ss.f1 );
rollback;
--
-- Test case for sublinks pushed down into subselects via join alias expansion
--
select
  (select sq1) as qq1
from
  (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy
   from int8_tbl) sq0
  join
  int4_tbl i4 on dummy = i4.f1;
 qq1 
-----
(0 rows)

--
-- Test case for subselect within UPDATE of INSERT...ON CONFLICT DO UPDATE
--
create temp table upsert(key int4 primary key, val text);
insert into upsert values(1, 'val') on conflict (key) do update set val = 'not seen';
insert into upsert values(1, 'val') on conflict (key) do update set val = 'seen with subselect ' || (select f1 from int4_tbl where f1 != 0 limit 1)::text;
select * from upsert;
 key |            val             
-----+----------------------------
   1 | seen with subselect 123456
(1 row)

with aa as (select 'int4_tbl' u from int4_tbl limit 1)
insert into upsert values (1, 'x'), (999, 'y')
on conflict (key) do update set val = (select u from aa)
returning *;
 key |   val    
-----+----------
   1 | int4_tbl
 999 | y
(2 rows)

--
-- Test case for cross-type partial matching in hashed subplan (bug #7597)
--
create temp table outer_7597 (f1 int4, f2 int4);
insert into outer_7597 values (0, 0);
insert into outer_7597 values (1, 0);
insert into outer_7597 values (0, null);
insert into outer_7597 values (1, null);
create temp table inner_7597(c1 int8, c2 int8);
insert into inner_7597 values(0, null);
select * from outer_7597 where (f1, f2) not in (select * from inner_7597);
 f1 | f2 
----+----
  1 |  0
  1 |   
(2 rows)

--
-- Similar test case using text that verifies that collation
-- information is passed through by execTuplesEqual() in nodeSubplan.c
-- (otherwise it would error in texteq())
--
create temp table outer_text (f1 text, f2 text);
insert into outer_text values ('a', 'a');
insert into outer_text values ('b', 'a');
insert into outer_text values ('a', null);
insert into outer_text values ('b', null);
create temp table inner_text (c1 text, c2 text);
insert into inner_text values ('a', null);
select * from outer_text where (f1, f2) not in (select * from inner_text);
 f1 | f2 
----+----
 b  | a
 b  | 
(2 rows)

--
-- Another test case for cross-type hashed subplans: comparison of
-- inner-side values must be done with appropriate operator
--
explain (verbose, costs off)
select 'foo'::text in (select 'bar'::name union all select 'bar'::name);
             QUERY PLAN              
-------------------------------------
 Result
   Output: (hashed SubPlan 1)
   SubPlan 1
     ->  Append
           ->  Result
                 Output: 'bar'::name
           ->  Result
                 Output: 'bar'::name
(8 rows)

select 'foo'::text in (select 'bar'::name union all select 'bar'::name);
 ?column? 
----------
 f
(1 row)

--
-- Test case for premature memory release during hashing of subplan output
--
select '1'::text in (select '1'::name union all select '1'::name);
 ?column? 
----------
 t
(1 row)

--
-- Test case for planner bug with nested EXISTS handling
--
select a.thousand from tenk1 a, tenk1 b
where a.thousand = b.thousand
  and exists ( select 1 from tenk1 c where b.hundred = c.hundred
                   and not exists ( select 1 from tenk1 d
                                    where a.thousand = d.thousand ) );
 thousand 
----------
(0 rows)

--
-- Check that nested sub-selects are not pulled up if they contain volatiles
--
explain (verbose, costs off)
  select x, x from
    (select (select now()) as x from (values(1),(2)) v(y)) ss;
        QUERY PLAN         
---------------------------
 Values Scan on "*VALUES*"
   Output: $0, $1
   InitPlan 1 (returns $0)
     ->  Result
           Output: now()
   InitPlan 2 (returns $1)
     ->  Result
           Output: now()
(8 rows)

explain (verbose, costs off)
  select x, x from
    (select (select random()) as x from (values(1),(2)) v(y)) ss;
            QUERY PLAN            
----------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.x
   ->  Values Scan on "*VALUES*"
         Output: $0
         InitPlan 1 (returns $0)
           ->  Result
                 Output: random()
(7 rows)

explain (verbose, costs off)
  select x, x from
    (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Values Scan on "*VALUES*"
   Output: (SubPlan 1), (SubPlan 2)
   SubPlan 1
     ->  Result
           Output: now()
           One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
   SubPlan 2
     ->  Result
           Output: now()
           One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
(10 rows)

explain (verbose, costs off)
  select x, x from
    (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.x
   ->  Values Scan on "*VALUES*"
         Output: (SubPlan 1)
         SubPlan 1
           ->  Result
                 Output: random()
                 One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
(8 rows)

--
-- Check we don't misoptimize a NOT IN where the subquery returns no rows.
--
create temp table notinouter (a int);
create temp table notininner (b int not null);
insert into notinouter values (null), (1);
select * from notinouter where a not in (select b from notininner);
 a 
---
  
 1
(2 rows)

--
-- Check we behave sanely in corner case of empty SELECT list (bug #8648)
--
create temp table nocolumns();
select exists(select * from nocolumns);
 exists 
--------
 f
(1 row)

--
-- Check behavior with a SubPlan in VALUES (bug #14924)
--
select val.x
  from generate_series(1,10) as s(i),
  lateral (
    values ((select s.i + 1)), (s.i + 101)
  ) as val(x)
where s.i < 10 and (select val.x) < 110;
  x  
-----
   2
 102
   3
 103
   4
 104
   5
 105
   6
 106
   7
 107
   8
 108
   9
 109
  10
(17 rows)

-- another variant of that (bug #16213)
explain (verbose, costs off)
select * from
(values
  (3 not in (select * from (values (1), (2)) ss1)),
  (false)
) ss;
               QUERY PLAN               
----------------------------------------
 Values Scan on "*VALUES*"
   Output: "*VALUES*".column1
   SubPlan 1
     ->  Values Scan on "*VALUES*_1"
           Output: "*VALUES*_1".column1
(5 rows)

select * from
(values
  (3 not in (select * from (values (1), (2)) ss1)),
  (false)
) ss;
 column1 
---------
 t
 f
(2 rows)

--
-- Check sane behavior with nested IN SubLinks
--
explain (verbose, costs off)
select * from int4_tbl where
  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
  (select ten from tenk1 b);
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Semi Join
   Output: int4_tbl.f1
   Join Filter: (CASE WHEN (hashed SubPlan 1) THEN int4_tbl.f1 ELSE NULL::integer END = b.ten)
   ->  Seq Scan on public.int4_tbl
         Output: int4_tbl.f1
   ->  Seq Scan on public.tenk1 b
         Output: b.unique1, b.unique2, b.two, b.four, b.ten, b.twenty, b.hundred, b.thousand, b.twothousand, b.fivethous, b.tenthous, b.odd, b.even, b.stringu1, b.stringu2, b.string4
   SubPlan 1
     ->  Index Only Scan using tenk1_unique1 on public.tenk1 a
           Output: a.unique1
(10 rows)

select * from int4_tbl where
  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
  (select ten from tenk1 b);
 f1 
----
  0
(1 row)

--
-- Check for incorrect optimization when IN subquery contains a SRF
--
explain (verbose, costs off)
select * from int4_tbl o where (f1, f1) in
  (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Nested Loop Semi Join
   Output: o.f1
   Join Filter: (o.f1 = "ANY_subquery".f1)
   ->  Seq Scan on public.int4_tbl o
         Output: o.f1
   ->  Materialize
         Output: "ANY_subquery".f1, "ANY_subquery".g
         ->  Subquery Scan on "ANY_subquery"
               Output: "ANY_subquery".f1, "ANY_subquery".g
               Filter: ("ANY_subquery".f1 = "ANY_subquery".g)
               ->  Result
                     Output: i.f1, ((generate_series(1, 50)) / 10)
                     ->  ProjectSet
                           Output: generate_series(1, 50), i.f1
                           ->  HashAggregate
                                 Output: i.f1
                                 Group Key: i.f1
                                 ->  Seq Scan on public.int4_tbl i
                                       Output: i.f1
(19 rows)

select * from int4_tbl o where (f1, f1) in
  (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
 f1 
----
  0
(1 row)

--
-- check for over-optimization of whole-row Var referencing an Append plan
--
select (select q from
         (select 1,2,3 where f1 > 0
          union all
          select 4,5,6.0 where f1 <= 0
         ) q )
from int4_tbl;
     q     
-----------
 (4,5,6.0)
 (1,2,3)
 (4,5,6.0)
 (1,2,3)
 (4,5,6.0)
(5 rows)

--
-- Check that volatile quals aren't pushed down past a DISTINCT:
-- nextval() should not be called more than the nominal number of times
--
create temp sequence ts1;
select * from
  (select distinct ten from tenk1) ss
  where ten < 10 + nextval('ts1')
  order by 1;
 ten 
-----
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
(10 rows)

select nextval('ts1');
 nextval 
---------
      11
(1 row)

--
-- Check that volatile quals aren't pushed down past a set-returning function;
-- while a nonvolatile qual can be, if it doesn't reference the SRF.
--
create function tattle(x int, y int) returns bool
volatile language plpgsql as $$
begin
  raise notice 'x = %, y = %', x, y;
  return x > y;
end$$;
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
                        QUERY PLAN                        
----------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.u
   Filter: tattle(ss.x, 8)
   ->  ProjectSet
         Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
         ->  Result
(6 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
 x | u  
---+----
 9 |  1
 9 |  2
 9 |  3
 9 | 11
 9 | 12
 9 | 13
(6 rows)

-- if we pretend it's stable, we get different results:
alter function tattle(x int, y int) stable;
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
                     QUERY PLAN                     
----------------------------------------------------
 ProjectSet
   Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
   ->  Result
         One-Time Filter: tattle(9, 8)
(4 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
NOTICE:  x = 9, y = 8
 x | u  
---+----
 9 |  1
 9 |  2
 9 |  3
 9 | 11
 9 | 12
 9 | 13
(6 rows)

-- although even a stable qual should not be pushed down if it references SRF
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, u);
                        QUERY PLAN                        
----------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.u
   Filter: tattle(ss.x, ss.u)
   ->  ProjectSet
         Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
         ->  Result
(6 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, u);
NOTICE:  x = 9, y = 1
NOTICE:  x = 9, y = 2
NOTICE:  x = 9, y = 3
NOTICE:  x = 9, y = 11
NOTICE:  x = 9, y = 12
NOTICE:  x = 9, y = 13
 x | u 
---+---
 9 | 1
 9 | 2
 9 | 3
(3 rows)

drop function tattle(x int, y int);
--
-- Test that LIMIT can be pushed to SORT through a subquery that just projects
-- columns.  We check for that having happened by looking to see if EXPLAIN
-- ANALYZE shows that a top-N sort was used.  We must suppress or filter away
-- all the non-invariant parts of the EXPLAIN ANALYZE output.
--
create table sq_limit (pk int primary key, c1 int, c2 int);
insert into sq_limit values
    (1, 1, 1),
    (2, 2, 2),
    (3, 3, 3),
    (4, 4, 4),
    (5, 1, 1),
    (6, 2, 2),
    (7, 3, 3),
    (8, 4, 4);
create function explain_sq_limit() returns setof text language plpgsql as
$$
declare ln text;
begin
    for ln in
        explain (analyze, summary off, timing off, costs off)
        select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3
    loop
        ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
        return next ln;
    end loop;
end;
$$;
select * from explain_sq_limit();
                        explain_sq_limit                        
----------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Subquery Scan on x (actual rows=3 loops=1)
         ->  Sort (actual rows=3 loops=1)
               Sort Key: sq_limit.c1, sq_limit.pk
               Sort Method: top-N heapsort  Memory: xxx
               ->  Seq Scan on sq_limit (actual rows=8 loops=1)
(6 rows)

select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3;
 pk | c2 
----+----
  1 |  1
  5 |  1
  2 |  2
(3 rows)

drop function explain_sq_limit();
drop table sq_limit;
--
-- Ensure that backward scan direction isn't propagated into
-- expression subqueries (bug #15336)
--
begin;
declare c1 scroll cursor for
 select * from generate_series(1,4) i
  where i <> all (values (2),(3));
move forward all in c1;
fetch backward all in c1;
 i 
---
 4
 1
(2 rows)

commit;
--
-- Tests for CTE inlining behavior
--
-- Basic subquery that can be inlined
explain (verbose, costs off)
with x as (select * from (select f1 from subselect_tbl) ss)
select * from x where f1 = 1;
            QUERY PLAN            
----------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1
   Filter: (subselect_tbl.f1 = 1)
(3 rows)

-- Explicitly request materialization
explain (verbose, costs off)
with x as materialized (select * from (select f1 from subselect_tbl) ss)
select * from x where f1 = 1;
                QUERY PLAN                
------------------------------------------
 CTE Scan on x
   Output: x.f1
   Filter: (x.f1 = 1)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1
(6 rows)

-- Stable functions are safe to inline
explain (verbose, costs off)
with x as (select * from (select f1, now() from subselect_tbl) ss)
select * from x where f1 = 1;
            QUERY PLAN             
-----------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1, now()
   Filter: (subselect_tbl.f1 = 1)
(3 rows)

-- Volatile functions prevent inlining
explain (verbose, costs off)
with x as (select * from (select f1, random() from subselect_tbl) ss)
select * from x where f1 = 1;
                  QUERY PLAN                  
----------------------------------------------
 CTE Scan on x
   Output: x.f1, x.random
   Filter: (x.f1 = 1)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1, random()
(6 rows)

-- SELECT FOR UPDATE cannot be inlined
explain (verbose, costs off)
with x as (select * from (select f1 from subselect_tbl for update) ss)
select * from x where f1 = 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 CTE Scan on x
   Output: x.f1
   Filter: (x.f1 = 1)
   CTE x
     ->  Subquery Scan on ss
           Output: ss.f1
           ->  LockRows
                 Output: subselect_tbl.f1, subselect_tbl.ctid
                 ->  Seq Scan on public.subselect_tbl
                       Output: subselect_tbl.f1, subselect_tbl.ctid
(10 rows)

-- Multiply-referenced CTEs are inlined only when requested
explain (verbose, costs off)
with x as (select * from (select f1, now() as n from subselect_tbl) ss)
select * from x, x x2 where x.n = x2.n;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Output: x.f1, x.n, x2.f1, x2.n
   Merge Cond: (x.n = x2.n)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1, now()
   ->  Sort
         Output: x.f1, x.n
         Sort Key: x.n
         ->  CTE Scan on x
               Output: x.f1, x.n
   ->  Sort
         Output: x2.f1, x2.n
         Sort Key: x2.n
         ->  CTE Scan on x x2
               Output: x2.f1, x2.n
(16 rows)

explain (verbose, costs off)
with x as not materialized (select * from (select f1, now() as n from subselect_tbl) ss)
select * from x, x x2 where x.n = x2.n;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Result
   Output: subselect_tbl.f1, now(), subselect_tbl_1.f1, now()
   One-Time Filter: (now() = now())
   ->  Nested Loop
         Output: subselect_tbl.f1, subselect_tbl_1.f1
         ->  Seq Scan on public.subselect_tbl
               Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
         ->  Materialize
               Output: subselect_tbl_1.f1
               ->  Seq Scan on public.subselect_tbl subselect_tbl_1
                     Output: subselect_tbl_1.f1
(11 rows)

-- Multiply-referenced CTEs can't be inlined if they contain outer self-refs
explain (verbose, costs off)
with recursive x(a) as
  ((values ('a'), ('b'))
   union all
   (with z as not materialized (select * from x)
    select z.a || z1.a as a from z cross join z as z1
    where length(z.a || z1.a) < 5))
select * from x;
                        QUERY PLAN                        
----------------------------------------------------------
 CTE Scan on x
   Output: x.a
   CTE x
     ->  Recursive Union
           ->  Values Scan on "*VALUES*"
                 Output: "*VALUES*".column1
           ->  Nested Loop
                 Output: (z.a || z1.a)
                 Join Filter: (length((z.a || z1.a)) < 5)
                 CTE z
                   ->  WorkTable Scan on x x_1
                         Output: x_1.a
                 ->  CTE Scan on z
                       Output: z.a
                 ->  CTE Scan on z z1
                       Output: z1.a
(16 rows)

with recursive x(a) as
  ((values ('a'), ('b'))
   union all
   (with z as not materialized (select * from x)
    select z.a || z1.a as a from z cross join z as z1
    where length(z.a || z1.a) < 5))
select * from x;
  a   
------
 a
 b
 aa
 ab
 ba
 bb
 aaaa
 aaab
 aaba
 aabb
 abaa
 abab
 abba
 abbb
 baaa
 baab
 baba
 babb
 bbaa
 bbab
 bbba
 bbbb
(22 rows)

explain (verbose, costs off)
with recursive x(a) as
  ((values ('a'), ('b'))
   union all
   (with z as not materialized (select * from x)
    select z.a || z.a as a from z
    where length(z.a || z.a) < 5))
select * from x;
                       QUERY PLAN                       
--------------------------------------------------------
 CTE Scan on x
   Output: x.a
   CTE x
     ->  Recursive Union
           ->  Values Scan on "*VALUES*"
                 Output: "*VALUES*".column1
           ->  WorkTable Scan on x x_1
                 Output: (x_1.a || x_1.a)
                 Filter: (length((x_1.a || x_1.a)) < 5)
(9 rows)

with recursive x(a) as
  ((values ('a'), ('b'))
   union all
   (with z as not materialized (select * from x)
    select z.a || z.a as a from z
    where length(z.a || z.a) < 5))
select * from x;
  a   
------
 a
 b
 aa
 bb
 aaaa
 bbbb
(6 rows)

-- Check handling of outer references
explain (verbose, costs off)
with x as (select * from int4_tbl)
select * from (with y as (select * from x) select * from y) ss;
         QUERY PLAN          
-----------------------------
 Seq Scan on public.int4_tbl
   Output: int4_tbl.f1
(2 rows)

explain (verbose, costs off)
with x as materialized (select * from int4_tbl)
select * from (with y as (select * from x) select * from y) ss;
             QUERY PLAN              
-------------------------------------
 CTE Scan on x
   Output: x.f1
   CTE x
     ->  Seq Scan on public.int4_tbl
           Output: int4_tbl.f1
(5 rows)

-- Ensure that we inline the currect CTE when there are
-- multiple CTEs with the same name
explain (verbose, costs off)
with x as (select 1 as y)
select * from (with x as (select 2 as y) select * from x) ss;
 QUERY PLAN  
-------------
 Result
   Output: 2
(2 rows)

-- Row marks are not pushed into CTEs
explain (verbose, costs off)
with x as (select * from subselect_tbl)
select * from x for update;
                           QUERY PLAN                           
----------------------------------------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
(2 rows)

-- test NON IN to ANTI JOIN conversion
CREATE TABLE s (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into s (u, n, nn, p)
    select
    generate_series(1,3) as u,
	generate_series(1,3) as n,
	generate_series(1,3) as nn,
	'foo' as p;
insert into s values(1000002, 1000002, 1000002, 'foofoo');
UPDATE s set n = NULL WHERE n = 3;
analyze s;
CREATE TABLE l (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into l (u, n, nn, p)
	select
    generate_series(1,10000 ) as u,
	generate_series(1,10000 ) as n,
	generate_series(1,10000 ) as nn,
	'bar' as p;
UPDATE l set n = NULL WHERE n = 7;
CREATE UNIQUE INDEX l_u ON l (u);
CREATE INDEX l_n ON l (n);
CREATE INDEX l_nn ON l (nn);
analyze l;
CREATE TABLE s1 (u INTEGER NOT NULL, n INTEGER NULL, n1 INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into s1 (u, n, n1, nn, p)
    select
    generate_series(1,3) as u,
	generate_series(1,3) as n,
	generate_series(1,3) as n1,
	generate_series(1,3) as nn,
	'foo' as p;
insert into s1 values(1000003, 1000003, 1000003, 1000003, 'foofoo');
insert into s1 values(1003, 1003, 1003, 1003, 'foofoo');
UPDATE s1 set n = NULL WHERE n = 3;
UPDATE s1 set n1 = NULL WHERE n = 2;
UPDATE s1 set n1 = NULL WHERE n1 = 3;
analyze s1;
CREATE TABLE empty (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
analyze empty;
-- set work_mem to 64KB so that NOT IN to ANTI JOIN optimization will kick in
set work_mem = 64;
-- correctness test 1: inner empty, return every thing from outer including NULL
explain (costs false) select * from s where n not in (select n from empty);
             QUERY PLAN             
------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Seq Scan on empty
(4 rows)

select * from s where n not in (select n from empty);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

-- correctness test 2: inner has NULL, return empty result
explain (costs false) select * from s where n not in (select n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- correctness test 3: inner non-null, result has no NULL
explain (costs false) select * from s where n not in (select u from l);
                  QUERY PLAN                   
-----------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Index Only Scan using l_u on l
         Index Cond: (u = s.n)
(7 rows)

select * from s where n not in (select u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

-- correctness test 4: inner has predicate
explain (costs false) select * from s where n not in (select n from l where u > 7);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 7)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 7)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 7);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
(3 rows)

-- correctness test 5: multi-expression, (2, 2, null, 2, foo) should be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u >= 3);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s1.n = l.u) AND (s1.n1 = l.nn)) IS NOT FALSE)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Seq Scan on l
               Filter: (u >= 3)
(6 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u >= 3);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
       1 |       1 |       1 |       1 | foo
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
       2 |       2 |         |       2 | foo
(3 rows)

-- correctness test 6: multi-expression, (3, null, null, 3, foo) should not be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u > 0);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s1.n = l.u) AND (s1.n1 = l.nn)) IS NOT FALSE)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Seq Scan on l
               Filter: (u > 0)
(6 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u > 0);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
(1 row)

-- correctness test 6: multi-expression, (3, null, null, 3, foo) should be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u < 0);
             QUERY PLAN             
------------------------------------
 Seq Scan on s1
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Index Scan using l_u on l
           Index Cond: (u < 0)
(5 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u < 0);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
       1 |       1 |       1 |       1 | foo
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
    1003 |    1003 |    1003 |    1003 | foofoo
       2 |       2 |         |       2 | foo
       3 |         |         |       3 | foo
(5 rows)

-- test using hashed subplan when inner fits in work_mem
explain (costs false) select * from l where n not in (select n from s);
             QUERY PLAN             
------------------------------------
 Seq Scan on l
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Seq Scan on s
(4 rows)

select * from l where n not in (select n from s);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- test single expression
explain (costs false) select * from s where n not in (select n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select u from l);
              QUERY PLAN              
--------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_u on l
         Index Cond: (u = s.u)
(4 rows)

select * from s where u not in (select u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where 3*n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: (((3 * n) IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: (((3 * s.n) = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = (3 * s.n))
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where 3*n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select 3*n from l);
                        QUERY PLAN                         
-----------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = (3 * l.n)) OR ((3 * l.n) IS NULL))
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Materialize
         ->  Seq Scan on l
(8 rows)

select * from s where n not in (select 3*n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- test single expression with predicates
explain (costs false) select * from s where n not in (select n from l where u > 0);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 0)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 0);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l where u > 100);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 100)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 100)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 100);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
(3 rows)

-- test multi expression
explain (costs false) select * from s where (n,u) not in (select n,u from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_u on l
         Index Cond: (u = s.u)
         Filter: ((s.n = n) OR (n IS NULL) OR (s.n IS NULL))
(5 rows)

select * from s where (n,u) not in (select n,u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (u, nn) not in (select u, nn from l);
            QUERY PLAN            
----------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: (s.u = u)
(5 rows)

select * from s where (u, nn) not in (select u, nn from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u) not in (select u,n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.u = n) OR (n IS NULL))
         Filter: ((s.n = u) OR (s.n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.u)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where (n,u) not in (select u,n from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: (((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1000);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 1000) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1000);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 0);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 0) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 0);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 1) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
 1000002 | 1000002 | 1000002 | foofoo
(2 rows)

-- test multi-table
explain (costs false) select count(*) from s, l where s.n not in (select n from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
                     Filter: ((n IS NOT NULL) OR (NOT $0))
               ->  Bitmap Heap Scan on l l_1
                     Recheck Cond: ((s.n = n) OR (n IS NULL))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on l_n
                                 Index Cond: (n = s.n)
                           ->  Bitmap Index Scan on l_n
                                 Index Cond: (n IS NULL)
         ->  Seq Scan on l
(15 rows)

select count(*) from s, l where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s, l where s.nn not in (select nn from l);
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
               ->  Index Only Scan using l_nn on l l_1
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on l
(7 rows)

select count(*) from s, l where s.nn not in (select nn from l);
 count 
-------
 10000
(1 row)

-- test null padded results from outer join
explain (costs false) select * from s where n not in (select s.nn from l left join s on l.nn = s.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = s_1.nn) OR (s_1.nn IS NULL))
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (l_1.nn = s_2.nn)
           ->  Seq Scan on l l_1
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Hash Left Join
         Hash Cond: (l.nn = s_1.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s s_1
(15 rows)

select * from s where n not in (select s.nn from l left join s on l.nn = s.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select s.nn from s right join l on s.nn = l.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = s_1.nn) OR (s_1.nn IS NULL))
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (s_2.nn = l_1.nn)
           ->  Seq Scan on l l_1
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Hash Left Join
         Hash Cond: (l.nn = s_1.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s s_1
(15 rows)

select * from s where n not in (select s.nn from s right join l on s.nn = l.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where l.nn not in (select nn from s);
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         ->  Seq Scan on l
               Filter: (NOT (hashed SubPlan 1))
               SubPlan 1
                 ->  Seq Scan on s s_1
         ->  Hash
               ->  Seq Scan on s
(9 rows)

select count(*) from s right join l on s.nn = l.nn where l.nn not in (select nn from s);
 count 
-------
  9997
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from s);
                QUERY PLAN                
------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
         SubPlan 1
           ->  Seq Scan on s s_1
(9 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from s);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn=l.nn where l.nn not in (select l.nn from l left join s on l.nn = s.nn);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: (s.nn = l.nn)
         ->  Hash Anti Join
               Hash Cond: (l.nn = l_1.nn)
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Left Join
                           Hash Cond: (l_1.nn = s_1.nn)
                           ->  Seq Scan on l l_1
                           ->  Hash
                                 ->  Seq Scan on s s_1
         ->  Seq Scan on s
(13 rows)

select count(*) from s right join l on s.nn=l.nn where l.nn not in (select l.nn from l left join s on l.nn = s.nn);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn=l.nn where s.nn not in (select s.nn from l left join s on l.nn = s.nn);
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (l_2.nn = s_2.nn)
           ->  Seq Scan on l l_2
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Nested Loop Anti Join
         Join Filter: ((s.nn = s_1.nn) OR (s_1.nn IS NULL))
         ->  Hash Left Join
               Hash Cond: (l.nn = s.nn)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Materialize
               ->  Hash Left Join
                     Hash Cond: (l_1.nn = s_1.nn)
                     ->  Seq Scan on l l_1
                     ->  Hash
                           ->  Seq Scan on s s_1
(21 rows)

select count(*) from s right join l on s.nn=l.nn where s.nn not in (select s.nn from l left join s on l.nn = s.nn);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s left join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select count(*) from s left join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u left join l on s.u=l.u where s.nn not in (select nn from l);
                    QUERY PLAN                     
---------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: (s.u = s1.u)
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on s1
(8 rows)

select count(*) from s left join s1 on s.u=s1.u left join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from s right join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s right join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select * from s join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
 u | n | nn | p | u | n | n1 | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s full join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s full join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join s1 on s.u=s1.u full join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Full Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select count(*) from s join s1 on s.u=s1.u full join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn left join s1 on l.nn=s1.nn);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Nested Loop Left Join
         Join Filter: (l.nn = s1.nn)
         ->  Nested Loop Left Join
               Join Filter: (l.nn = s_1.nn)
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
               ->  Seq Scan on s s_1
         ->  Seq Scan on s1
(10 rows)

select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn left join s1 on l.nn=s1.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn right join s1 on l.nn=s1.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.nn = s_1.nn)
           ->  Nested Loop Left Join
                 ->  Seq Scan on s1
                 ->  Index Only Scan using l_nn on l
                       Index Cond: (nn = s1.nn)
           ->  Materialize
                 ->  Seq Scan on s s_1
(11 rows)

select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn right join s1 on l.nn=s1.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Nested Loop Left Join
         Join Filter: (l.nn = s_1.nn)
         ->  Index Scan using l_nn on l
               Index Cond: (nn = s.nn)
               Filter: (((s.n = n) OR (n IS NULL) OR (s.n IS NULL)) AND (s.u = u))
         ->  Seq Scan on s s_1
(8 rows)

select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l right join s on l.nn = s.nn);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(7 rows)

select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

--test reduce outer joins from outer query
explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.nn = s.nn)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(13 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l) and s.u>0;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
                     Filter: (u > 0)
               ->  Index Only Scan using l_nn on l l_1
                     Index Cond: (nn = s.nn)
         ->  Index Only Scan using l_nn on l
               Index Cond: (nn = s.nn)
(9 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l) and s.u>0;
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Nested Loop
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on s1
(11 rows)

select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn right join s1 on s.u = s1.u where s.nn not in (select nn from l);
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on s1
               ->  Materialize
                     ->  Nested Loop
                           ->  Seq Scan on s
                           ->  Index Only Scan using l_nn on l
                                 Index Cond: (nn = s.nn)
         ->  Index Only Scan using l_nn on l l_1
               Index Cond: (nn = s.nn)
(15 rows)

select count(*) from s right join l on s.nn = l.nn right join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select nn from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Left Join
         Join Filter: (s.u = s1.u)
         ->  Hash Anti Join
               Hash Cond: (s.nn = l_1.nn)
               ->  Hash Left Join
                     Hash Cond: (l.nn = s.nn)
                     Filter: ((s.nn IS NOT NULL) OR (NOT $0))
                     ->  Seq Scan on l
                     ->  Hash
                           ->  Seq Scan on s
               ->  Hash
                     ->  Seq Scan on l l_1
         ->  Seq Scan on s1
(16 rows)

select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

--test reduce outer joins from subquery
explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn);
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(7 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where l.u > 9);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
                 Filter: (u > 9)
(8 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where l.u > 9);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where s.u > 9);
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
                 Filter: (u > 9)
           ->  Index Only Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(8 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where s.u > 9);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l
                             Index Cond: (nn = s_1.nn)
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn right join s1 on l.n = s1.n);
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l
                             Index Cond: (nn = s_1.nn)
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn right join s1 on l.n = s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
                   QUERY PLAN                    
-------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Nested Loop Left Join
                 ->  Seq Scan on s s_1
                 ->  Index Scan using l_nn on l
                       Index Cond: (nn = s_1.nn)
           ->  Materialize
                 ->  Seq Scan on s1
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

--test reduce outer join on outer and sub-query
explain (costs false) select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Seq Scan on s1
         ->  Materialize
               ->  Nested Loop
                     ->  Seq Scan on s
                           Filter: (NOT (hashed SubPlan 1))
                           SubPlan 1
                             ->  Nested Loop
                                   Join Filter: (l_1.n = s1_1.n)
                                   ->  Seq Scan on s1 s1_1
                                   ->  Materialize
                                         ->  Nested Loop
                                               ->  Seq Scan on s s_1
                                               ->  Index Scan using l_nn on l l_1
                                                     Index Cond: (nn = s_1.nn)
                     ->  Index Only Scan using l_nn on l
                           Index Cond: (nn = s.nn)
(19 rows)

select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Hash Right Join
                     Hash Cond: (s1.u = s.u)
                     ->  Seq Scan on s1
                     ->  Hash
                           ->  Seq Scan on s
         SubPlan 1
           ->  Nested Loop Left Join
                 Join Filter: (l_1.n = s1_1.n)
                 ->  Nested Loop Left Join
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l l_1
                             Index Cond: (nn = s_1.nn)
                 ->  Materialize
                       ->  Seq Scan on s1 s1_1
(20 rows)

select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
 count 
-------
     0
(1 row)

-- test union all
explain (costs false) select * from s as t where not exists
(select 1 from (select n as y from l union all
				select u as y from s union all
				select nn as y from s) as v where t.n=v.y or v.y is null) and n is not null;
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s t
         Filter: (n IS NOT NULL)
   ->  Append
         ->  Bitmap Heap Scan on l
               Recheck Cond: ((t.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = t.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
         ->  Seq Scan on s
               Filter: ((t.n = u) OR (u IS NULL))
         ->  Seq Scan on s s_1
               Filter: ((t.n = nn) OR (nn IS NULL))
(15 rows)

select * from s as t where not exists
(select 1 from (select n as y from l union all
				select u as y from s union all
				select nn as y from s) as v where t.n=v.y or v.y is null) and n is not null;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Result
           ->  Append
                 ->  Seq Scan on l l_1
                 ->  Seq Scan on s s_3
                 ->  Seq Scan on s s_4
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Append
         ->  Bitmap Heap Scan on l
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
         ->  Seq Scan on s s_1
               Filter: ((s.n = u) OR (u IS NULL))
         ->  Seq Scan on s s_2
               Filter: ((s.n = nn) OR (nn IS NULL))
(21 rows)

select * from s where n not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select nn from l);
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.n = l_1.nn)
         ->  Append
               ->  Seq Scan on s
                     Filter: ((n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
                     Filter: ((u IS NOT NULL) OR (NOT $0))
         ->  Hash
               ->  Seq Scan on l l_1
(12 rows)

select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select nn from l);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from
(select n as x from s union all select n as x from l) t where t.x not in
(select nn from empty);
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Append
         ->  Seq Scan on s
               Filter: (NOT (hashed SubPlan 1))
               SubPlan 1
                 ->  Seq Scan on empty
         ->  Seq Scan on l
               Filter: (NOT (hashed SubPlan 1))
(8 rows)

select count(*) from
(select n as x from s union all select n as x from l) t where t.x not in
(select nn from empty);
 count 
-------
 10004
(1 row)

explain (costs false) select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Finalize Aggregate
   InitPlan 1 (returns $0)
     ->  Result
           ->  Append
                 ->  Seq Scan on l l_2
                 ->  Seq Scan on s s_3
                 ->  Seq Scan on s s_4
   ->  Gather
         Workers Planned: 2
         Params Evaluated: $0
         ->  Partial Aggregate
               ->  Nested Loop Anti Join
                     ->  Parallel Append
                           ->  Parallel Seq Scan on l
                                 Filter: ((u IS NOT NULL) OR (NOT $0))
                           ->  Parallel Seq Scan on s
                                 Filter: ((n IS NOT NULL) OR (NOT $0))
                     ->  Append
                           ->  Bitmap Heap Scan on l l_1
                                 Recheck Cond: ((l.u = n) OR (n IS NULL))
                                 ->  BitmapOr
                                       ->  Bitmap Index Scan on l_n
                                             Index Cond: (n = l.u)
                                       ->  Bitmap Index Scan on l_n
                                             Index Cond: (n IS NULL)
                           ->  Seq Scan on s s_1
                                 Filter: ((l.u = u) OR (u IS NULL))
                           ->  Seq Scan on s s_2
                                 Filter: ((l.u = nn) OR (nn IS NULL))
(29 rows)

select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
 count 
-------
     0
(1 row)

-- test multi-levels of NOT IN
explain (costs false) select * from s where n not in (select n from s where n not in (select n from l));
                         QUERY PLAN                         
------------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 2))
   SubPlan 2
     ->  Nested Loop Anti Join
           InitPlan 1 (returns $0)
             ->  Seq Scan on l
           ->  Seq Scan on s s_1
                 Filter: ((n IS NOT NULL) OR (NOT $0))
           ->  Bitmap Heap Scan on l l_1
                 Recheck Cond: ((s_1.n = n) OR (n IS NULL))
                 ->  BitmapOr
                       ->  Bitmap Index Scan on l_n
                             Index Cond: (n = s_1.n)
                       ->  Bitmap Index Scan on l_n
                             Index Cond: (n IS NULL)
(15 rows)

select * from s where n not in (select n from s where n not in (select n from l));
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where n not in (select n from s where n not in (select u from l));
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 2))
   SubPlan 2
     ->  Nested Loop Anti Join
           InitPlan 1 (returns $0)
             ->  Seq Scan on l
           ->  Seq Scan on s s_1
                 Filter: ((n IS NOT NULL) OR (NOT $0))
           ->  Index Only Scan using l_u on l l_1
                 Index Cond: (u = s_1.n)
(10 rows)

select * from s where n not in (select n from s where n not in (select u from l));
 u | n | nn |  p  
---+---+----+-----
 1 | 1 |  1 | foo
 2 | 2 |  2 | foo
(2 rows)

explain (costs false) select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Aggregate
   ->  Seq Scan on s
         Filter: (NOT (SubPlan 2))
         SubPlan 2
           ->  Result
                 One-Time Filter: (NOT $2)
                 InitPlan 1 (returns $2)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l
                               Recheck Cond: ((s1.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_1
(18 rows)

select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
 count 
-------
     0
(1 row)

explain (costs false) select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from s1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Seq Scan on s
   Filter: ((NOT (hashed SubPlan 1)) AND (NOT (hashed SubPlan 2)) AND (NOT (hashed SubPlan 3)))
   SubPlan 1
     ->  Seq Scan on s1
   SubPlan 2
     ->  Seq Scan on s1 s1_1
   SubPlan 3
     ->  Seq Scan on s1 s1_2
(8 rows)

select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from s1);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from l);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: ((NOT (hashed SubPlan 1)) AND (NOT (hashed SubPlan 2)))
         SubPlan 1
           ->  Seq Scan on s1
         SubPlan 2
           ->  Seq Scan on s1 s1_1
   ->  Index Only Scan using l_nn on l
         Index Cond: (nn = s.nn)
(9 rows)

select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n))
and nn not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Aggregate
   ->  Seq Scan on s
         Filter: ((NOT (SubPlan 2)) AND (NOT (SubPlan 4)))
         SubPlan 2
           ->  Result
                 One-Time Filter: (NOT $2)
                 InitPlan 1 (returns $2)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l
                               Recheck Cond: ((s1.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_1
         SubPlan 4
           ->  Result
                 One-Time Filter: (NOT $6)
                 InitPlan 3 (returns $6)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1 s1_2
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l l_1
                               Recheck Cond: ((s1_2.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1_2.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_3
(33 rows)

select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n))
and nn not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
 count 
-------
     0
(1 row)

--test COALESCE
explain (costs false) select * from s where COALESCE(n, -1) not in (select COALESCE(n, -1) from l);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, '-1'::integer) = COALESCE(l.n, '-1'::integer))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, -1) not in (select COALESCE(n, -1) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(n, NULL, -1) not in (select COALESCE(n, NULL, -1) from l);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, '-1'::integer) = COALESCE(l.n, '-1'::integer))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, NULL, -1) not in (select COALESCE(n, NULL, -1) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(n, NULL, NULL) not in (select COALESCE(n, NULL, NULL) from l);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((COALESCE(s.n) = COALESCE(l.n)) OR (COALESCE(l.n) IS NULL))
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((COALESCE(n) IS NOT NULL) OR (NOT $0))
   ->  Materialize
         ->  Seq Scan on l
(8 rows)

select * from s where COALESCE(n, NULL, NULL) not in (select COALESCE(n, NULL, NULL) from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where COALESCE(n, nn) not in (select COALESCE(n, nn) from l);
                        QUERY PLAN                        
----------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, s.nn) = COALESCE(l.n, l.nn))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, nn) not in (select COALESCE(n, nn) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(nn, NULL) not in (select COALESCE(nn, NULL) from l);
                   QUERY PLAN                   
------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.nn) = COALESCE(l.nn))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(nn, NULL) not in (select COALESCE(nn, NULL) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (COALESCE(n, -1), nn, COALESCE(n, u)) not in (select COALESCE(n, -1), nn, COALESCE(n, u) from l);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((COALESCE(s.n, '-1'::integer) = COALESCE(n, '-1'::integer)) AND (COALESCE(s.n, s.u) = COALESCE(n, u)))
(5 rows)

select * from s where (COALESCE(n, -1), nn, COALESCE(n, u)) not in (select COALESCE(n, -1), nn, COALESCE(n, u) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

-- test miscellaneous outer nullable cases
explain (costs false) select * from s where (n,n) not in (select n,n from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s.n = l.n) AND (s.n = l.n)) IS NOT FALSE)
   ->  Seq Scan on s
   ->  Materialize
         ->  Seq Scan on l
(5 rows)

select * from s where (n,n) not in (select n,n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s.n = l_1.n) AND (s.u = l_1.u) AND (s.nn = l_1.nn)) IS NOT FALSE)
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
   ->  Materialize
         ->  Seq Scan on l l_1
(9 rows)

select * from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l);
 u | n | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l where u < 0);
                 QUERY PLAN                  
---------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
         SubPlan 1
           ->  Index Scan using l_u on l l_1
                 Index Cond: (u < 0)
(10 rows)

select count(*) from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l where u < 0);
 count 
-------
 10000
(1 row)

explain (costs false) select * from s where (n,n,n) not in (select distinct n,n,n from l where u > 0 limit 3) order by n;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: s.n
   ->  Seq Scan on s
         Filter: (NOT (hashed SubPlan 1))
         SubPlan 1
           ->  Limit
                 ->  Unique
                       ->  Index Scan using l_n on l
                             Filter: (u > 0)
(9 rows)

select * from s where (n,n,n) not in (select distinct n,n,n from l where u > 0 limit 3) order by n;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

--test outer has strict predicate or inner join
explain (costs false) select * from s where n not in (select n from l) and n > 0;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where n not in (select n from l) and n > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l) and u > 0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: (((n IS NOT NULL) OR (NOT $0)) AND (u > 0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l) and u > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l) and n is not null;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n IS NOT NULL)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where n not in (select n from l) and n is not null;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s join l on s.n = l.n where s.n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
   ->  Index Scan using l_n on l
         Index Cond: (n = s.n)
(12 rows)

select * from s join l on s.n = l.n where s.n not in (select n from l);
 u | n | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.n = l.n where s.n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Hash Left Join
               Hash Cond: (l.n = s.n)
               Filter: ((s.n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
(17 rows)

select count(*) from s right join l on s.n = l.n where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select n from l);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Nested Loop
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Bitmap Heap Scan on l l_1
                           Recheck Cond: ((s.n = n) OR (n IS NULL))
                           ->  BitmapOr
                                 ->  Bitmap Index Scan on l_n
                                       Index Cond: (n = s.n)
                                 ->  Bitmap Index Scan on l_n
                                       Index Cond: (n IS NULL)
               ->  Index Only Scan using l_n on l
                     Index Cond: (n = s.n)
         ->  Seq Scan on s1
(16 rows)

select count(*) from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select n from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               Filter: ((s.n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on s1
               ->  Materialize
                     ->  Nested Loop
                           ->  Seq Scan on s
                           ->  Index Only Scan using l_n on l
                                 Index Cond: (n = s.n)
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
(20 rows)

select count(*) from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select n from l);
 count 
-------
     0
(1 row)

--test inner has strict predicate or inner join
explain (costs false) select * from s where u not in (select n from l where n > 0);
                 QUERY PLAN                  
---------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.u) AND (n > 0))
(4 rows)

select * from s where u not in (select n from l where n > 0);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select n from l where u > 0);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.u = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.u)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where u not in (select n from l where u > 0);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select n from l where n is not null);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.u) AND (n IS NOT NULL))
(4 rows)

select * from s where u not in (select n from l where n is not null);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n=s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l join s on l.n=s.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l join s on l.u=s.u);
               QUERY PLAN                
-----------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Scan using l_u on l
                 Index Cond: (u = s_1.u)
(7 rows)

select * from s where u not in (select l.n from l join s on l.u=s.u);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n = s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l join s on l.n = s.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l right join s on l.n = s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l right join s on l.n = s.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select l.n from l right join s on l.n=s.n join s1 on l.n=s1.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Nested Loop
                 Join Filter: (s_1.n = s1.n)
                 ->  Seq Scan on s1
                 ->  Materialize
                       ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(11 rows)

select * from s where u not in (select l.n from l right join s on l.n=s.n join s1 on l.n=s1.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n=s.n right join s1 on l.n=s1.n);
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Only Scan using l_n on l
                             Index Cond: (n = s_1.n)
(11 rows)

select * from s where u not in (select l.n from l join s on l.n=s.n right join s1 on l.n=s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

--test both sides have strict predicate or inner join
explain (costs false) select * from s where n not in (select n from l where n > 0) and n > 0;
                 QUERY PLAN                  
---------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.n) AND (n > 0))
(5 rows)

select * from s where n not in (select n from l where n > 0) and n > 0;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where n not in (select n from l where u > 0) and n > 0;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(11 rows)

select * from s where n not in (select n from l where u > 0) and n > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l where n > 0) and u > 0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (n > 0)
   ->  Seq Scan on s
         Filter: (((n IS NOT NULL) OR (NOT $0)) AND (u > 0))
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.n) AND (n > 0))
(8 rows)

select * from s where n not in (select n from l where n > 0) and u > 0;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l right join s on l.n=s.n join s s1 on l.n=s1.n);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   Join Filter: (s.u = s1.u)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
                     Filter: (NOT (hashed SubPlan 1))
                     SubPlan 1
                       ->  Nested Loop
                             ->  Nested Loop
                                   Join Filter: (s_1.n = s1_1.n)
                                   ->  Seq Scan on s s_1
                                   ->  Materialize
                                         ->  Seq Scan on s s1_1
                             ->  Index Only Scan using l_n on l l_1
                                   Index Cond: (n = s_1.n)
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
(18 rows)

select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l right join s on l.n=s.n join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

explain (costs false) select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (s.u = s1.u)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
                     Filter: (NOT (hashed SubPlan 1))
                     SubPlan 1
                       ->  Nested Loop Left Join
                             Join Filter: (l_1.n = s1_1.n)
                             ->  Seq Scan on s s1_1
                             ->  Materialize
                                   ->  Nested Loop
                                         ->  Seq Scan on s s_1
                                         ->  Index Only Scan using l_n on l l_1
                                               Index Cond: (n = s_1.n)
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
(18 rows)

select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

explain (costs false) select * from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: (s.u = s1.u)
   Filter: (NOT (hashed SubPlan 1))
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l_1.n = s1_1.n)
           ->  Seq Scan on s s1_1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Only Scan using l_n on l l_1
                             Index Cond: (n = s_1.n)
(18 rows)

select * from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

--JIRA-7279 CTE with NOT IN
create table public.testing
(
a integer,
b integer,
c integer
);
explain (costs false) with
selected(a,b,c) as (values(1,2,3)),
updated(d,e,f) as (values(4,5,6))
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated);
                    QUERY PLAN                     
---------------------------------------------------
 Insert on testing
   ->  Result
         One-Time Filter: (NOT (hashed SubPlan 1))
         SubPlan 1
           ->  Result
(5 rows)

with
selected(a,b,c) as (values(1,2,3)),
updated(d,e,f) as (values(4,5,6))
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated);
select * from public.testing;
 a | b | c 
---+---+---
 1 | 2 | 3
(1 row)

explain (costs false) with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Insert on testing
   ->  Nested Loop Anti Join
         Join Filter: (((s.u = l.u) AND (s.n = l.n) AND (s.nn = l.nn)) IS NOT FALSE)
         ->  Seq Scan on s
         ->  Materialize
               ->  Seq Scan on l
(6 rows)

with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
(2 rows)

-- expect to get Hash Anti Join
explain (costs false) with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where a not in (select d from updated);
                     QUERY PLAN                      
-----------------------------------------------------
 Insert on testing
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
               Filter: ((u IS NOT NULL) OR (NOT $0))
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(8 rows)

with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where a not in (select d from updated);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
(3 rows)

explain (costs false) with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where b not in (select e from updated);
                       QUERY PLAN                       
--------------------------------------------------------
 Insert on testing
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
               Filter: ((n IS NOT NULL) OR (NOT $0))
         ->  Bitmap Heap Scan on l
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
(13 rows)

with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where b not in (select e from updated);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
(3 rows)

explain (costs false) with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where b not in (select d from updated);
                     QUERY PLAN                      
-----------------------------------------------------
 Insert on testing
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
               Filter: ((n IS NOT NULL) OR (NOT $0))
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.n)
(8 rows)

with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where b not in (select d from updated);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
(4 rows)

-- two levels of NOT IN with CTE, 2nd NOT IN
-- subquery access CTE two levels above
explain (costs false) with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated
      where d not in (select a from selected));
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Insert on testing
   CTE selected
     ->  Seq Scan on s
   ->  Nested Loop Anti Join
         Join Filter: (((selected.a = l.u) AND (selected.b = l.n) AND (selected.c = l.nn)) IS NOT FALSE)
         ->  CTE Scan on selected
         ->  Materialize
               ->  Seq Scan on l
                     Filter: (NOT (hashed SubPlan 3))
                     SubPlan 3
                       ->  CTE Scan on selected selected_1
(11 rows)

with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
insert into public.testing
select * from selected
where (a,b,c) not in (select d,e,f from updated
      where d not in (select a from selected));
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
       1 |       1 |       1
       2 |       2 |       2
 1000002 | 1000002 | 1000002
       3 |         |       3
(8 rows)

-- With clause inside a query block
explain select count(distinct t.a) from
(with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
select * from selected where (a,b,c) not in
(select d,e,f from updated
 where d not in (select a from selected))) as t;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Aggregate  (cost=693.75..693.76 rows=1 width=8)
   ->  Nested Loop Anti Join  (cost=1.13..693.71 rows=3 width=12)
         Join Filter: (((selected.a = l.u) AND (selected.b = l.n) AND (selected.c = l.nn)) IS NOT FALSE)
         CTE selected
           ->  Seq Scan on s  (cost=0.00..1.04 rows=4 width=12)
         ->  CTE Scan on selected  (cost=0.00..0.08 rows=4 width=12)
         ->  Materialize  (cost=0.09..230.09 rows=5000 width=12)
               ->  Seq Scan on l  (cost=0.09..180.09 rows=5000 width=12)
                     Filter: (NOT (hashed SubPlan 3))
                     SubPlan 3
                       ->  CTE Scan on selected selected_1  (cost=0.00..0.08 rows=4 width=4)
(11 rows)

select count(distinct t.a) from
(with
selected(a,b,c) as (select u, n, nn from s),
updated(d,e,f) as (select u, n, nn from l)
select * from selected where (a,b,c) not in
(select d,e,f from updated
 where d not in (select a from selected))) as t;
 count 
-------
     4
(1 row)

-- With clause in subquery, can't flatten subquery to anti join
explain (costs false) with
selected(a,b,c) as (select u, n, nn from s)
insert into public.testing
select * from selected where (a,b,c) not in
(with updated (d,e,f) as (select u, n, nn from l)
select d,e,f from updated);
            QUERY PLAN             
-----------------------------------
 Insert on testing
   ->  Seq Scan on s
         Filter: (NOT (SubPlan 1))
         SubPlan 1
           ->  Materialize
                 ->  Seq Scan on l
(6 rows)

with
selected(a,b,c) as (select u, n, nn from s)
insert into public.testing
select * from selected where (a,b,c) not in
(with updated (d,e,f) as (select u, n, nn from l)
select d,e,f from updated);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
       1 |       1 |       1
       2 |       2 |       2
 1000002 | 1000002 | 1000002
       3 |         |       3
 1000002 | 1000002 | 1000002
(9 rows)

-- With clause in subquery, subsubquery access CTE in subquery
explain (costs false) with
selected(a,b,c) as (select u, n, nn from s)
insert into public.testing
select * from selected where (a,b,c) not in
(
with updated(d,e,f) as (select u, n, nn from l)
select d,e,f from updated where d not in (select d from updated)
);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Insert on testing
   ->  Seq Scan on s
         Filter: (NOT (SubPlan 3))
         SubPlan 3
           ->  Materialize
                 CTE updated
                   ->  Seq Scan on l
                 InitPlan 2 (returns $1)
                   ->  CTE Scan on updated
                 ->  Hash Anti Join
                       Hash Cond: (updated_1.d = updated_2.d)
                       ->  CTE Scan on updated updated_1
                             Filter: ((d IS NOT NULL) OR (NOT $1))
                       ->  Hash
                             ->  CTE Scan on updated updated_2
(15 rows)

with
selected(a,b,c) as (select u, n, nn from s)
insert into public.testing
select * from selected where (a,b,c) not in
(
with updated(d,e,f) as (select u, n, nn from l)
select d,e,f from updated where d not in (select d from updated)
);
select * from public.testing;
    a    |    b    |    c    
---------+---------+---------
       1 |       2 |       3
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
 1000002 | 1000002 | 1000002
       1 |       1 |       1
       2 |       2 |       2
 1000002 | 1000002 | 1000002
       3 |         |       3
 1000002 | 1000002 | 1000002
       1 |       1 |       1
       2 |       2 |       2
 1000002 | 1000002 | 1000002
       3 |         |       3
(13 rows)

-- Recursive CTE
CREATE TABLE employees (
  id serial,
  name varchar(255),
  manager_id int
);
INSERT INTO employees VALUES (1, 'Mark', null);
INSERT INTO employees VALUES (2, 'John', 1);
INSERT INTO employees VALUES (3, 'Dan', 2);
INSERT INTO employees VALUES (4, 'Clark', 1);
INSERT INTO employees VALUES (5, 'Linda', 2);
INSERT INTO employees VALUES (6, 'Willy', 2);
INSERT INTO employees VALUES (7, 'Barack', 2);
INSERT INTO employees VALUES (8, 'Elen', 2);
INSERT INTO employees VALUES (9, 'Kate', 3);
INSERT INTO employees VALUES (10, 'Terry', 4);
WITH RECURSIVE managertree AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  INNER JOIN managertree mtree ON mtree.id = e.manager_id
)
SELECT *
FROM managertree;
 id |  name  | manager_id 
----+--------+------------
  2 | John   |          1
  3 | Dan    |          2
  5 | Linda  |          2
  6 | Willy  |          2
  7 | Barack |          2
  8 | Elen   |          2
  9 | Kate   |          3
(7 rows)

-- NOT IN subquery access Recursive CTE
EXPLAIN (COSTS FALSE) WITH RECURSIVE managertree AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  INNER JOIN managertree mtree ON mtree.id = e.manager_id
)
SELECT *
FROM managertree mt WHERE mt.manager_id NOT IN (SELECT id FROM managertree);
                          QUERY PLAN                           
---------------------------------------------------------------
 CTE Scan on managertree mt
   Filter: (NOT (hashed SubPlan 2))
   CTE managertree
     ->  Recursive Union
           ->  Seq Scan on employees
                 Filter: (id = 2)
           ->  Hash Join
                 Hash Cond: (e.manager_id = mtree.id)
                 ->  Seq Scan on employees e
                 ->  Hash
                       ->  WorkTable Scan on managertree mtree
   SubPlan 2
     ->  CTE Scan on managertree
(13 rows)

WITH RECURSIVE managertree AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  INNER JOIN managertree mtree ON mtree.id = e.manager_id
)
SELECT *
FROM managertree mt WHERE mt.manager_id NOT IN (SELECT id FROM managertree);
 id | name | manager_id 
----+------+------------
  2 | John |          1
(1 row)

-- NOT IN under UNION ALL inside Recursive CTE
EXPLAIN (COSTS FALSE) WITH RECURSIVE managertree AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  INNER JOIN managertree mtree ON
  (mtree.id = e.manager_id AND
  mtree.manager_id NOT IN (SELECT manager_id FROM employees)
  )
)
SELECT *
FROM managertree;
                          QUERY PLAN                           
---------------------------------------------------------------
 CTE Scan on managertree
   CTE managertree
     ->  Recursive Union
           ->  Seq Scan on employees employees_1
                 Filter: (id = 2)
           ->  Hash Join
                 Hash Cond: (e.manager_id = mtree.id)
                 ->  Seq Scan on employees e
                 ->  Hash
                       ->  WorkTable Scan on managertree mtree
                             Filter: (NOT (hashed SubPlan 1))
                             SubPlan 1
                               ->  Seq Scan on employees
(13 rows)

WITH RECURSIVE managertree AS (
  SELECT id, name, manager_id
  FROM employees
  WHERE id = 2
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employees e
  INNER JOIN managertree mtree ON
  (mtree.id = e.manager_id AND
  mtree.manager_id NOT IN (SELECT manager_id FROM employees)
  )
)
SELECT *
FROM managertree;
 id | name | manager_id 
----+------+------------
  2 | John |          1
(1 row)

--Manfred-7613 CTE NOT IN with Union All
create table cocotero as (
	select * from(
	values(1,2,3)) as data(a,b,c)
);
explain (costs off) with selected as (
	select *
	from cocotero
),
updated as (
	update cocotero
	set a = 3
	from selected
	where cocotero.a = selected.a
	returning selected.a,selected.b,selected.c
),
inserted as (
	insert into cocotero
	select *
	from selected
	where a not in (select a from updated)
	returning *
)
select 'updated' as action, count(*) as lines from updated
union all
select 'inserted' as action, count(*) as lines from inserted;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Append
   CTE selected
     ->  Seq Scan on cocotero
   CTE updated
     ->  Update on cocotero cocotero_1
           ->  Merge Join
                 Merge Cond: (cocotero_1.a = selected.a)
                 ->  Sort
                       Sort Key: cocotero_1.a
                       ->  Seq Scan on cocotero cocotero_1
                 ->  Materialize
                       ->  Sort
                             Sort Key: selected.a
                             ->  CTE Scan on selected
   CTE inserted
     ->  Insert on cocotero cocotero_2
           InitPlan 3 (returns $3)
             ->  CTE Scan on updated updated_1
           ->  Nested Loop Anti Join
                 Join Filter: ((selected_1.a = updated_2.a) OR (updated_2.a IS NULL))
                 ->  CTE Scan on selected selected_1
                       Filter: ((a IS NOT NULL) OR (NOT $3))
                 ->  CTE Scan on updated updated_2
   ->  Aggregate
         ->  CTE Scan on updated
   ->  Aggregate
         ->  CTE Scan on inserted
(27 rows)

with selected as (
	select *
	from cocotero
),
updated as (
	update cocotero
	set a = 3
	from selected
	where cocotero.a = selected.a
	returning selected.a,selected.b,selected.c
),
inserted as (
	insert into cocotero
	select *
	from selected
	where a not in (select a from updated)
	returning *
)
select 'updated' as action, count(*) as lines from updated
union all
select 'inserted' as action, count(*) as lines from inserted;
  action  | lines 
----------+-------
 updated  |     1
 inserted |     0
(2 rows)

--test enable_not_in_transform
explain (costs off) select count(*) from s where s.u not in (select l.u from l);
                 QUERY PLAN                 
--------------------------------------------
 Aggregate
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(5 rows)

set enable_not_in_transform = off;
explain (costs off) select count(*) from s where s.u not in (select l.u from l);
            QUERY PLAN             
-----------------------------------
 Aggregate
   ->  Seq Scan on s
         Filter: (NOT (SubPlan 1))
         SubPlan 1
           ->  Materialize
                 ->  Seq Scan on l
(6 rows)

-- clean up
reset work_mem;
reset enable_not_in_transform;
drop table s;
drop table s1;
drop table l;
drop table empty;
drop table public.testing;
drop table employees;
drop table cocotero;
