CREATE SCHEMA IF NOT EXISTS gtt_function;
set search_path=gtt_function,sys;
create global temp table gtt1(a int primary key, b text);
create global temp table gtt_test_rename(a int primary key, b text);
create global temp table gtt2(a int primary key, b text) on commit delete rows;
create global temp table gtt3(a int primary key, b text) on commit PRESERVE rows;
create global temp table tmp_t0(c0 tsvector,c1 varchar(100));
create table tbl_inherits_parent(
a int not null,
b varchar(32) not null default 'Got u',
c int check (c > 0),
d date not null
);
create global temp table tbl_inherits_parent_global_temp(
a int not null,
b varchar(32) not null default 'Got u',
c int check (c > 0),
d date not null
)on commit delete rows;
CREATE global temp TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
-- ERROR
create index CONCURRENTLY idx_gtt1 on gtt1 (b);
ERROR:  cannot create indexes on global temporary tables using concurrent mode
-- ERROR
cluster gtt1 using gtt1_pkey;
ERROR:  not support cluster global temporary tables yet
-- ERROR
create table gtt1(a int primary key, b text) on commit delete rows;
ERROR:  ON COMMIT can only be used on temporary tables
-- ok
create table gtt1(a int primary key, b text) with(on_commit_delete_rows=true);
ERROR:  regular table cannot specifie on_commit_delete_rows
-- ok
CREATE global temp TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
--ok
CREATE global temp TABLE p_table01 (
id        bigserial NOT NULL,
cre_time  timestamp without time zone,
note      varchar(30)
) PARTITION BY RANGE (cre_time)
WITH (
OIDS = FALSE
)on commit delete rows;
 
CREATE global temp TABLE p_table01_2018
PARTITION OF p_table01
FOR VALUES FROM ('2018-01-01 00:00:00') TO ('2019-01-01 00:00:00');
 
CREATE global temp TABLE p_table01_2017
PARTITION OF p_table01
FOR VALUES FROM ('2017-01-01 00:00:00') TO ('2018-01-01 00:00:00');
begin;
insert into p_table01 values(1,'2018-01-02 00:00:00','test1');
insert into p_table01 values(1,'2018-01-02 00:00:00','test2');
select count(*) from p_table01;
 count 
-------
     2
(1 row)

commit;
select count(*) from p_table01;
 count 
-------
     0
(1 row)

--ok
CREATE global temp TABLE p_table02 (
id        bigserial NOT NULL,
cre_time  timestamp without time zone,
note      varchar(30)
) PARTITION BY RANGE (cre_time)
WITH (
OIDS = FALSE
)
on commit PRESERVE rows;
CREATE global temp TABLE p_table02_2018
PARTITION OF p_table02
FOR VALUES FROM ('2018-01-01 00:00:00') TO ('2019-01-01 00:00:00');
CREATE global temp TABLE p_table02_2017
PARTITION OF p_table02
FOR VALUES FROM ('2017-01-01 00:00:00') TO ('2018-01-01 00:00:00');
-- ok
create global temp table tbl_inherits_partition() inherits (tbl_inherits_parent);
ERROR:  The parent table must be global temporary table
create global temp table tbl_inherits_partition() inherits (tbl_inherits_parent_global_temp) on commit delete rows;
select relname ,relkind, relpersistence, reloptions from pg_class where relname like 'p_table0%' or  relname like 'tbl_inherits%' order by relname;
             relname             | relkind | relpersistence |          reloptions           
---------------------------------+---------+----------------+-------------------------------
 p_table01                       | p       | g              | {on_commit_delete_rows=true}
 p_table01_2017                  | r       | g              | {on_commit_delete_rows=true}
 p_table01_2018                  | r       | g              | {on_commit_delete_rows=true}
 p_table01_id_seq                | S       | g              | 
 p_table02                       | p       | g              | {on_commit_delete_rows=false}
 p_table02_2017                  | r       | g              | {on_commit_delete_rows=false}
 p_table02_2018                  | r       | g              | {on_commit_delete_rows=false}
 p_table02_id_seq                | S       | g              | 
 tbl_inherits_parent             | r       | p              | 
 tbl_inherits_parent_global_temp | r       | g              | {on_commit_delete_rows=true}
 tbl_inherits_partition          | r       | g              | {on_commit_delete_rows=true}
(11 rows)

-- ERROR
create global temp table gtt3(a int primary key, b text) on commit drop;
ERROR:  global temp table not support on commit drop clause
-- ERROR
create global temp table gtt4(a int primary key, b text) with(on_commit_delete_rows=true) on commit delete rows;
ERROR:  can not defeine global temp table with on commit and with clause at same time
-- ok
create global temp table gtt5(a int primary key, b text) with(on_commit_delete_rows=true);
--ok
alter table gtt_test_rename rename to gtt_test;
-- ok
ALTER TABLE gtt_test ADD COLUMN address varchar(30);
-- ERROR
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
ERROR:  referenced relation "products" is not a global temp table
-- ERROR
CREATE global temp TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
ERROR:  referenced relation "products" is not a global temp table
-- ERROR
CREATE GLOBAL TEMPORARY TABLE mytable (
  id SERIAL PRIMARY KEY,
  data text
) on commit preserve rows;
-- ok
create global temp table gtt_seq(id int GENERATED ALWAYS AS IDENTITY (START WITH 2) primary key, a int)  on commit PRESERVE rows;
insert into gtt_seq (a) values(1);
insert into gtt_seq (a) values(2);
select * from gtt_seq order by id;
 id | a 
----+---
  2 | 1
  3 | 2
(2 rows)

truncate gtt_seq;
select * from gtt_seq order by id;
 id | a 
----+---
(0 rows)

insert into gtt_seq (a) values(3);
select * from gtt_seq order by id;
 id | a 
----+---
  4 | 3
(1 row)

--ERROR
CREATE MATERIALIZED VIEW mv_gtt1 as select * from gtt1;
ERROR:  materialized views must not use global temporary tables or views
-- ALL ERROR
create index idx_err on gtt1 using hash (a);
ERROR:  only support btree index on global temp table
create index idx_err on gtt1 using gist (a);
ERROR:  data type integer has no default operator class for access method "gist"
HINT:  You must specify an operator class for the index or define a default operator class for the data type.
create index idx_tmp_t0_1 on tmp_t0 using gin (c0);
ERROR:  only support btree index on global temp table
create index idx_tmp_t0_1 on tmp_t0 using gist (c0);
ERROR:  only support btree index on global temp table
--ok
create global temp table gt (a SERIAL,b int);
begin;
set transaction_read_only = true;
insert into gt (b) values(1);
select * from gt;
 a | b 
---+---
 1 | 1
(1 row)

commit;
--ok
create global temp table gt1(a int);
insert into gt1 values(generate_series(1,100000));
create index idx_gt1_1 on gt1 (a);
create index idx_gt1_2 on gt1((a + 1));
create index idx_gt1_3 on gt1((a*10),(a+a),(a-1));
explain select * from gt1 where a=1;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on gt1  (cost=12.17..482.50 rows=500 width=4)
   Recheck Cond: (a = 1)
   ->  Bitmap Index Scan on idx_gt1_1  (cost=0.00..12.04 rows=500 width=0)
         Index Cond: (a = 1)
(4 rows)

explain select * from gt1 where a=200000;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on gt1  (cost=12.17..482.50 rows=500 width=4)
   Recheck Cond: (a = 200000)
   ->  Bitmap Index Scan on idx_gt1_1  (cost=0.00..12.04 rows=500 width=0)
         Index Cond: (a = 200000)
(4 rows)

explain select * from gt1 where a*10=300;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on gt1  (cost=12.29..483.88 rows=500 width=4)
   Recheck Cond: ((a * 10) = 300)
   ->  Bitmap Index Scan on idx_gt1_3  (cost=0.00..12.17 rows=500 width=0)
         Index Cond: ((a * 10) = 300)
(4 rows)

explain select * from gt1 where a*10=3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on gt1  (cost=12.29..483.88 rows=500 width=4)
   Recheck Cond: ((a * 10) = 3)
   ->  Bitmap Index Scan on idx_gt1_3  (cost=0.00..12.17 rows=500 width=0)
         Index Cond: ((a * 10) = 3)
(4 rows)

analyze gt1;
explain select * from gt1 where a=1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Index Only Scan using idx_gt1_1 on gt1  (cost=0.29..8.31 rows=1 width=4)
   Index Cond: (a = 1)
(2 rows)

explain select * from gt1 where a=200000;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Index Only Scan using idx_gt1_1 on gt1  (cost=0.29..8.31 rows=1 width=4)
   Index Cond: (a = 200000)
(2 rows)

explain select * from gt1 where a*10=300;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Index Scan using idx_gt1_3 on gt1  (cost=0.42..8.44 rows=1 width=4)
   Index Cond: ((a * 10) = 300)
(2 rows)

explain select * from gt1 where a*10=3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Index Scan using idx_gt1_3 on gt1  (cost=0.42..8.44 rows=1 width=4)
   Index Cond: ((a * 10) = 3)
(2 rows)

reset search_path;
drop schema gtt_function cascade;
NOTICE:  drop cascades to 17 other objects
DETAIL:  drop cascades to table gtt_function.gtt1
drop cascades to table gtt_function.gtt_test
drop cascades to table gtt_function.gtt2
drop cascades to table gtt_function.gtt3
drop cascades to table gtt_function.tmp_t0
drop cascades to table gtt_function.tbl_inherits_parent
drop cascades to table gtt_function.tbl_inherits_parent_global_temp
drop cascades to table gtt_function.products
drop cascades to table gtt_function.measurement
drop cascades to table gtt_function.p_table01
drop cascades to table gtt_function.p_table02
drop cascades to table gtt_function.tbl_inherits_partition
drop cascades to table gtt_function.gtt5
drop cascades to table gtt_function.mytable
drop cascades to table gtt_function.gtt_seq
drop cascades to table gtt_function.gt
drop cascades to table gtt_function.gt1
