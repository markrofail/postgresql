--
-- PARTITION_JOIN
-- Test partitionwise join between partitioned tables
--
-- Enable partitionwise join, which by default is disabled.
SET enable_partitionwise_join to true;
--
-- partitioned by a single column
--
CREATE TABLE prt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_p1 PARTITION OF prt1 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_p3 PARTITION OF prt1 FOR VALUES FROM (500) TO (600);
CREATE TABLE prt1_p2 PARTITION OF prt1 FOR VALUES FROM (250) TO (500);
INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0;
CREATE INDEX iprt1_p1_a on prt1_p1(a);
CREATE INDEX iprt1_p2_a on prt1_p2(a);
CREATE INDEX iprt1_p3_a on prt1_p3(a);
ANALYZE prt1;
CREATE TABLE prt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_p1 PARTITION OF prt2 FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_p2 PARTITION OF prt2 FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_p3 PARTITION OF prt2 FOR VALUES FROM (500) TO (600);
INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0;
CREATE INDEX iprt2_p1_b on prt2_p1(b);
CREATE INDEX iprt2_p2_b on prt2_p2(b);
CREATE INDEX iprt2_p3_b on prt2_p3(b);
ANALYZE prt2;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_p3 t1_3
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0150 | 150 | 0150
 300 | 0300 | 300 | 0300
 450 | 0450 | 450 | 0450
(4 rows)

-- left outer join, with whole-row reference; partitionwise join does not apply
EXPLAIN (COSTS OFF)
SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Hash Right Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_p1 t2_1
               ->  Seq Scan on prt2_p2 t2_2
               ->  Seq Scan on prt2_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_p1 t1_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_p2 t1_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_p3 t1_3
                           Filter: (b = 0)
(16 rows)

SELECT t1, t2 FROM prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
      t1      |      t2      
--------------+--------------
 (0,0,0000)   | (0,0,0000)
 (50,0,0050)  | 
 (100,0,0100) | 
 (150,0,0150) | (0,150,0150)
 (200,0,0200) | 
 (250,0,0250) | 
 (300,0,0300) | (0,300,0300)
 (350,0,0350) | 
 (400,0,0400) | 
 (450,0,0450) | (0,450,0450)
 (500,0,0500) | 
 (550,0,0550) | 
(12 rows)

-- right outer join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Right Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Seq Scan on prt1_p1 t1_1
               ->  Hash
                     ->  Seq Scan on prt2_p1 t2_1
                           Filter: (a = 0)
         ->  Hash Right Join
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Seq Scan on prt1_p2 t1_2
               ->  Hash
                     ->  Seq Scan on prt2_p2 t2_2
                           Filter: (a = 0)
         ->  Nested Loop Left Join
               ->  Seq Scan on prt2_p3 t2_3
                     Filter: (a = 0)
               ->  Index Scan using iprt1_p3_a on prt1_p3 t1_3
                     Index Cond: (a = t2_3.b)
(20 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0150 | 150 | 0150
 300 | 0300 | 300 | 0300
 450 | 0450 | 450 | 0450
     |      |  75 | 0075
     |      | 225 | 0225
     |      | 375 | 0375
     |      | 525 | 0525
(8 rows)

-- full outer join, with placeholder vars
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort
   Sort Key: prt1.a, prt2.b
   ->  Append
         ->  Hash Full Join
               Hash Cond: (prt1_1.a = prt2_1.b)
               Filter: (((50) = prt1_1.a) OR ((75) = prt2_1.b))
               ->  Seq Scan on prt1_p1 prt1_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_p1 prt2_1
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: (prt1_2.a = prt2_2.b)
               Filter: (((50) = prt1_2.a) OR ((75) = prt2_2.b))
               ->  Seq Scan on prt1_p2 prt1_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_p2 prt2_2
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: (prt1_3.a = prt2_3.b)
               Filter: (((50) = prt1_3.a) OR ((75) = prt2_3.b))
               ->  Seq Scan on prt1_p3 prt1_3
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_p3 prt2_3
                           Filter: (a = 0)
(27 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
 a  |  c   | b  |  c   
----+------+----+------
 50 | 0050 |    | 
    |      | 75 | 0075
(2 rows)

-- Join with pruned partitions from joining relations
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a < 450 AND t2.b > 250 AND t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Seq Scan on prt2_p2 t2
               Filter: (b > 250)
         ->  Hash
               ->  Seq Scan on prt1_p2 t1
                     Filter: ((a < 450) AND (b = 0))
(9 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a < 450 AND t2.b > 250 AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 300 | 0300 | 300 | 0300
(1 row)

-- Currently we can't do partitioned join if nullable-side partitions are pruned
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                        QUERY PLAN                         
-----------------------------------------------------------
 Sort
   Sort Key: prt1.a, prt2.b
   ->  Hash Right Join
         Hash Cond: (prt2.b = prt1.a)
         ->  Append
               ->  Seq Scan on prt2_p2 prt2_1
                     Filter: (b > 250)
               ->  Seq Scan on prt2_p3 prt2_2
                     Filter: (b > 250)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_p1 prt1_1
                           Filter: ((a < 450) AND (b = 0))
                     ->  Seq Scan on prt1_p2 prt1_2
                           Filter: ((a < 450) AND (b = 0))
(15 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |     | 
  50 | 0050 |     | 
 100 | 0100 |     | 
 150 | 0150 |     | 
 200 | 0200 |     | 
 250 | 0250 |     | 
 300 | 0300 | 300 | 0300
 350 | 0350 |     | 
 400 | 0400 |     | 
(9 rows)

-- Currently we can't do partitioned join if nullable-side partitions are pruned
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: prt1.a, prt2.b
   ->  Hash Full Join
         Hash Cond: (prt1.a = prt2.b)
         Filter: ((prt1.b = 0) OR (prt2.a = 0))
         ->  Append
               ->  Seq Scan on prt1_p1 prt1_1
                     Filter: (a < 450)
               ->  Seq Scan on prt1_p2 prt1_2
                     Filter: (a < 450)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt2_p2 prt2_1
                           Filter: (b > 250)
                     ->  Seq Scan on prt2_p3 prt2_2
                           Filter: (b > 250)
(16 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |     | 
  50 | 0050 |     | 
 100 | 0100 |     | 
 150 | 0150 |     | 
 200 | 0200 |     | 
 250 | 0250 |     | 
 300 | 0300 | 300 | 0300
 350 | 0350 |     | 
 400 | 0400 |     | 
     |      | 375 | 0375
     |      | 450 | 0450
     |      | 525 | 0525
(12 rows)

-- Semi-join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t2.b FROM prt2 t2 WHERE t2.a = 0) AND t1.b = 0 ORDER BY t1.a;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Semi Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Seq Scan on prt1_p1 t1_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_p1 t2_1
                           Filter: (a = 0)
         ->  Hash Semi Join
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Seq Scan on prt1_p2 t1_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_p2 t2_2
                           Filter: (a = 0)
         ->  Nested Loop Semi Join
               Join Filter: (t1_3.a = t2_3.b)
               ->  Seq Scan on prt1_p3 t1_3
                     Filter: (b = 0)
               ->  Materialize
                     ->  Seq Scan on prt2_p3 t2_3
                           Filter: (a = 0)
(24 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t2.b FROM prt2 t2 WHERE t2.a = 0) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

-- Anti-join with aggregates
EXPLAIN (COSTS OFF)
SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
                    QUERY PLAN                    
--------------------------------------------------
 Aggregate
   ->  Append
         ->  Hash Anti Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Seq Scan on prt1_p1 t1_1
               ->  Hash
                     ->  Seq Scan on prt2_p1 t2_1
         ->  Hash Anti Join
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Seq Scan on prt1_p2 t1_2
               ->  Hash
                     ->  Seq Scan on prt2_p2 t2_2
         ->  Hash Anti Join
               Hash Cond: (t1_3.a = t2_3.b)
               ->  Seq Scan on prt1_p3 t1_3
               ->  Hash
                     ->  Seq Scan on prt2_p3 t2_3
(17 rows)

SELECT sum(t1.a), avg(t1.a), sum(t1.b), avg(t1.b) FROM prt1 t1 WHERE NOT EXISTS (SELECT 1 FROM prt2 t2 WHERE t1.a = t2.b);
  sum  |         avg          | sum  |         avg         
-------+----------------------+------+---------------------
 60000 | 300.0000000000000000 | 2400 | 12.0000000000000000
(1 row)

-- lateral reference
EXPLAIN (COSTS OFF)
SELECT * FROM prt1 t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss
			  ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_p1 t1_1
                     Filter: (b = 0)
               ->  Nested Loop
                     ->  Index Only Scan using iprt1_p1_a on prt1_p1 t2_1
                           Index Cond: (a = t1_1.a)
                     ->  Index Scan using iprt2_p1_b on prt2_p1 t3_1
                           Index Cond: (b = t2_1.a)
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_p2 t1_2
                     Filter: (b = 0)
               ->  Nested Loop
                     ->  Index Only Scan using iprt1_p2_a on prt1_p2 t2_2
                           Index Cond: (a = t1_2.a)
                     ->  Index Scan using iprt2_p2_b on prt2_p2 t3_2
                           Index Cond: (b = t2_2.a)
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_p3 t1_3
                     Filter: (b = 0)
               ->  Nested Loop
                     ->  Index Only Scan using iprt1_p3_a on prt1_p3 t2_3
                           Index Cond: (a = t1_3.a)
                     ->  Index Scan using iprt2_p3_b on prt2_p3 t3_3
                           Index Cond: (b = t2_3.a)
(27 rows)

SELECT * FROM prt1 t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t3.a AS t3a, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss
			  ON t1.a = ss.t2a WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t3a | least 
-----+---+------+-----+-----+-------
   0 | 0 | 0000 |   0 |   0 |     0
  50 | 0 | 0050 |     |     |      
 100 | 0 | 0100 |     |     |      
 150 | 0 | 0150 | 150 |   0 |   150
 200 | 0 | 0200 |     |     |      
 250 | 0 | 0250 |     |     |      
 300 | 0 | 0300 | 300 |   0 |   300
 350 | 0 | 0350 |     |     |      
 400 | 0 | 0400 |     |     |      
 450 | 0 | 0450 | 450 |   0 |   450
 500 | 0 | 0500 |     |     |      
 550 | 0 | 0550 |     |     |      
(12 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, ss.t2a, ss.t2c FROM prt1 t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t3.a AS t3a, t2.b t2b, t2.c t2c, least(t1.a,t2.a,t3.b) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss
			  ON t1.c = ss.t2c WHERE (t1.b + coalesce(ss.t2b, 0)) = 0 ORDER BY t1.a;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Left Join
         Hash Cond: ((t1.c)::text = (t2.c)::text)
         Filter: ((t1.b + COALESCE(t2.b, 0)) = 0)
         ->  Append
               ->  Seq Scan on prt1_p1 t1_1
               ->  Seq Scan on prt1_p2 t1_2
               ->  Seq Scan on prt1_p3 t1_3
         ->  Hash
               ->  Append
                     ->  Hash Join
                           Hash Cond: (t2_1.a = t3_1.b)
                           ->  Seq Scan on prt1_p1 t2_1
                           ->  Hash
                                 ->  Seq Scan on prt2_p1 t3_1
                     ->  Hash Join
                           Hash Cond: (t2_2.a = t3_2.b)
                           ->  Seq Scan on prt1_p2 t2_2
                           ->  Hash
                                 ->  Seq Scan on prt2_p2 t3_2
                     ->  Hash Join
                           Hash Cond: (t2_3.a = t3_3.b)
                           ->  Seq Scan on prt1_p3 t2_3
                           ->  Hash
                                 ->  Seq Scan on prt2_p3 t3_3
(26 rows)

SELECT t1.a, ss.t2a, ss.t2c FROM prt1 t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t3.a AS t3a, t2.b t2b, t2.c t2c, least(t1.a,t2.a,t3.a) FROM prt1 t2 JOIN prt2 t3 ON (t2.a = t3.b)) ss
			  ON t1.c = ss.t2c WHERE (t1.b + coalesce(ss.t2b, 0)) = 0 ORDER BY t1.a;
  a  | t2a | t2c  
-----+-----+------
   0 |   0 | 0000
  50 |     | 
 100 |     | 
 150 | 150 | 0150
 200 |     | 
 250 |     | 
 300 | 300 | 0300
 350 |     | 
 400 |     | 
 450 | 450 | 0450
 500 |     | 
 550 |     | 
(12 rows)

-- bug with inadequate sort key representation
SET enable_partitionwise_aggregate TO true;
SET enable_hashjoin TO false;
EXPLAIN (COSTS OFF)
SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)
  WHERE a BETWEEN 490 AND 510
  GROUP BY 1, 2 ORDER BY 1, 2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Group
   Group Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
   ->  Merge Append
         Sort Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
         ->  Group
               Group Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
               ->  Sort
                     Sort Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
                     ->  Merge Full Join
                           Merge Cond: ((prt1.a = p2.a) AND (prt1.b = p2.b))
                           Filter: ((COALESCE(prt1.a, p2.a) >= 490) AND (COALESCE(prt1.a, p2.a) <= 510))
                           ->  Sort
                                 Sort Key: prt1.a, prt1.b
                                 ->  Seq Scan on prt1_p1 prt1
                           ->  Sort
                                 Sort Key: p2.a, p2.b
                                 ->  Seq Scan on prt2_p1 p2
         ->  Group
               Group Key: (COALESCE(prt1_1.a, p2_1.a)), (COALESCE(prt1_1.b, p2_1.b))
               ->  Sort
                     Sort Key: (COALESCE(prt1_1.a, p2_1.a)), (COALESCE(prt1_1.b, p2_1.b))
                     ->  Merge Full Join
                           Merge Cond: ((prt1_1.a = p2_1.a) AND (prt1_1.b = p2_1.b))
                           Filter: ((COALESCE(prt1_1.a, p2_1.a) >= 490) AND (COALESCE(prt1_1.a, p2_1.a) <= 510))
                           ->  Sort
                                 Sort Key: prt1_1.a, prt1_1.b
                                 ->  Seq Scan on prt1_p2 prt1_1
                           ->  Sort
                                 Sort Key: p2_1.a, p2_1.b
                                 ->  Seq Scan on prt2_p2 p2_1
         ->  Group
               Group Key: (COALESCE(prt1_2.a, p2_2.a)), (COALESCE(prt1_2.b, p2_2.b))
               ->  Sort
                     Sort Key: (COALESCE(prt1_2.a, p2_2.a)), (COALESCE(prt1_2.b, p2_2.b))
                     ->  Merge Full Join
                           Merge Cond: ((prt1_2.a = p2_2.a) AND (prt1_2.b = p2_2.b))
                           Filter: ((COALESCE(prt1_2.a, p2_2.a) >= 490) AND (COALESCE(prt1_2.a, p2_2.a) <= 510))
                           ->  Sort
                                 Sort Key: prt1_2.a, prt1_2.b
                                 ->  Seq Scan on prt1_p3 prt1_2
                           ->  Sort
                                 Sort Key: p2_2.a, p2_2.b
                                 ->  Seq Scan on prt2_p3 p2_2
(43 rows)

SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)
  WHERE a BETWEEN 490 AND 510
  GROUP BY 1, 2 ORDER BY 1, 2;
  a  | b  
-----+----
 490 | 15
 492 | 17
 494 | 19
 495 | 20
 496 | 21
 498 | 23
 500 |  0
 501 |  1
 502 |  2
 504 |  4
 506 |  6
 507 |  7
 508 |  8
 510 | 10
(14 rows)

RESET enable_partitionwise_aggregate;
RESET enable_hashjoin;
--
-- partitioned by expression
--
CREATE TABLE prt1_e (a int, b int, c int) PARTITION BY RANGE(((a + b)/2));
CREATE TABLE prt1_e_p1 PARTITION OF prt1_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_e_p2 PARTITION OF prt1_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt1_e_p3 PARTITION OF prt1_e FOR VALUES FROM (500) TO (600);
INSERT INTO prt1_e SELECT i, i, i % 25 FROM generate_series(0, 599, 2) i;
CREATE INDEX iprt1_e_p1_ab2 on prt1_e_p1(((a+b)/2));
CREATE INDEX iprt1_e_p2_ab2 on prt1_e_p2(((a+b)/2));
CREATE INDEX iprt1_e_p3_ab2 on prt1_e_p3(((a+b)/2));
ANALYZE prt1_e;
CREATE TABLE prt2_e (a int, b int, c int) PARTITION BY RANGE(((b + a)/2));
CREATE TABLE prt2_e_p1 PARTITION OF prt2_e FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_e_p2 PARTITION OF prt2_e FOR VALUES FROM (250) TO (500);
CREATE TABLE prt2_e_p3 PARTITION OF prt2_e FOR VALUES FROM (500) TO (600);
INSERT INTO prt2_e SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
ANALYZE prt2_e;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Join
               Hash Cond: (((t2_1.b + t2_1.a) / 2) = ((t1_1.a + t1_1.b) / 2))
               ->  Seq Scan on prt2_e_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_e_p1 t1_1
                           Filter: (c = 0)
         ->  Hash Join
               Hash Cond: (((t2_2.b + t2_2.a) / 2) = ((t1_2.a + t1_2.b) / 2))
               ->  Seq Scan on prt2_e_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_e_p2 t1_2
                           Filter: (c = 0)
         ->  Hash Join
               Hash Cond: (((t2_3.b + t2_3.a) / 2) = ((t1_3.a + t1_3.b) / 2))
               ->  Seq Scan on prt2_e_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_e_p3 t1_3
                           Filter: (c = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_e t1, prt2_e t2 WHERE (t1.a + t1.b)/2 = (t2.b + t2.a)/2 AND t1.c = 0 ORDER BY t1.a, t2.b;
  a  | c |  b  | c 
-----+---+-----+---
   0 | 0 |   0 | 0
 150 | 0 | 150 | 0
 300 | 0 | 300 | 0
 450 | 0 | 450 | 0
(4 rows)

--
-- N-way join
--
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM prt1 t1, prt2 t2, prt1_e t3 WHERE t1.a = t2.b AND t1.a = (t3.a + t3.b)/2 AND t1.b = 0 ORDER BY t1.a, t2.b;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop
               Join Filter: (t1_1.a = ((t3_1.a + t3_1.b) / 2))
               ->  Hash Join
                     Hash Cond: (t2_1.b = t1_1.a)
                     ->  Seq Scan on prt2_p1 t2_1
                     ->  Hash
                           ->  Seq Scan on prt1_p1 t1_1
                                 Filter: (b = 0)
               ->  Index Scan using iprt1_e_p1_ab2 on prt1_e_p1 t3_1
                     Index Cond: (((a + b) / 2) = t2_1.b)
         ->  Nested Loop
               Join Filter: (t1_2.a = ((t3_2.a + t3_2.b) / 2))
               ->  Hash Join
                     Hash Cond: (t2_2.b = t1_2.a)
                     ->  Seq Scan on prt2_p2 t2_2
                     ->  Hash
                           ->  Seq Scan on prt1_p2 t1_2
                                 Filter: (b = 0)
               ->  Index Scan using iprt1_e_p2_ab2 on prt1_e_p2 t3_2
                     Index Cond: (((a + b) / 2) = t2_2.b)
         ->  Nested Loop
               Join Filter: (t1_3.a = ((t3_3.a + t3_3.b) / 2))
               ->  Hash Join
                     Hash Cond: (t2_3.b = t1_3.a)
                     ->  Seq Scan on prt2_p3 t2_3
                     ->  Hash
                           ->  Seq Scan on prt1_p3 t1_3
                                 Filter: (b = 0)
               ->  Index Scan using iprt1_e_p3_ab2 on prt1_e_p3 t3_3
                     Index Cond: (((a + b) / 2) = t2_3.b)
(33 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM prt1 t1, prt2 t2, prt1_e t3 WHERE t1.a = t2.b AND t1.a = (t3.a + t3.b)/2 AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
(4 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Hash Right Join
               Hash Cond: (((t3_1.a + t3_1.b) / 2) = t1_1.a)
               ->  Seq Scan on prt1_e_p1 t3_1
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (t2_1.b = t1_1.a)
                           ->  Seq Scan on prt2_p1 t2_1
                           ->  Hash
                                 ->  Seq Scan on prt1_p1 t1_1
                                       Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (((t3_2.a + t3_2.b) / 2) = t1_2.a)
               ->  Seq Scan on prt1_e_p2 t3_2
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (t2_2.b = t1_2.a)
                           ->  Seq Scan on prt2_p2 t2_2
                           ->  Hash
                                 ->  Seq Scan on prt1_p2 t1_2
                                       Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (((t3_3.a + t3_3.b) / 2) = t1_3.a)
               ->  Seq Scan on prt1_e_p3 t3_3
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (t2_3.b = t1_3.a)
                           ->  Seq Scan on prt2_p3 t2_3
                           ->  Hash
                                 ->  Seq Scan on prt1_p3 t1_3
                                       Filter: (b = 0)
(33 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) LEFT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Nested Loop Left Join
               ->  Hash Right Join
                     Hash Cond: (t1_1.a = ((t3_1.a + t3_1.b) / 2))
                     ->  Seq Scan on prt1_p1 t1_1
                     ->  Hash
                           ->  Seq Scan on prt1_e_p1 t3_1
                                 Filter: (c = 0)
               ->  Index Scan using iprt2_p1_b on prt2_p1 t2_1
                     Index Cond: (b = t1_1.a)
         ->  Nested Loop Left Join
               ->  Hash Right Join
                     Hash Cond: (t1_2.a = ((t3_2.a + t3_2.b) / 2))
                     ->  Seq Scan on prt1_p2 t1_2
                     ->  Hash
                           ->  Seq Scan on prt1_e_p2 t3_2
                                 Filter: (c = 0)
               ->  Index Scan using iprt2_p2_b on prt2_p2 t2_2
                     Index Cond: (b = t1_2.a)
         ->  Nested Loop Left Join
               ->  Hash Right Join
                     Hash Cond: (t1_3.a = ((t3_3.a + t3_3.b) / 2))
                     ->  Seq Scan on prt1_p3 t1_3
                     ->  Hash
                           ->  Seq Scan on prt1_e_p3 t3_3
                                 Filter: (c = 0)
               ->  Index Scan using iprt2_p3_b on prt2_p3 t2_3
                     Index Cond: (b = t1_3.a)
(30 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

-- Cases with non-nullable expressions in subquery results;
-- make sure these go to null as expected
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: prt1.a, prt2.b, ((prt1_e.a + prt1_e.b))
   ->  Append
         ->  Hash Full Join
               Hash Cond: (prt1_1.a = ((prt1_e_1.a + prt1_e_1.b) / 2))
               Filter: ((prt1_1.a = (50)) OR (prt2_1.b = (75)) OR (((prt1_e_1.a + prt1_e_1.b) / 2) = (50)))
               ->  Hash Full Join
                     Hash Cond: (prt1_1.a = prt2_1.b)
                     ->  Seq Scan on prt1_p1 prt1_1
                           Filter: (b = 0)
                     ->  Hash
                           ->  Seq Scan on prt2_p1 prt2_1
                                 Filter: (a = 0)
               ->  Hash
                     ->  Seq Scan on prt1_e_p1 prt1_e_1
                           Filter: (c = 0)
         ->  Hash Full Join
               Hash Cond: (prt1_2.a = ((prt1_e_2.a + prt1_e_2.b) / 2))
               Filter: ((prt1_2.a = (50)) OR (prt2_2.b = (75)) OR (((prt1_e_2.a + prt1_e_2.b) / 2) = (50)))
               ->  Hash Full Join
                     Hash Cond: (prt1_2.a = prt2_2.b)
                     ->  Seq Scan on prt1_p2 prt1_2
                           Filter: (b = 0)
                     ->  Hash
                           ->  Seq Scan on prt2_p2 prt2_2
                                 Filter: (a = 0)
               ->  Hash
                     ->  Seq Scan on prt1_e_p2 prt1_e_2
                           Filter: (c = 0)
         ->  Hash Full Join
               Hash Cond: (prt1_3.a = ((prt1_e_3.a + prt1_e_3.b) / 2))
               Filter: ((prt1_3.a = (50)) OR (prt2_3.b = (75)) OR (((prt1_e_3.a + prt1_e_3.b) / 2) = (50)))
               ->  Hash Full Join
                     Hash Cond: (prt1_3.a = prt2_3.b)
                     ->  Seq Scan on prt1_p3 prt1_3
                           Filter: (b = 0)
                     ->  Hash
                           ->  Seq Scan on prt2_p3 prt2_3
                                 Filter: (a = 0)
               ->  Hash
                     ->  Seq Scan on prt1_e_p3 prt1_e_3
                           Filter: (c = 0)
(42 rows)

SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
 a  | phv | b  | phv | ?column? | phv 
----+-----+----+-----+----------+-----
 50 |  50 |    |     |      100 |  50
    |     | 75 |  75 |          |    
(2 rows)

-- Semi-join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop
               Join Filter: (t1_2.a = t1_5.b)
               ->  HashAggregate
                     Group Key: t1_5.b
                     ->  Hash Join
                           Hash Cond: (((t2_1.a + t2_1.b) / 2) = t1_5.b)
                           ->  Seq Scan on prt1_e_p1 t2_1
                           ->  Hash
                                 ->  Seq Scan on prt2_p1 t1_5
                                       Filter: (a = 0)
               ->  Index Scan using iprt1_p1_a on prt1_p1 t1_2
                     Index Cond: (a = ((t2_1.a + t2_1.b) / 2))
                     Filter: (b = 0)
         ->  Nested Loop
               Join Filter: (t1_3.a = t1_6.b)
               ->  HashAggregate
                     Group Key: t1_6.b
                     ->  Hash Join
                           Hash Cond: (((t2_2.a + t2_2.b) / 2) = t1_6.b)
                           ->  Seq Scan on prt1_e_p2 t2_2
                           ->  Hash
                                 ->  Seq Scan on prt2_p2 t1_6
                                       Filter: (a = 0)
               ->  Index Scan using iprt1_p2_a on prt1_p2 t1_3
                     Index Cond: (a = ((t2_2.a + t2_2.b) / 2))
                     Filter: (b = 0)
         ->  Nested Loop
               Join Filter: (t1_4.a = t1_7.b)
               ->  HashAggregate
                     Group Key: t1_7.b
                     ->  Nested Loop
                           ->  Seq Scan on prt2_p3 t1_7
                                 Filter: (a = 0)
                           ->  Index Scan using iprt1_e_p3_ab2 on prt1_e_p3 t2_3
                                 Index Cond: (((a + b) / 2) = t1_7.b)
               ->  Index Scan using iprt1_p3_a on prt1_p3 t1_4
                     Index Cond: (a = ((t2_3.a + t2_3.b) / 2))
                     Filter: (b = 0)
(41 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1, prt1_e t2 WHERE t1.a = 0 AND t1.b = (t2.a + t2.b)/2) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop
               ->  HashAggregate
                     Group Key: t1_6.b
                     ->  Hash Semi Join
                           Hash Cond: (t1_6.b = ((t1_9.a + t1_9.b) / 2))
                           ->  Seq Scan on prt2_p1 t1_6
                           ->  Hash
                                 ->  Seq Scan on prt1_e_p1 t1_9
                                       Filter: (c = 0)
               ->  Index Scan using iprt1_p1_a on prt1_p1 t1_3
                     Index Cond: (a = t1_6.b)
                     Filter: (b = 0)
         ->  Nested Loop
               ->  HashAggregate
                     Group Key: t1_7.b
                     ->  Hash Semi Join
                           Hash Cond: (t1_7.b = ((t1_10.a + t1_10.b) / 2))
                           ->  Seq Scan on prt2_p2 t1_7
                           ->  Hash
                                 ->  Seq Scan on prt1_e_p2 t1_10
                                       Filter: (c = 0)
               ->  Index Scan using iprt1_p2_a on prt1_p2 t1_4
                     Index Cond: (a = t1_7.b)
                     Filter: (b = 0)
         ->  Nested Loop
               ->  HashAggregate
                     Group Key: t1_8.b
                     ->  Hash Semi Join
                           Hash Cond: (t1_8.b = ((t1_11.a + t1_11.b) / 2))
                           ->  Seq Scan on prt2_p3 t1_8
                           ->  Hash
                                 ->  Seq Scan on prt1_e_p3 t1_11
                                       Filter: (c = 0)
               ->  Index Scan using iprt1_p3_a on prt1_p3 t1_5
                     Index Cond: (a = t1_8.b)
                     Filter: (b = 0)
(39 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

-- test merge joins
SET enable_hashjoin TO off;
SET enable_nestloop TO off;
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
                            QUERY PLAN                            
------------------------------------------------------------------
 Merge Append
   Sort Key: t1.a
   ->  Merge Semi Join
         Merge Cond: (t1_3.a = t1_6.b)
         ->  Sort
               Sort Key: t1_3.a
               ->  Seq Scan on prt1_p1 t1_3
                     Filter: (b = 0)
         ->  Merge Semi Join
               Merge Cond: (t1_6.b = (((t1_9.a + t1_9.b) / 2)))
               ->  Sort
                     Sort Key: t1_6.b
                     ->  Seq Scan on prt2_p1 t1_6
               ->  Sort
                     Sort Key: (((t1_9.a + t1_9.b) / 2))
                     ->  Seq Scan on prt1_e_p1 t1_9
                           Filter: (c = 0)
   ->  Merge Semi Join
         Merge Cond: (t1_4.a = t1_7.b)
         ->  Sort
               Sort Key: t1_4.a
               ->  Seq Scan on prt1_p2 t1_4
                     Filter: (b = 0)
         ->  Merge Semi Join
               Merge Cond: (t1_7.b = (((t1_10.a + t1_10.b) / 2)))
               ->  Sort
                     Sort Key: t1_7.b
                     ->  Seq Scan on prt2_p2 t1_7
               ->  Sort
                     Sort Key: (((t1_10.a + t1_10.b) / 2))
                     ->  Seq Scan on prt1_e_p2 t1_10
                           Filter: (c = 0)
   ->  Merge Semi Join
         Merge Cond: (t1_5.a = t1_8.b)
         ->  Sort
               Sort Key: t1_5.a
               ->  Seq Scan on prt1_p3 t1_5
                     Filter: (b = 0)
         ->  Merge Semi Join
               Merge Cond: (t1_8.b = (((t1_11.a + t1_11.b) / 2)))
               ->  Sort
                     Sort Key: t1_8.b
                     ->  Seq Scan on prt2_p3 t1_8
               ->  Sort
                     Sort Key: (((t1_11.a + t1_11.b) / 2))
                     ->  Seq Scan on prt1_e_p3 t1_11
                           Filter: (c = 0)
(47 rows)

SELECT t1.* FROM prt1 t1 WHERE t1.a IN (SELECT t1.b FROM prt2 t1 WHERE t1.b IN (SELECT (t1.a + t1.b)/2 FROM prt1_e t1 WHERE t1.c = 0)) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
   0 | 0 | 0000
 150 | 0 | 0150
 300 | 0 | 0300
 450 | 0 | 0450
(4 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b, ((t3.a + t3.b))
   ->  Append
         ->  Merge Left Join
               Merge Cond: (t1_1.a = t2_1.b)
               ->  Sort
                     Sort Key: t1_1.a
                     ->  Merge Left Join
                           Merge Cond: ((((t3_1.a + t3_1.b) / 2)) = t1_1.a)
                           ->  Sort
                                 Sort Key: (((t3_1.a + t3_1.b) / 2))
                                 ->  Seq Scan on prt1_e_p1 t3_1
                                       Filter: (c = 0)
                           ->  Sort
                                 Sort Key: t1_1.a
                                 ->  Seq Scan on prt1_p1 t1_1
               ->  Sort
                     Sort Key: t2_1.b
                     ->  Seq Scan on prt2_p1 t2_1
         ->  Merge Left Join
               Merge Cond: (t1_2.a = t2_2.b)
               ->  Sort
                     Sort Key: t1_2.a
                     ->  Merge Left Join
                           Merge Cond: ((((t3_2.a + t3_2.b) / 2)) = t1_2.a)
                           ->  Sort
                                 Sort Key: (((t3_2.a + t3_2.b) / 2))
                                 ->  Seq Scan on prt1_e_p2 t3_2
                                       Filter: (c = 0)
                           ->  Sort
                                 Sort Key: t1_2.a
                                 ->  Seq Scan on prt1_p2 t1_2
               ->  Sort
                     Sort Key: t2_2.b
                     ->  Seq Scan on prt2_p2 t2_2
         ->  Merge Left Join
               Merge Cond: (t1_3.a = t2_3.b)
               ->  Sort
                     Sort Key: t1_3.a
                     ->  Merge Left Join
                           Merge Cond: ((((t3_3.a + t3_3.b) / 2)) = t1_3.a)
                           ->  Sort
                                 Sort Key: (((t3_3.a + t3_3.b) / 2))
                                 ->  Seq Scan on prt1_e_p3 t3_3
                                       Filter: (c = 0)
                           ->  Sort
                                 Sort Key: t1_3.a
                                 ->  Seq Scan on prt1_p3 t1_3
               ->  Sort
                     Sort Key: t2_3.b
                     ->  Seq Scan on prt2_p3 t2_3
(51 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2 ON t1.a = t2.b) RIGHT JOIN prt1_e t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t3.c = 0 ORDER BY t1.a, t2.b, t3.a + t3.b;
  a  |  c   |  b  |  c   | ?column? | c 
-----+------+-----+------+----------+---
   0 | 0000 |   0 | 0000 |        0 | 0
  50 | 0050 |     |      |      100 | 0
 100 | 0100 |     |      |      200 | 0
 150 | 0150 | 150 | 0150 |      300 | 0
 200 | 0200 |     |      |      400 | 0
 250 | 0250 |     |      |      500 | 0
 300 | 0300 | 300 | 0300 |      600 | 0
 350 | 0350 |     |      |      700 | 0
 400 | 0400 |     |      |      800 | 0
 450 | 0450 | 450 | 0450 |      900 | 0
 500 | 0500 |     |      |     1000 | 0
 550 | 0550 |     |      |     1100 | 0
(12 rows)

-- MergeAppend on nullable column
-- This should generate a partitionwise join, but currently fails to
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                        QUERY PLAN                         
-----------------------------------------------------------
 Sort
   Sort Key: prt1.a, prt2.b
   ->  Merge Left Join
         Merge Cond: (prt1.a = prt2.b)
         ->  Sort
               Sort Key: prt1.a
               ->  Append
                     ->  Seq Scan on prt1_p1 prt1_1
                           Filter: ((a < 450) AND (b = 0))
                     ->  Seq Scan on prt1_p2 prt1_2
                           Filter: ((a < 450) AND (b = 0))
         ->  Sort
               Sort Key: prt2.b
               ->  Append
                     ->  Seq Scan on prt2_p2 prt2_1
                           Filter: (b > 250)
                     ->  Seq Scan on prt2_p3 prt2_2
                           Filter: (b > 250)
(18 rows)

SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  b  
-----+-----
   0 |    
  50 |    
 100 |    
 150 |    
 200 |    
 250 |    
 300 | 300
 350 |    
 400 |    
(9 rows)

-- merge join when expression with whole-row reference needs to be sorted;
-- partitionwise join does not apply
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Merge Join
   Merge Cond: ((t1.a = t2.b) AND (((((t1.*)::prt1))::text) = ((((t2.*)::prt2))::text)))
   ->  Sort
         Sort Key: t1.a, ((((t1.*)::prt1))::text)
         ->  Result
               ->  Append
                     ->  Seq Scan on prt1_p1 t1_1
                     ->  Seq Scan on prt1_p2 t1_2
                     ->  Seq Scan on prt1_p3 t1_3
   ->  Sort
         Sort Key: t2.b, ((((t2.*)::prt2))::text)
         ->  Result
               ->  Append
                     ->  Seq Scan on prt2_p1 t2_1
                     ->  Seq Scan on prt2_p2 t2_2
                     ->  Seq Scan on prt2_p3 t2_3
(16 rows)

SELECT t1.a, t2.b FROM prt1 t1, prt2 t2 WHERE t1::text = t2::text AND t1.a = t2.b ORDER BY t1.a;
 a  | b  
----+----
  0 |  0
  6 |  6
 12 | 12
 18 | 18
 24 | 24
(5 rows)

RESET enable_hashjoin;
RESET enable_nestloop;
--
-- partitioned by multiple columns
--
CREATE TABLE prt1_m (a int, b int, c int) PARTITION BY RANGE(a, ((a + b)/2));
CREATE TABLE prt1_m_p1 PARTITION OF prt1_m FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE prt1_m_p2 PARTITION OF prt1_m FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE prt1_m_p3 PARTITION OF prt1_m FOR VALUES FROM (500, 500) TO (600, 600);
INSERT INTO prt1_m SELECT i, i, i % 25 FROM generate_series(0, 599, 2) i;
ANALYZE prt1_m;
CREATE TABLE prt2_m (a int, b int, c int) PARTITION BY RANGE(((b + a)/2), b);
CREATE TABLE prt2_m_p1 PARTITION OF prt2_m FOR VALUES FROM (0, 0) TO (250, 250);
CREATE TABLE prt2_m_p2 PARTITION OF prt2_m FOR VALUES FROM (250, 250) TO (500, 500);
CREATE TABLE prt2_m_p3 PARTITION OF prt2_m FOR VALUES FROM (500, 500) TO (600, 600);
INSERT INTO prt2_m SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
ANALYZE prt2_m;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: prt1_m.a, prt2_m.b
   ->  Append
         ->  Hash Full Join
               Hash Cond: ((prt1_m_1.a = ((prt2_m_1.b + prt2_m_1.a) / 2)) AND (((prt1_m_1.a + prt1_m_1.b) / 2) = prt2_m_1.b))
               ->  Seq Scan on prt1_m_p1 prt1_m_1
                     Filter: (c = 0)
               ->  Hash
                     ->  Seq Scan on prt2_m_p1 prt2_m_1
                           Filter: (c = 0)
         ->  Hash Full Join
               Hash Cond: ((prt1_m_2.a = ((prt2_m_2.b + prt2_m_2.a) / 2)) AND (((prt1_m_2.a + prt1_m_2.b) / 2) = prt2_m_2.b))
               ->  Seq Scan on prt1_m_p2 prt1_m_2
                     Filter: (c = 0)
               ->  Hash
                     ->  Seq Scan on prt2_m_p2 prt2_m_2
                           Filter: (c = 0)
         ->  Hash Full Join
               Hash Cond: ((prt1_m_3.a = ((prt2_m_3.b + prt2_m_3.a) / 2)) AND (((prt1_m_3.a + prt1_m_3.b) / 2) = prt2_m_3.b))
               ->  Seq Scan on prt1_m_p3 prt1_m_3
                     Filter: (c = 0)
               ->  Hash
                     ->  Seq Scan on prt2_m_p3 prt2_m_3
                           Filter: (c = 0)
(24 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
  a  | c |  b  | c 
-----+---+-----+---
   0 | 0 |   0 | 0
  50 | 0 |     |  
 100 | 0 |     |  
 150 | 0 | 150 | 0
 200 | 0 |     |  
 250 | 0 |     |  
 300 | 0 | 300 | 0
 350 | 0 |     |  
 400 | 0 |     |  
 450 | 0 | 450 | 0
 500 | 0 |     |  
 550 | 0 |     |  
     |   |  75 | 0
     |   | 225 | 0
     |   | 375 | 0
     |   | 525 | 0
(16 rows)

--
-- tests for list partitioned tables.
--
CREATE TABLE plt1 (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE plt1_p1 PARTITION OF plt1 FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt1_p2 PARTITION OF plt1 FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt1_p3 PARTITION OF plt1 FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO plt1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE plt1;
CREATE TABLE plt2 (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE plt2_p1 PARTITION OF plt2 FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt2_p2 PARTITION OF plt2 FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt2_p3 PARTITION OF plt2 FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO plt2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 3) i;
ANALYZE plt2;
--
-- list partitioned by expression
--
CREATE TABLE plt1_e (a int, b int, c text) PARTITION BY LIST(ltrim(c, 'A'));
CREATE TABLE plt1_e_p1 PARTITION OF plt1_e FOR VALUES IN ('0000', '0003', '0004', '0010');
CREATE TABLE plt1_e_p2 PARTITION OF plt1_e FOR VALUES IN ('0001', '0005', '0002', '0009');
CREATE TABLE plt1_e_p3 PARTITION OF plt1_e FOR VALUES IN ('0006', '0007', '0008', '0011');
INSERT INTO plt1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE plt1_e;
-- test partition matching with N-way join
EXPLAIN (COSTS OFF)
SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM plt1 t1, plt2 t2, plt1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 GroupAggregate
   Group Key: t1.c, t2.c, t3.c
   ->  Sort
         Sort Key: t1.c, t3.c
         ->  Append
               ->  Hash Join
                     Hash Cond: (t1_1.c = ltrim(t3_1.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_1.b = t2_1.b) AND (t1_1.c = t2_1.c))
                           ->  Seq Scan on plt1_p1 t1_1
                           ->  Hash
                                 ->  Seq Scan on plt2_p1 t2_1
                     ->  Hash
                           ->  Seq Scan on plt1_e_p1 t3_1
               ->  Hash Join
                     Hash Cond: (t1_2.c = ltrim(t3_2.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_2.b = t2_2.b) AND (t1_2.c = t2_2.c))
                           ->  Seq Scan on plt1_p2 t1_2
                           ->  Hash
                                 ->  Seq Scan on plt2_p2 t2_2
                     ->  Hash
                           ->  Seq Scan on plt1_e_p2 t3_2
               ->  Hash Join
                     Hash Cond: (t1_3.c = ltrim(t3_3.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_3.b = t2_3.b) AND (t1_3.c = t2_3.c))
                           ->  Seq Scan on plt1_p3 t1_3
                           ->  Hash
                                 ->  Seq Scan on plt2_p3 t2_3
                     ->  Hash
                           ->  Seq Scan on plt1_e_p3 t3_3
(32 rows)

SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM plt1 t1, plt2 t2, plt1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
         avg          |         avg          |          avg          |  c   |  c   |   c   
----------------------+----------------------+-----------------------+------+------+-------
  24.0000000000000000 |  24.0000000000000000 |   48.0000000000000000 | 0000 | 0000 | A0000
  75.0000000000000000 |  75.0000000000000000 |  148.0000000000000000 | 0001 | 0001 | A0001
 123.0000000000000000 | 123.0000000000000000 |  248.0000000000000000 | 0002 | 0002 | A0002
 174.0000000000000000 | 174.0000000000000000 |  348.0000000000000000 | 0003 | 0003 | A0003
 225.0000000000000000 | 225.0000000000000000 |  448.0000000000000000 | 0004 | 0004 | A0004
 273.0000000000000000 | 273.0000000000000000 |  548.0000000000000000 | 0005 | 0005 | A0005
 324.0000000000000000 | 324.0000000000000000 |  648.0000000000000000 | 0006 | 0006 | A0006
 375.0000000000000000 | 375.0000000000000000 |  748.0000000000000000 | 0007 | 0007 | A0007
 423.0000000000000000 | 423.0000000000000000 |  848.0000000000000000 | 0008 | 0008 | A0008
 474.0000000000000000 | 474.0000000000000000 |  948.0000000000000000 | 0009 | 0009 | A0009
 525.0000000000000000 | 525.0000000000000000 | 1048.0000000000000000 | 0010 | 0010 | A0010
 573.0000000000000000 | 573.0000000000000000 | 1148.0000000000000000 | 0011 | 0011 | A0011
(12 rows)

-- joins where one of the relations is proven empty
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.a = 1 AND t1.a = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 LEFT JOIN prt2 t2 ON t1.a = t2.b;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b, prt1 t3 WHERE t2.b = t3.a;
                    QUERY PLAN                    
--------------------------------------------------
 Hash Left Join
   Hash Cond: (t2.b = a)
   ->  Append
         ->  Hash Join
               Hash Cond: (t3_1.a = t2_1.b)
               ->  Seq Scan on prt1_p1 t3_1
               ->  Hash
                     ->  Seq Scan on prt2_p1 t2_1
         ->  Hash Join
               Hash Cond: (t3_2.a = t2_2.b)
               ->  Seq Scan on prt1_p2 t3_2
               ->  Hash
                     ->  Seq Scan on prt2_p2 t2_2
         ->  Hash Join
               Hash Cond: (t3_3.a = t2_3.b)
               ->  Seq Scan on prt1_p3 t3_3
               ->  Hash
                     ->  Seq Scan on prt2_p3 t2_3
   ->  Hash
         ->  Result
               One-Time Filter: false
(21 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a = 1 AND a = 2) t1 FULL JOIN prt2 t2 ON t1.a = t2.b WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                 QUERY PLAN                 
--------------------------------------------
 Sort
   Sort Key: a, t2.b
   ->  Hash Left Join
         Hash Cond: (t2.b = a)
         ->  Append
               ->  Seq Scan on prt2_p1 t2_1
                     Filter: (a = 0)
               ->  Seq Scan on prt2_p2 t2_2
                     Filter: (a = 0)
               ->  Seq Scan on prt2_p3 t2_3
                     Filter: (a = 0)
         ->  Hash
               ->  Result
                     One-Time Filter: false
(14 rows)

--
-- tests for hash partitioned tables.
--
CREATE TABLE pht1 (a int, b int, c text) PARTITION BY HASH(c);
CREATE TABLE pht1_p1 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht1_p2 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht1_p3 PARTITION OF pht1 FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO pht1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE pht1;
CREATE TABLE pht2 (a int, b int, c text) PARTITION BY HASH(c);
CREATE TABLE pht2_p1 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht2_p2 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht2_p3 PARTITION OF pht2 FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO pht2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 3) i;
ANALYZE pht2;
--
-- hash partitioned by expression
--
CREATE TABLE pht1_e (a int, b int, c text) PARTITION BY HASH(ltrim(c, 'A'));
CREATE TABLE pht1_e_p1 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 0);
CREATE TABLE pht1_e_p2 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 1);
CREATE TABLE pht1_e_p3 PARTITION OF pht1_e FOR VALUES WITH (MODULUS 3, REMAINDER 2);
INSERT INTO pht1_e SELECT i, i, 'A' || to_char(i/50, 'FM0000') FROM generate_series(0, 299, 2) i;
ANALYZE pht1_e;
-- test partition matching with N-way join
EXPLAIN (COSTS OFF)
SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM pht1 t1, pht2 t2, pht1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 GroupAggregate
   Group Key: t1.c, t2.c, t3.c
   ->  Sort
         Sort Key: t1.c, t3.c
         ->  Append
               ->  Hash Join
                     Hash Cond: (t1_1.c = ltrim(t3_1.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_1.b = t2_1.b) AND (t1_1.c = t2_1.c))
                           ->  Seq Scan on pht1_p1 t1_1
                           ->  Hash
                                 ->  Seq Scan on pht2_p1 t2_1
                     ->  Hash
                           ->  Seq Scan on pht1_e_p1 t3_1
               ->  Hash Join
                     Hash Cond: (t1_2.c = ltrim(t3_2.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_2.b = t2_2.b) AND (t1_2.c = t2_2.c))
                           ->  Seq Scan on pht1_p2 t1_2
                           ->  Hash
                                 ->  Seq Scan on pht2_p2 t2_2
                     ->  Hash
                           ->  Seq Scan on pht1_e_p2 t3_2
               ->  Hash Join
                     Hash Cond: (t1_3.c = ltrim(t3_3.c, 'A'::text))
                     ->  Hash Join
                           Hash Cond: ((t1_3.b = t2_3.b) AND (t1_3.c = t2_3.c))
                           ->  Seq Scan on pht1_p3 t1_3
                           ->  Hash
                                 ->  Seq Scan on pht2_p3 t2_3
                     ->  Hash
                           ->  Seq Scan on pht1_e_p3 t3_3
(32 rows)

SELECT avg(t1.a), avg(t2.b), avg(t3.a + t3.b), t1.c, t2.c, t3.c FROM pht1 t1, pht2 t2, pht1_e t3 WHERE t1.b = t2.b AND t1.c = t2.c AND ltrim(t3.c, 'A') = t1.c GROUP BY t1.c, t2.c, t3.c ORDER BY t1.c, t2.c, t3.c;
         avg          |         avg          |         avg          |  c   |  c   |   c   
----------------------+----------------------+----------------------+------+------+-------
  24.0000000000000000 |  24.0000000000000000 |  48.0000000000000000 | 0000 | 0000 | A0000
  75.0000000000000000 |  75.0000000000000000 | 148.0000000000000000 | 0001 | 0001 | A0001
 123.0000000000000000 | 123.0000000000000000 | 248.0000000000000000 | 0002 | 0002 | A0002
 174.0000000000000000 | 174.0000000000000000 | 348.0000000000000000 | 0003 | 0003 | A0003
 225.0000000000000000 | 225.0000000000000000 | 448.0000000000000000 | 0004 | 0004 | A0004
 273.0000000000000000 | 273.0000000000000000 | 548.0000000000000000 | 0005 | 0005 | A0005
(6 rows)

-- test default partition behavior for range
ALTER TABLE prt1 DETACH PARTITION prt1_p3;
ALTER TABLE prt1 ATTACH PARTITION prt1_p3 DEFAULT;
ANALYZE prt1;
ALTER TABLE prt2 DETACH PARTITION prt2_p3;
ALTER TABLE prt2 ATTACH PARTITION prt2_p3 DEFAULT;
ANALYZE prt2;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt2 t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_p3 t1_3
                           Filter: (b = 0)
(21 rows)

-- test default partition behavior for list
ALTER TABLE plt1 DETACH PARTITION plt1_p3;
ALTER TABLE plt1 ATTACH PARTITION plt1_p3 DEFAULT;
ANALYZE plt1;
ALTER TABLE plt2 DETACH PARTITION plt2_p3;
ALTER TABLE plt2 ATTACH PARTITION plt2_p3 DEFAULT;
ANALYZE plt2;
EXPLAIN (COSTS OFF)
SELECT avg(t1.a), avg(t2.b), t1.c, t2.c FROM plt1 t1 RIGHT JOIN plt2 t2 ON t1.c = t2.c WHERE t1.a % 25 = 0 GROUP BY t1.c, t2.c ORDER BY t1.c, t2.c;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: t1.c
   ->  HashAggregate
         Group Key: t1.c, t2.c
         ->  Append
               ->  Hash Join
                     Hash Cond: (t2_1.c = t1_1.c)
                     ->  Seq Scan on plt2_p1 t2_1
                     ->  Hash
                           ->  Seq Scan on plt1_p1 t1_1
                                 Filter: ((a % 25) = 0)
               ->  Hash Join
                     Hash Cond: (t2_2.c = t1_2.c)
                     ->  Seq Scan on plt2_p2 t2_2
                     ->  Hash
                           ->  Seq Scan on plt1_p2 t1_2
                                 Filter: ((a % 25) = 0)
               ->  Hash Join
                     Hash Cond: (t2_3.c = t1_3.c)
                     ->  Seq Scan on plt2_p3 t2_3
                     ->  Hash
                           ->  Seq Scan on plt1_p3 t1_3
                                 Filter: ((a % 25) = 0)
(23 rows)

--
-- multiple levels of partitioning
--
CREATE TABLE prt1_l (a int, b int, c varchar) PARTITION BY RANGE(a);
CREATE TABLE prt1_l_p1 PARTITION OF prt1_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt1_l_p2 PARTITION OF prt1_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt1_l_p2_p1 PARTITION OF prt1_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt1_l_p2_p2 PARTITION OF prt1_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt1_l_p3 PARTITION OF prt1_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (b);
CREATE TABLE prt1_l_p3_p1 PARTITION OF prt1_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt1_l_p3_p2 PARTITION OF prt1_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt1_l SELECT i, i % 25, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE prt1_l;
CREATE TABLE prt2_l (a int, b int, c varchar) PARTITION BY RANGE(b);
CREATE TABLE prt2_l_p1 PARTITION OF prt2_l FOR VALUES FROM (0) TO (250);
CREATE TABLE prt2_l_p2 PARTITION OF prt2_l FOR VALUES FROM (250) TO (500) PARTITION BY LIST (c);
CREATE TABLE prt2_l_p2_p1 PARTITION OF prt2_l_p2 FOR VALUES IN ('0000', '0001');
CREATE TABLE prt2_l_p2_p2 PARTITION OF prt2_l_p2 FOR VALUES IN ('0002', '0003');
CREATE TABLE prt2_l_p3 PARTITION OF prt2_l FOR VALUES FROM (500) TO (600) PARTITION BY RANGE (a);
CREATE TABLE prt2_l_p3_p1 PARTITION OF prt2_l_p3 FOR VALUES FROM (0) TO (13);
CREATE TABLE prt2_l_p3_p2 PARTITION OF prt2_l_p3 FOR VALUES FROM (13) TO (25);
INSERT INTO prt2_l SELECT i % 25, i, to_char(i % 4, 'FM0000') FROM generate_series(0, 599, 3) i;
ANALYZE prt2_l;
-- inner join, qual covering only top-level partitions
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
                         QUERY PLAN                          
-------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_l_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_l_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Append
                     ->  Seq Scan on prt2_l_p2_p1 t2_3
                     ->  Seq Scan on prt2_l_p2_p2 t2_4
               ->  Hash
                     ->  Append
                           ->  Seq Scan on prt1_l_p2_p1 t1_3
                                 Filter: (b = 0)
                           ->  Seq Scan on prt1_l_p2_p2 t1_4
                                 Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_6.b = t1_5.a)
               ->  Append
                     ->  Seq Scan on prt2_l_p3_p1 t2_6
                     ->  Seq Scan on prt2_l_p3_p2 t2_7
               ->  Hash
                     ->  Seq Scan on prt1_l_p3_p1 t1_5
                           Filter: (b = 0)
(28 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1, prt2_l t2 WHERE t1.a = t2.b AND t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0002 | 150 | 0002
 300 | 0000 | 300 | 0000
 450 | 0002 | 450 | 0002
(4 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 LEFT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t2_1.b = t1_1.a) AND ((t2_1.c)::text = (t1_1.c)::text))
               ->  Seq Scan on prt2_l_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_l_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: ((t2_2.b = t1_2.a) AND ((t2_2.c)::text = (t1_2.c)::text))
               ->  Seq Scan on prt2_l_p2_p1 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_l_p2_p1 t1_2
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: ((t2_3.b = t1_3.a) AND ((t2_3.c)::text = (t1_3.c)::text))
               ->  Seq Scan on prt2_l_p2_p2 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_l_p2_p2 t1_3
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: ((t2_5.b = t1_4.a) AND ((t2_5.c)::text = (t1_4.c)::text))
               ->  Append
                     ->  Seq Scan on prt2_l_p3_p1 t2_5
                     ->  Seq Scan on prt2_l_p3_p2 t2_6
               ->  Hash
                     ->  Seq Scan on prt1_l_p3_p1 t1_4
                           Filter: (b = 0)
(29 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 LEFT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
  50 | 0002 |     | 
 100 | 0000 |     | 
 150 | 0002 | 150 | 0002
 200 | 0000 |     | 
 250 | 0002 |     | 
 300 | 0000 | 300 | 0000
 350 | 0002 |     | 
 400 | 0000 |     | 
 450 | 0002 | 450 | 0002
 500 | 0000 |     | 
 550 | 0002 |     | 
(12 rows)

-- right join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t2.a = 0 ORDER BY t1.a, t2.b;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t1_1.a = t2_1.b) AND ((t1_1.c)::text = (t2_1.c)::text))
               ->  Seq Scan on prt1_l_p1 t1_1
               ->  Hash
                     ->  Seq Scan on prt2_l_p1 t2_1
                           Filter: (a = 0)
         ->  Hash Right Join
               Hash Cond: ((t1_2.a = t2_2.b) AND ((t1_2.c)::text = (t2_2.c)::text))
               ->  Seq Scan on prt1_l_p2_p1 t1_2
               ->  Hash
                     ->  Seq Scan on prt2_l_p2_p1 t2_2
                           Filter: (a = 0)
         ->  Hash Right Join
               Hash Cond: ((t1_3.a = t2_3.b) AND ((t1_3.c)::text = (t2_3.c)::text))
               ->  Seq Scan on prt1_l_p2_p2 t1_3
               ->  Hash
                     ->  Seq Scan on prt2_l_p2_p2 t2_3
                           Filter: (a = 0)
         ->  Hash Right Join
               Hash Cond: ((t1_5.a = t2_4.b) AND ((t1_5.c)::text = (t2_4.c)::text))
               ->  Append
                     ->  Seq Scan on prt1_l_p3_p1 t1_5
                     ->  Seq Scan on prt1_l_p3_p2 t1_6
               ->  Hash
                     ->  Seq Scan on prt2_l_p3_p1 t2_4
                           Filter: (a = 0)
(29 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.c = t2.c WHERE t2.a = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
 150 | 0002 | 150 | 0002
 300 | 0000 | 300 | 0000
 450 | 0002 | 450 | 0002
     |      |  75 | 0003
     |      | 225 | 0001
     |      | 375 | 0003
     |      | 525 | 0001
(8 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort
   Sort Key: prt1_l.a, prt2_l.b
   ->  Append
         ->  Hash Full Join
               Hash Cond: ((prt1_l_1.a = prt2_l_1.b) AND ((prt1_l_1.c)::text = (prt2_l_1.c)::text))
               ->  Seq Scan on prt1_l_p1 prt1_l_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_l_p1 prt2_l_1
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: ((prt1_l_2.a = prt2_l_2.b) AND ((prt1_l_2.c)::text = (prt2_l_2.c)::text))
               ->  Seq Scan on prt1_l_p2_p1 prt1_l_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_l_p2_p1 prt2_l_2
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: ((prt1_l_3.a = prt2_l_3.b) AND ((prt1_l_3.c)::text = (prt2_l_3.c)::text))
               ->  Seq Scan on prt1_l_p2_p2 prt1_l_3
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_l_p2_p2 prt2_l_3
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: ((prt1_l_4.a = prt2_l_4.b) AND ((prt1_l_4.c)::text = (prt2_l_4.c)::text))
               ->  Seq Scan on prt1_l_p3_p1 prt1_l_4
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_l_p3_p1 prt2_l_4
                           Filter: (a = 0)
(31 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
   0 | 0000 |   0 | 0000
  50 | 0002 |     | 
 100 | 0000 |     | 
 150 | 0002 | 150 | 0002
 200 | 0000 |     | 
 250 | 0002 |     | 
 300 | 0000 | 300 | 0000
 350 | 0002 |     | 
 400 | 0000 |     | 
 450 | 0002 | 450 | 0002
 500 | 0000 |     | 
 550 | 0002 |     | 
     |      |  75 | 0003
     |      | 225 | 0001
     |      | 375 | 0003
     |      | 525 | 0001
(16 rows)

-- lateral partitionwise join
EXPLAIN (COSTS OFF)
SELECT * FROM prt1_l t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss
			  ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_l_p1 t1_1
                     Filter: (b = 0)
               ->  Hash Join
                     Hash Cond: ((t3_1.b = t2_1.a) AND ((t3_1.c)::text = (t2_1.c)::text))
                     ->  Seq Scan on prt2_l_p1 t3_1
                     ->  Hash
                           ->  Seq Scan on prt1_l_p1 t2_1
                                 Filter: ((t1_1.a = a) AND ((t1_1.c)::text = (c)::text))
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_l_p2_p1 t1_2
                     Filter: (b = 0)
               ->  Hash Join
                     Hash Cond: ((t3_2.b = t2_2.a) AND ((t3_2.c)::text = (t2_2.c)::text))
                     ->  Seq Scan on prt2_l_p2_p1 t3_2
                     ->  Hash
                           ->  Seq Scan on prt1_l_p2_p1 t2_2
                                 Filter: ((t1_2.a = a) AND ((t1_2.c)::text = (c)::text))
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_l_p2_p2 t1_3
                     Filter: (b = 0)
               ->  Hash Join
                     Hash Cond: ((t3_3.b = t2_3.a) AND ((t3_3.c)::text = (t2_3.c)::text))
                     ->  Seq Scan on prt2_l_p2_p2 t3_3
                     ->  Hash
                           ->  Seq Scan on prt1_l_p2_p2 t2_3
                                 Filter: ((t1_3.a = a) AND ((t1_3.c)::text = (c)::text))
         ->  Nested Loop Left Join
               ->  Seq Scan on prt1_l_p3_p1 t1_4
                     Filter: (b = 0)
               ->  Hash Join
                     Hash Cond: ((t3_5.b = t2_5.a) AND ((t3_5.c)::text = (t2_5.c)::text))
                     ->  Append
                           ->  Seq Scan on prt2_l_p3_p1 t3_5
                           ->  Seq Scan on prt2_l_p3_p2 t3_6
                     ->  Hash
                           ->  Append
                                 ->  Seq Scan on prt1_l_p3_p1 t2_5
                                       Filter: ((t1_4.a = a) AND ((t1_4.c)::text = (c)::text))
                                 ->  Seq Scan on prt1_l_p3_p2 t2_6
                                       Filter: ((t1_4.a = a) AND ((t1_4.c)::text = (c)::text))
(44 rows)

SELECT * FROM prt1_l t1 LEFT JOIN LATERAL
			  (SELECT t2.a AS t2a, t2.c AS t2c, t2.b AS t2b, t3.b AS t3b, least(t1.a,t2.a,t3.b) FROM prt1_l t2 JOIN prt2_l t3 ON (t2.a = t3.b AND t2.c = t3.c)) ss
			  ON t1.a = ss.t2a AND t1.c = ss.t2c WHERE t1.b = 0 ORDER BY t1.a;
  a  | b |  c   | t2a | t2c  | t2b | t3b | least 
-----+---+------+-----+------+-----+-----+-------
   0 | 0 | 0000 |   0 | 0000 |   0 |   0 |     0
  50 | 0 | 0002 |     |      |     |     |      
 100 | 0 | 0000 |     |      |     |     |      
 150 | 0 | 0002 | 150 | 0002 |   0 | 150 |   150
 200 | 0 | 0000 |     |      |     |     |      
 250 | 0 | 0002 |     |      |     |     |      
 300 | 0 | 0000 | 300 | 0000 |   0 | 300 |   300
 350 | 0 | 0002 |     |      |     |     |      
 400 | 0 | 0000 |     |      |     |     |      
 450 | 0 | 0002 | 450 | 0002 |   0 | 450 |   450
 500 | 0 | 0000 |     |      |     |     |      
 550 | 0 | 0002 |     |      |     |     |      
(12 rows)

-- join with one side empty
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE a = 1 AND a = 2) t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b AND t1.b = t2.a AND t1.c = t2.c;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Hash Left Join
   Hash Cond: ((t2.b = a) AND (t2.a = b) AND ((t2.c)::text = (c)::text))
   ->  Append
         ->  Seq Scan on prt2_l_p1 t2_1
         ->  Seq Scan on prt2_l_p2_p1 t2_2
         ->  Seq Scan on prt2_l_p2_p2 t2_3
         ->  Seq Scan on prt2_l_p3_p1 t2_4
         ->  Seq Scan on prt2_l_p3_p2 t2_5
   ->  Hash
         ->  Result
               One-Time Filter: false
(11 rows)

-- Test case to verify proper handling of subqueries in a partitioned delete.
-- The weird-looking lateral join is just there to force creation of a
-- nestloop parameter within the subquery, which exposes the problem if the
-- planner fails to make multiple copies of the subquery as appropriate.
EXPLAIN (COSTS OFF)
DELETE FROM prt1_l
WHERE EXISTS (
  SELECT 1
    FROM int4_tbl,
         LATERAL (SELECT int4_tbl.f1 FROM int8_tbl LIMIT 2) ss
    WHERE prt1_l.c IS NULL);
                          QUERY PLAN                           
---------------------------------------------------------------
 Delete on prt1_l
   Delete on prt1_l_p1 prt1_l_1
   Delete on prt1_l_p3_p1 prt1_l_2
   Delete on prt1_l_p3_p2 prt1_l_3
   ->  Nested Loop Semi Join
         ->  Seq Scan on prt1_l_p1 prt1_l_1
               Filter: (c IS NULL)
         ->  Nested Loop
               ->  Seq Scan on int4_tbl
               ->  Subquery Scan on ss
                     ->  Limit
                           ->  Seq Scan on int8_tbl
   ->  Nested Loop Semi Join
         ->  Seq Scan on prt1_l_p3_p1 prt1_l_2
               Filter: (c IS NULL)
         ->  Nested Loop
               ->  Seq Scan on int4_tbl
               ->  Subquery Scan on ss_1
                     ->  Limit
                           ->  Seq Scan on int8_tbl int8_tbl_1
   ->  Nested Loop Semi Join
         ->  Seq Scan on prt1_l_p3_p2 prt1_l_3
               Filter: (c IS NULL)
         ->  Nested Loop
               ->  Seq Scan on int4_tbl
               ->  Subquery Scan on ss_2
                     ->  Limit
                           ->  Seq Scan on int8_tbl int8_tbl_2
(28 rows)

--
-- negative testcases
--
CREATE TABLE prt1_n (a int, b int, c varchar) PARTITION BY RANGE(c);
CREATE TABLE prt1_n_p1 PARTITION OF prt1_n FOR VALUES FROM ('0000') TO ('0250');
CREATE TABLE prt1_n_p2 PARTITION OF prt1_n FOR VALUES FROM ('0250') TO ('0500');
INSERT INTO prt1_n SELECT i, i, to_char(i, 'FM0000') FROM generate_series(0, 499, 2) i;
ANALYZE prt1_n;
CREATE TABLE prt2_n (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE prt2_n_p1 PARTITION OF prt2_n FOR VALUES IN ('0000', '0003', '0004', '0010', '0006', '0007');
CREATE TABLE prt2_n_p2 PARTITION OF prt2_n FOR VALUES IN ('0001', '0005', '0002', '0009', '0008', '0011');
INSERT INTO prt2_n SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE prt2_n;
CREATE TABLE prt3_n (a int, b int, c text) PARTITION BY LIST(c);
CREATE TABLE prt3_n_p1 PARTITION OF prt3_n FOR VALUES IN ('0000', '0004', '0006', '0007');
CREATE TABLE prt3_n_p2 PARTITION OF prt3_n FOR VALUES IN ('0001', '0002', '0008', '0010');
CREATE TABLE prt3_n_p3 PARTITION OF prt3_n FOR VALUES IN ('0003', '0005', '0009', '0011');
INSERT INTO prt2_n SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE prt3_n;
CREATE TABLE prt4_n (a int, b int, c text) PARTITION BY RANGE(a);
CREATE TABLE prt4_n_p1 PARTITION OF prt4_n FOR VALUES FROM (0) TO (300);
CREATE TABLE prt4_n_p2 PARTITION OF prt4_n FOR VALUES FROM (300) TO (500);
CREATE TABLE prt4_n_p3 PARTITION OF prt4_n FOR VALUES FROM (500) TO (600);
INSERT INTO prt4_n SELECT i, i, to_char(i, 'FM0000') FROM generate_series(0, 599, 2) i;
ANALYZE prt4_n;
-- partitionwise join can not be applied if the partition ranges differ
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2 WHERE t1.a = t2.a;
                  QUERY PLAN                  
----------------------------------------------
 Hash Join
   Hash Cond: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on prt1_p1 t1_1
         ->  Seq Scan on prt1_p2 t1_2
         ->  Seq Scan on prt1_p3 t1_3
   ->  Hash
         ->  Append
               ->  Seq Scan on prt4_n_p1 t2_1
               ->  Seq Scan on prt4_n_p2 t2_2
               ->  Seq Scan on prt4_n_p3 t2_3
(11 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1, prt4_n t2, prt2 t3 WHERE t1.a = t2.a and t1.a = t3.b;
                       QUERY PLAN                       
--------------------------------------------------------
 Hash Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on prt4_n_p1 t2_1
         ->  Seq Scan on prt4_n_p2 t2_2
         ->  Seq Scan on prt4_n_p3 t2_3
   ->  Hash
         ->  Append
               ->  Hash Join
                     Hash Cond: (t1_1.a = t3_1.b)
                     ->  Seq Scan on prt1_p1 t1_1
                     ->  Hash
                           ->  Seq Scan on prt2_p1 t3_1
               ->  Hash Join
                     Hash Cond: (t1_2.a = t3_2.b)
                     ->  Seq Scan on prt1_p2 t1_2
                     ->  Hash
                           ->  Seq Scan on prt2_p2 t3_2
               ->  Hash Join
                     Hash Cond: (t1_3.a = t3_3.b)
                     ->  Seq Scan on prt1_p3 t1_3
                     ->  Hash
                           ->  Seq Scan on prt2_p3 t3_3
(23 rows)

-- partitionwise join can not be applied if there are no equi-join conditions
-- between partition keys
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 LEFT JOIN prt2 t2 ON (t1.a < t2.b);
                       QUERY PLAN                        
---------------------------------------------------------
 Nested Loop Left Join
   ->  Append
         ->  Seq Scan on prt1_p1 t1_1
         ->  Seq Scan on prt1_p2 t1_2
         ->  Seq Scan on prt1_p3 t1_3
   ->  Append
         ->  Index Scan using iprt2_p1_b on prt2_p1 t2_1
               Index Cond: (b > t1.a)
         ->  Index Scan using iprt2_p2_b on prt2_p2 t2_2
               Index Cond: (b > t1.a)
         ->  Index Scan using iprt2_p3_b on prt2_p3 t2_3
               Index Cond: (b > t1.a)
(12 rows)

-- equi-join with join condition on partial keys does not qualify for
-- partitionwise join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1, prt2_m t2 WHERE t1.a = (t2.b + t2.a)/2;
                  QUERY PLAN                  
----------------------------------------------
 Hash Join
   Hash Cond: (((t2.b + t2.a) / 2) = t1.a)
   ->  Append
         ->  Seq Scan on prt2_m_p1 t2_1
         ->  Seq Scan on prt2_m_p2 t2_2
         ->  Seq Scan on prt2_m_p3 t2_3
   ->  Hash
         ->  Append
               ->  Seq Scan on prt1_m_p1 t1_1
               ->  Seq Scan on prt1_m_p2 t1_2
               ->  Seq Scan on prt1_m_p3 t1_3
(11 rows)

-- equi-join between out-of-order partition key columns does not qualify for
-- partitionwise join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.a = t2.b;
                  QUERY PLAN                  
----------------------------------------------
 Hash Left Join
   Hash Cond: (t1.a = t2.b)
   ->  Append
         ->  Seq Scan on prt1_m_p1 t1_1
         ->  Seq Scan on prt1_m_p2 t1_2
         ->  Seq Scan on prt1_m_p3 t1_3
   ->  Hash
         ->  Append
               ->  Seq Scan on prt2_m_p1 t2_1
               ->  Seq Scan on prt2_m_p2 t2_2
               ->  Seq Scan on prt2_m_p3 t2_3
(11 rows)

-- equi-join between non-key columns does not qualify for partitionwise join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_m t1 LEFT JOIN prt2_m t2 ON t1.c = t2.c;
                  QUERY PLAN                  
----------------------------------------------
 Hash Left Join
   Hash Cond: (t1.c = t2.c)
   ->  Append
         ->  Seq Scan on prt1_m_p1 t1_1
         ->  Seq Scan on prt1_m_p2 t1_2
         ->  Seq Scan on prt1_m_p3 t1_3
   ->  Hash
         ->  Append
               ->  Seq Scan on prt2_m_p1 t2_1
               ->  Seq Scan on prt2_m_p2 t2_2
               ->  Seq Scan on prt2_m_p3 t2_3
(11 rows)

-- partitionwise join can not be applied for a join between list and range
-- partitioned tables
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 LEFT JOIN prt2_n t2 ON (t1.c = t2.c);
                  QUERY PLAN                  
----------------------------------------------
 Hash Right Join
   Hash Cond: (t2.c = (t1.c)::text)
   ->  Append
         ->  Seq Scan on prt2_n_p1 t2_1
         ->  Seq Scan on prt2_n_p2 t2_2
   ->  Hash
         ->  Append
               ->  Seq Scan on prt1_n_p1 t1_1
               ->  Seq Scan on prt1_n_p2 t1_2
(9 rows)

-- partitionwise join can not be applied between tables with different
-- partition lists
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 JOIN prt2_n t2 ON (t1.c = t2.c) JOIN plt1 t3 ON (t1.c = t3.c);
                        QUERY PLAN                        
----------------------------------------------------------
 Hash Join
   Hash Cond: (t2.c = (t1.c)::text)
   ->  Append
         ->  Seq Scan on prt2_n_p1 t2_1
         ->  Seq Scan on prt2_n_p2 t2_2
   ->  Hash
         ->  Hash Join
               Hash Cond: (t3.c = (t1.c)::text)
               ->  Append
                     ->  Seq Scan on plt1_p1 t3_1
                     ->  Seq Scan on plt1_p2 t3_2
                     ->  Seq Scan on plt1_p3 t3_3
               ->  Hash
                     ->  Append
                           ->  Seq Scan on prt1_n_p1 t1_1
                           ->  Seq Scan on prt1_n_p2 t1_2
(16 rows)

-- partitionwise join can not be applied for a join between key column and
-- non-key column
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_n t1 FULL JOIN prt1 t2 ON (t1.c = t2.c);
                  QUERY PLAN                  
----------------------------------------------
 Hash Full Join
   Hash Cond: ((t2.c)::text = (t1.c)::text)
   ->  Append
         ->  Seq Scan on prt1_p1 t2_1
         ->  Seq Scan on prt1_p2 t2_2
         ->  Seq Scan on prt1_p3 t2_3
   ->  Hash
         ->  Append
               ->  Seq Scan on prt1_n_p1 t1_1
               ->  Seq Scan on prt1_n_p2 t1_2
(10 rows)

--
-- Test advanced partition-matching algorithm for partitioned join
--
-- Tests for range-partitioned tables
CREATE TABLE prt1_ad (a int, b int, c varchar) PARTITION BY RANGE (a);
CREATE TABLE prt1_ad_p1 PARTITION OF prt1_ad FOR VALUES FROM (100) TO (200);
CREATE TABLE prt1_ad_p2 PARTITION OF prt1_ad FOR VALUES FROM (200) TO (300);
CREATE TABLE prt1_ad_p3 PARTITION OF prt1_ad FOR VALUES FROM (300) TO (400);
CREATE INDEX prt1_ad_a_idx on prt1_ad (a);
INSERT INTO prt1_ad SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(100, 399) i;
ANALYZE prt1_ad;
CREATE TABLE prt2_ad (a int, b int, c varchar) PARTITION BY RANGE (b);
CREATE TABLE prt2_ad_p1 PARTITION OF prt2_ad FOR VALUES FROM (100) TO (150);
CREATE TABLE prt2_ad_p2 PARTITION OF prt2_ad FOR VALUES FROM (200) TO (300);
CREATE TABLE prt2_ad_p3 PARTITION OF prt2_ad FOR VALUES FROM (350) TO (500);
CREATE INDEX prt2_ad_b_idx on prt2_ad (b);
INSERT INTO prt2_ad_p1 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(100, 149) i;
INSERT INTO prt2_ad_p2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(200, 299) i;
INSERT INTO prt2_ad_p3 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(350, 499) i;
ANALYZE prt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 100 | 0100 | 100 | 0100
 125 | 0125 | 125 | 0125
 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275
 350 | 0350 | 350 | 0350
 375 | 0375 | 375 | 0375
(8 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Semi Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Seq Scan on prt1_ad_p1 t1_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p1 t2_1
         ->  Hash Semi Join
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Seq Scan on prt1_ad_p2 t1_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p2 t2_2
         ->  Hash Semi Join
               Hash Cond: (t1_3.a = t2_3.b)
               ->  Seq Scan on prt1_ad_p3 t1_3
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p3 t2_3
(21 rows)

SELECT t1.* FROM prt1_ad t1 WHERE EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
 100 | 0 | 0100
 125 | 0 | 0125
 200 | 0 | 0200
 225 | 0 | 0225
 250 | 0 | 0250
 275 | 0 | 0275
 350 | 0 | 0350
 375 | 0 | 0375
(8 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Right Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 100 | 0100 | 100 | 0100
 125 | 0125 | 125 | 0125
 150 | 0150 |     | 
 175 | 0175 |     | 
 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275
 300 | 0300 |     | 
 325 | 0325 |     | 
 350 | 0350 | 350 | 0350
 375 | 0375 | 375 | 0375
(12 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0;
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Hash Anti Join
         Hash Cond: (t1_1.a = t2_1.b)
         ->  Seq Scan on prt1_ad_p1 t1_1
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p1 t2_1
   ->  Hash Anti Join
         Hash Cond: (t1_2.a = t2_2.b)
         ->  Seq Scan on prt1_ad_p2 t1_2
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p2 t2_2
   ->  Hash Anti Join
         Hash Cond: (t1_3.a = t2_3.b)
         ->  Seq Scan on prt1_ad_p3 t1_3
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p3 t2_3
(19 rows)

SELECT t1.* FROM prt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0;
  a  | b |  c   
-----+---+------
 150 | 0 | 0150
 175 | 0 | 0175
 300 | 0 | 0300
 325 | 0 | 0325
(4 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_ad WHERE prt1_ad.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_ad WHERE prt2_ad.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Sort Key: prt1_ad.a, prt2_ad.b
   ->  Append
         ->  Hash Full Join
               Hash Cond: (prt1_ad_1.a = prt2_ad_1.b)
               Filter: (((175) = prt1_ad_1.a) OR ((425) = prt2_ad_1.b))
               ->  Seq Scan on prt1_ad_p1 prt1_ad_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p1 prt2_ad_1
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: (prt1_ad_2.a = prt2_ad_2.b)
               Filter: (((175) = prt1_ad_2.a) OR ((425) = prt2_ad_2.b))
               ->  Seq Scan on prt1_ad_p2 prt1_ad_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p2 prt2_ad_2
                           Filter: (a = 0)
         ->  Hash Full Join
               Hash Cond: (prt2_ad_3.b = prt1_ad_3.a)
               Filter: (((175) = prt1_ad_3.a) OR ((425) = prt2_ad_3.b))
               ->  Seq Scan on prt2_ad_p3 prt2_ad_3
                     Filter: (a = 0)
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 prt1_ad_3
                           Filter: (b = 0)
(27 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_ad WHERE prt1_ad.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_ad WHERE prt2_ad.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 175 | 0175 |     | 
     |      | 425 | 0425
(2 rows)

-- Test cases where one side has an extra partition
-- Add an extra partition to prt2_ad
CREATE TABLE prt2_ad_extra PARTITION OF prt2_ad FOR VALUES FROM (500) TO (MAXVALUE);
INSERT INTO prt2_ad SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(500, 599) i;
ANALYZE prt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 100 | 0100 | 100 | 0100
 125 | 0125 | 125 | 0125
 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275
 350 | 0350 | 350 | 0350
 375 | 0375 | 375 | 0375
(8 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Semi Join
               Hash Cond: (t1_1.a = t2_1.b)
               ->  Seq Scan on prt1_ad_p1 t1_1
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p1 t2_1
         ->  Hash Semi Join
               Hash Cond: (t1_2.a = t2_2.b)
               ->  Seq Scan on prt1_ad_p2 t1_2
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p2 t2_2
         ->  Hash Semi Join
               Hash Cond: (t1_3.a = t2_3.b)
               ->  Seq Scan on prt1_ad_p3 t1_3
                     Filter: (b = 0)
               ->  Hash
                     ->  Seq Scan on prt2_ad_p3 t2_3
(21 rows)

SELECT t1.* FROM prt1_ad t1 WHERE EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
  a  | b |  c   
-----+---+------
 100 | 0 | 0100
 125 | 0 | 0125
 200 | 0 | 0200
 225 | 0 | 0225
 250 | 0 | 0250
 275 | 0 | 0275
 350 | 0 | 0350
 375 | 0 | 0375
(8 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Append
         ->  Hash Right Join
               Hash Cond: (t2_1.b = t1_1.a)
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (t2_2.b = t1_2.a)
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (t2_3.b = t1_3.a)
               ->  Seq Scan on prt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 100 | 0100 | 100 | 0100
 125 | 0125 | 125 | 0125
 150 | 0150 |     | 
 175 | 0175 |     | 
 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275
 300 | 0300 |     | 
 325 | 0325 |     | 
 350 | 0350 | 350 | 0350
 375 | 0375 | 375 | 0375
(12 rows)

-- left join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.b, t1.c, t2.a, t2.c FROM prt2_ad t1 LEFT JOIN prt1_ad t2 ON (t1.b = t2.a) WHERE t1.a = 0 ORDER BY t1.b, t2.a;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: t1.b, t2.a
   ->  Hash Right Join
         Hash Cond: (t2.a = t1.b)
         ->  Append
               ->  Seq Scan on prt1_ad_p1 t2_1
               ->  Seq Scan on prt1_ad_p2 t2_2
               ->  Seq Scan on prt1_ad_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt2_ad_p1 t1_1
                           Filter: (a = 0)
                     ->  Seq Scan on prt2_ad_p2 t1_2
                           Filter: (a = 0)
                     ->  Seq Scan on prt2_ad_p3 t1_3
                           Filter: (a = 0)
                     ->  Seq Scan on prt2_ad_extra t1_4
                           Filter: (a = 0)
(18 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0;
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Hash Anti Join
         Hash Cond: (t1_1.a = t2_1.b)
         ->  Seq Scan on prt1_ad_p1 t1_1
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p1 t2_1
   ->  Hash Anti Join
         Hash Cond: (t1_2.a = t2_2.b)
         ->  Seq Scan on prt1_ad_p2 t1_2
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p2 t2_2
   ->  Hash Anti Join
         Hash Cond: (t1_3.a = t2_3.b)
         ->  Seq Scan on prt1_ad_p3 t1_3
               Filter: (b = 0)
         ->  Hash
               ->  Seq Scan on prt2_ad_p3 t2_3
(19 rows)

SELECT t1.* FROM prt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0;
  a  | b |  c   
-----+---+------
 150 | 0 | 0150
 175 | 0 | 0175
 300 | 0 | 0300
 325 | 0 | 0325
(4 rows)

-- anti join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt2_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt1_ad t2 WHERE t1.b = t2.a) AND t1.a = 0;
                  QUERY PLAN                   
-----------------------------------------------
 Hash Anti Join
   Hash Cond: (t1.b = t2.a)
   ->  Append
         ->  Seq Scan on prt2_ad_p1 t1_1
               Filter: (a = 0)
         ->  Seq Scan on prt2_ad_p2 t1_2
               Filter: (a = 0)
         ->  Seq Scan on prt2_ad_p3 t1_3
               Filter: (a = 0)
         ->  Seq Scan on prt2_ad_extra t1_4
               Filter: (a = 0)
   ->  Hash
         ->  Append
               ->  Seq Scan on prt1_ad_p1 t2_1
               ->  Seq Scan on prt1_ad_p2 t2_2
               ->  Seq Scan on prt1_ad_p3 t2_3
(16 rows)

-- full join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_ad WHERE prt1_ad.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_ad WHERE prt2_ad.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Sort Key: prt1_ad.a, prt2_ad.b
   ->  Hash Full Join
         Hash Cond: (prt2_ad.b = prt1_ad.a)
         Filter: (((175) = prt1_ad.a) OR ((425) = prt2_ad.b))
         ->  Append
               ->  Seq Scan on prt2_ad_p1 prt2_ad_1
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_p2 prt2_ad_2
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_p3 prt2_ad_3
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_extra prt2_ad_4
                     Filter: (a = 0)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p1 prt1_ad_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p2 prt1_ad_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 prt1_ad_3
                           Filter: (b = 0)
(22 rows)

-- 3-way join where not every pair of relations can do partitioned join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a, t3.c FROM prt1_ad t1 RIGHT JOIN prt2_ad t2 ON (t1.a = t2.b) INNER JOIN prt1_ad t3 ON (t2.b = t3.a) WHERE t1.b = 0 ORDER BY t1.a, t2.a, t3.c;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a, t3.c
   ->  Append
         ->  Nested Loop
               Join Filter: (t1_1.a = t3_1.a)
               ->  Hash Join
                     Hash Cond: (t2_1.b = t1_1.a)
                     ->  Seq Scan on prt2_ad_p1 t2_1
                     ->  Hash
                           ->  Seq Scan on prt1_ad_p1 t1_1
                                 Filter: (b = 0)
               ->  Index Scan using prt1_ad_p1_a_idx on prt1_ad_p1 t3_1
                     Index Cond: (a = t2_1.b)
         ->  Nested Loop
               Join Filter: (t1_2.a = t3_2.a)
               ->  Hash Join
                     Hash Cond: (t2_2.b = t1_2.a)
                     ->  Seq Scan on prt2_ad_p2 t2_2
                     ->  Hash
                           ->  Seq Scan on prt1_ad_p2 t1_2
                                 Filter: (b = 0)
               ->  Index Scan using prt1_ad_p2_a_idx on prt1_ad_p2 t3_2
                     Index Cond: (a = t2_2.b)
         ->  Nested Loop
               Join Filter: (t1_3.a = t2_3.b)
               ->  Hash Join
                     Hash Cond: (t3_3.a = t1_3.a)
                     ->  Seq Scan on prt1_ad_p3 t3_3
                     ->  Hash
                           ->  Seq Scan on prt1_ad_p3 t1_3
                                 Filter: (b = 0)
               ->  Index Scan using prt2_ad_p3_b_idx on prt2_ad_p3 t2_3
                     Index Cond: (b = t3_3.a)
(33 rows)

SELECT t1.a, t2.a, t3.c FROM prt1_ad t1 RIGHT JOIN prt2_ad t2 ON (t1.a = t2.b) INNER JOIN prt1_ad t3 ON (t2.b = t3.a) WHERE t1.b = 0 ORDER BY t1.a, t2.a, t3.c;
  a  | a |  c   
-----+---+------
 100 | 0 | 0100
 125 | 0 | 0125
 200 | 0 | 0200
 225 | 0 | 0225
 250 | 0 | 0250
 275 | 0 | 0275
 350 | 0 | 0350
 375 | 0 | 0375
(8 rows)

DROP TABLE prt2_ad_extra;
-- Test cases where a partition on one side matches multiple partitions on
-- the other side; we currently can't do partitioned join in those cases
-- Split prt2_ad_p3 into two partitions so that prt1_ad_p3 matches both
-- partitions
ALTER TABLE prt2_ad DETACH PARTITION prt2_ad_p3;
CREATE TABLE prt2_ad_p3_350_375 PARTITION OF prt2_ad FOR VALUES FROM (350) TO (375);
CREATE TABLE prt2_ad_p3_375_500 PARTITION OF prt2_ad FOR VALUES FROM (375) TO (500);
INSERT INTO prt2_ad SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(350, 499) i;
ANALYZE prt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Seq Scan on prt2_ad_p3_350_375 t2_3
               ->  Seq Scan on prt2_ad_p3_375_500 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(17 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0 ORDER BY t1.a;
                         QUERY PLAN                          
-------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Semi Join
         Hash Cond: (t1.a = t2.b)
         ->  Append
               ->  Seq Scan on prt1_ad_p1 t1_1
                     Filter: (b = 0)
               ->  Seq Scan on prt1_ad_p2 t1_2
                     Filter: (b = 0)
               ->  Seq Scan on prt1_ad_p3 t1_3
                     Filter: (b = 0)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt2_ad_p1 t2_1
                     ->  Seq Scan on prt2_ad_p2 t2_2
                     ->  Seq Scan on prt2_ad_p3_350_375 t2_3
                     ->  Seq Scan on prt2_ad_p3_375_500 t2_4
(17 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b
   ->  Hash Right Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Seq Scan on prt2_ad_p3_350_375 t2_3
               ->  Seq Scan on prt2_ad_p3_375_500 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p1 t1_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p2 t1_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 t1_3
                           Filter: (b = 0)
(17 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM prt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM prt2_ad t2 WHERE t1.a = t2.b) AND t1.b = 0;
                      QUERY PLAN                       
-------------------------------------------------------
 Hash Anti Join
   Hash Cond: (t1.a = t2.b)
   ->  Append
         ->  Seq Scan on prt1_ad_p1 t1_1
               Filter: (b = 0)
         ->  Seq Scan on prt1_ad_p2 t1_2
               Filter: (b = 0)
         ->  Seq Scan on prt1_ad_p3 t1_3
               Filter: (b = 0)
   ->  Hash
         ->  Append
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Seq Scan on prt2_ad_p3_350_375 t2_3
               ->  Seq Scan on prt2_ad_p3_375_500 t2_4
(15 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 175 phv, * FROM prt1_ad WHERE prt1_ad.b = 0) t1 FULL JOIN (SELECT 425 phv, * FROM prt2_ad WHERE prt2_ad.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Sort Key: prt1_ad.a, prt2_ad.b
   ->  Hash Full Join
         Hash Cond: (prt2_ad.b = prt1_ad.a)
         Filter: (((175) = prt1_ad.a) OR ((425) = prt2_ad.b))
         ->  Append
               ->  Seq Scan on prt2_ad_p1 prt2_ad_1
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_p2 prt2_ad_2
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_p3_350_375 prt2_ad_3
                     Filter: (a = 0)
               ->  Seq Scan on prt2_ad_p3_375_500 prt2_ad_4
                     Filter: (a = 0)
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p1 prt1_ad_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p2 prt1_ad_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 prt1_ad_3
                           Filter: (b = 0)
(22 rows)

DROP TABLE prt2_ad_p3_350_375;
DROP TABLE prt2_ad_p3_375_500;
-- Test default partitions
-- Change prt1_ad_p1 to the default partition
ALTER TABLE prt1_ad DETACH PARTITION prt1_ad_p1;
ALTER TABLE prt1_ad ATTACH PARTITION prt1_ad_p1 DEFAULT;
ANALYZE prt1_ad;
CREATE TABLE prt2_ad_p3_300_400 PARTITION OF prt2_ad FOR VALUES FROM (300) TO (400);
INSERT INTO prt2_ad SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(300, 399) i;
ANALYZE prt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: (t2_1.b = t1_3.a)
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on prt1_ad_p1 t1_3
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_2.b = t1_1.a)
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on prt1_ad_p2 t1_1
                           Filter: (b = 0)
         ->  Hash Join
               Hash Cond: (t2_3.b = t1_2.a)
               ->  Seq Scan on prt2_ad_p3_300_400 t2_3
               ->  Hash
                     ->  Seq Scan on prt1_ad_p3 t1_2
                           Filter: (b = 0)
(21 rows)

SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
  a  |  c   |  b  |  c   
-----+------+-----+------
 100 | 0100 | 100 | 0100
 125 | 0125 | 125 | 0125
 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275
 300 | 0300 | 300 | 0300
 325 | 0325 | 325 | 0325
 350 | 0350 | 350 | 0350
 375 | 0375 | 375 | 0375
(10 rows)

DROP TABLE prt2_ad_p3_300_400;
-- Restore prt2_ad_p3
ALTER TABLE prt2_ad ATTACH PARTITION prt2_ad_p3 FOR VALUES FROM (350) TO (500);
ANALYZE prt2_ad;
-- Partitioned join can't be applied because the default partition of prt1_ad
-- prt1_ad_p1 matches prt2_ad_p1 and prt2_ad_p3
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Seq Scan on prt2_ad_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p2 t1_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 t1_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p1 t1_3
                           Filter: (b = 0)
(16 rows)

-- Change prt2_ad_p3 to the default partition
ALTER TABLE prt2_ad DETACH PARTITION prt2_ad_p3;
ALTER TABLE prt2_ad ATTACH PARTITION prt2_ad_p3 DEFAULT;
ANALYZE prt2_ad;
-- Partitioned join can't be applied because the default partition of prt1_ad
-- prt1_ad_p1 matches prt2_ad_p1 and prt2_ad_p3
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_ad t1 INNER JOIN prt2_ad t2 ON (t1.a = t2.b) WHERE t1.b = 0 ORDER BY t1.a, t2.b;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: (t2.b = t1.a)
         ->  Append
               ->  Seq Scan on prt2_ad_p1 t2_1
               ->  Seq Scan on prt2_ad_p2 t2_2
               ->  Seq Scan on prt2_ad_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on prt1_ad_p2 t1_1
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p3 t1_2
                           Filter: (b = 0)
                     ->  Seq Scan on prt1_ad_p1 t1_3
                           Filter: (b = 0)
(16 rows)

DROP TABLE prt1_ad_p3;
ANALYZE prt1_ad;
DROP TABLE prt2_ad_p3;
ANALYZE prt2_ad;
CREATE TABLE prt3_ad (a int, b int, c varchar) PARTITION BY RANGE (a);
CREATE TABLE prt3_ad_p1 PARTITION OF prt3_ad FOR VALUES FROM (200) TO (300);
CREATE TABLE prt3_ad_p2 PARTITION OF prt3_ad FOR VALUES FROM (300) TO (400);
CREATE INDEX prt3_ad_a_idx on prt3_ad (a);
INSERT INTO prt3_ad SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(200, 399) i;
ANALYZE prt3_ad;
-- 3-way join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.b, t2.c, t3.a, t3.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) LEFT JOIN prt3_ad t3 ON (t1.a = t3.a) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.b, t3.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: (t3_1.a = t1_1.a)
               ->  Seq Scan on prt3_ad_p1 t3_1
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (t2_2.b = t1_1.a)
                           ->  Seq Scan on prt2_ad_p2 t2_2
                           ->  Hash
                                 ->  Seq Scan on prt1_ad_p2 t1_1
                                       Filter: (b = 0)
         ->  Hash Right Join
               Hash Cond: (t3_2.a = t1_2.a)
               ->  Seq Scan on prt3_ad_p2 t3_2
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (t2_1.b = t1_2.a)
                           ->  Seq Scan on prt2_ad_p1 t2_1
                           ->  Hash
                                 ->  Seq Scan on prt1_ad_p1 t1_2
                                       Filter: (b = 0)
(23 rows)

SELECT t1.a, t1.c, t2.b, t2.c, t3.a, t3.c FROM prt1_ad t1 LEFT JOIN prt2_ad t2 ON (t1.a = t2.b) LEFT JOIN prt3_ad t3 ON (t1.a = t3.a) WHERE t1.b = 0 ORDER BY t1.a, t2.b, t3.a;
  a  |  c   |  b  |  c   |  a  |  c   
-----+------+-----+------+-----+------
 100 | 0100 | 100 | 0100 |     | 
 125 | 0125 | 125 | 0125 |     | 
 150 | 0150 |     |      |     | 
 175 | 0175 |     |      |     | 
 200 | 0200 | 200 | 0200 | 200 | 0200
 225 | 0225 | 225 | 0225 | 225 | 0225
 250 | 0250 | 250 | 0250 | 250 | 0250
 275 | 0275 | 275 | 0275 | 275 | 0275
(8 rows)

-- Tests for list-partitioned tables
CREATE TABLE plt1_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt1_ad_p1 PARTITION OF plt1_ad FOR VALUES IN ('0001', '0003');
CREATE TABLE plt1_ad_p2 PARTITION OF plt1_ad FOR VALUES IN ('0004', '0006');
CREATE TABLE plt1_ad_p3 PARTITION OF plt1_ad FOR VALUES IN ('0008', '0009');
INSERT INTO plt1_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 NOT IN (0, 2, 5, 7);
ANALYZE plt1_ad;
CREATE TABLE plt2_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt2_ad_p1 PARTITION OF plt2_ad FOR VALUES IN ('0002', '0003');
CREATE TABLE plt2_ad_p2 PARTITION OF plt2_ad FOR VALUES IN ('0004', '0006');
CREATE TABLE plt2_ad_p3 PARTITION OF plt2_ad FOR VALUES IN ('0007', '0009');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 NOT IN (0, 1, 5, 8);
ANALYZE plt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 9 | 0009 | 9 | 0009
(4 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Semi Join
               Join Filter: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Semi Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Semi Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3 t2_3
(18 rows)

SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a | b |  c   
---+---+------
 3 | 3 | 0003
 4 | 4 | 0004
 6 | 6 | 0006
 9 | 9 | 0009
(4 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 1 | 0001 |   | 
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 8 | 0008 |   | 
 9 | 0009 | 9 | 0009
(6 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Anti Join
               Join Filter: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Anti Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Anti Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3 t2_3
(18 rows)

SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a | b |  c   
---+---+------
 1 | 1 | 0001
 8 | 8 | 0008
(2 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Append
         ->  Hash Full Join
               Hash Cond: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               Filter: ((COALESCE(t1_1.b, 0) < 10) AND (COALESCE(t2_1.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p1 t1_1
               ->  Hash
                     ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Hash Full Join
               Hash Cond: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               Filter: ((COALESCE(t1_2.b, 0) < 10) AND (COALESCE(t2_2.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p2 t1_2
               ->  Hash
                     ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Hash Full Join
               Hash Cond: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               Filter: ((COALESCE(t1_3.b, 0) < 10) AND (COALESCE(t2_3.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p3 t1_3
               ->  Hash
                     ->  Seq Scan on plt2_ad_p3 t2_3
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
 a |  c   | a |  c   
---+------+---+------
 1 | 0001 |   | 
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 8 | 0008 |   | 
 9 | 0009 | 9 | 0009
   |      | 2 | 0002
   |      | 7 | 0007
(8 rows)

-- Test cases where one side has an extra partition
-- Add an extra partition to plt2_ad
CREATE TABLE plt2_ad_extra PARTITION OF plt2_ad FOR VALUES IN ('0000');
INSERT INTO plt2_ad_extra VALUES (0, 0, '0000');
ANALYZE plt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 9 | 0009 | 9 | 0009
(4 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Semi Join
               Join Filter: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Semi Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Semi Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3 t2_3
(18 rows)

SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a | b |  c   
---+---+------
 3 | 3 | 0003
 4 | 4 | 0004
 6 | 6 | 0006
 9 | 9 | 0009
(4 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 1 | 0001 |   | 
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 8 | 0008 |   | 
 9 | 0009 | 9 | 0009
(6 rows)

-- left join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt2_ad t1 LEFT JOIN plt1_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Right Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt1_ad_p1 t2_1
               ->  Seq Scan on plt1_ad_p2 t2_2
               ->  Seq Scan on plt1_ad_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt2_ad_extra t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt2_ad_p1 t1_2
                           Filter: (b < 10)
                     ->  Seq Scan on plt2_ad_p2 t1_3
                           Filter: (b < 10)
                     ->  Seq Scan on plt2_ad_p3 t1_4
                           Filter: (b < 10)
(18 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Nested Loop Anti Join
               Join Filter: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Anti Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Anti Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3 t2_3
(18 rows)

SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a | b |  c   
---+---+------
 1 | 1 | 0001
 8 | 8 | 0008
(2 rows)

-- anti join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt2_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt1_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Anti Join
         Hash Cond: ((t1.a = t2.a) AND (t1.c = t2.c))
         ->  Append
               ->  Seq Scan on plt2_ad_extra t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p1 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3 t1_4
                     Filter: (b < 10)
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t2_1
                     ->  Seq Scan on plt1_ad_p2 t2_2
                     ->  Seq Scan on plt1_ad_p3 t2_3
(18 rows)

-- full join; currently we can't do partitioned join if there are no matched
-- partitions on the nullable side
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Hash Full Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         Filter: ((COALESCE(t1.b, 0) < 10) AND (COALESCE(t2.b, 0) < 10))
         ->  Append
               ->  Seq Scan on plt2_ad_extra t2_1
               ->  Seq Scan on plt2_ad_p1 t2_2
               ->  Seq Scan on plt2_ad_p2 t2_3
               ->  Seq Scan on plt2_ad_p3 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t1_1
                     ->  Seq Scan on plt1_ad_p2 t1_2
                     ->  Seq Scan on plt1_ad_p3 t1_3
(15 rows)

DROP TABLE plt2_ad_extra;
-- Test cases where a partition on one side matches multiple partitions on
-- the other side; we currently can't do partitioned join in those cases
-- Split plt2_ad_p2 into two partitions so that prt1_ad_p2 matches both
-- partitions
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p2;
CREATE TABLE plt2_ad_p2_0004 PARTITION OF plt2_ad FOR VALUES IN ('0004');
CREATE TABLE plt2_ad_p2_0006 PARTITION OF plt2_ad FOR VALUES IN ('0006');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 6);
ANALYZE plt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2_0004 t2_2
               ->  Seq Scan on plt2_ad_p2_0006 t2_3
               ->  Seq Scan on plt2_ad_p3 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(17 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                        QUERY PLAN                        
----------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Semi Join
         Hash Cond: ((t1.a = t2.a) AND (t1.c = t2.c))
         ->  Append
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt2_ad_p1 t2_1
                     ->  Seq Scan on plt2_ad_p2_0004 t2_2
                     ->  Seq Scan on plt2_ad_p2_0006 t2_3
                     ->  Seq Scan on plt2_ad_p3 t2_4
(17 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Right Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2_0004 t2_2
               ->  Seq Scan on plt2_ad_p2_0006 t2_3
               ->  Seq Scan on plt2_ad_p3 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(17 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                        QUERY PLAN                        
----------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Anti Join
         Hash Cond: ((t1.a = t2.a) AND (t1.c = t2.c))
         ->  Append
               ->  Seq Scan on plt1_ad_p1 t1_1
                     Filter: (b < 10)
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt2_ad_p1 t2_1
                     ->  Seq Scan on plt2_ad_p2_0004 t2_2
                     ->  Seq Scan on plt2_ad_p2_0006 t2_3
                     ->  Seq Scan on plt2_ad_p3 t2_4
(17 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Hash Full Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         Filter: ((COALESCE(t1.b, 0) < 10) AND (COALESCE(t2.b, 0) < 10))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2_0004 t2_2
               ->  Seq Scan on plt2_ad_p2_0006 t2_3
               ->  Seq Scan on plt2_ad_p3 t2_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t1_1
                     ->  Seq Scan on plt1_ad_p2 t1_2
                     ->  Seq Scan on plt1_ad_p3 t1_3
(15 rows)

DROP TABLE plt2_ad_p2_0004;
DROP TABLE plt2_ad_p2_0006;
-- Restore plt2_ad_p2
ALTER TABLE plt2_ad ATTACH PARTITION plt2_ad_p2 FOR VALUES IN ('0004', '0006');
ANALYZE plt2_ad;
-- Test NULL partitions
-- Change plt1_ad_p1 to the NULL partition
ALTER TABLE plt1_ad DETACH PARTITION plt1_ad_p1;
CREATE TABLE plt1_ad_p1_null PARTITION OF plt1_ad FOR VALUES IN (NULL, '0001', '0003');
INSERT INTO plt1_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 3);
INSERT INTO plt1_ad VALUES (-1, -1, NULL);
ANALYZE plt1_ad;
-- Change plt2_ad_p3 to the NULL partition
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p3;
CREATE TABLE plt2_ad_p3_null PARTITION OF plt2_ad FOR VALUES IN (NULL, '0007', '0009');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (7, 9);
INSERT INTO plt2_ad VALUES (-1, -1, NULL);
ANALYZE plt2_ad;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1_null t1_1
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3_null t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 9 | 0009 | 9 | 0009
(4 rows)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Semi Join
               Hash Cond: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1_null t1_1
                     Filter: (b < 10)
               ->  Hash
                     ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Semi Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Semi Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3_null t2_3
(19 rows)

SELECT t1.* FROM plt1_ad t1 WHERE EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a | b |  c   
---+---+------
 3 | 3 | 0003
 4 | 4 | 0004
 6 | 6 | 0006
 9 | 9 | 0009
(4 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1_null t1_1
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3_null t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a  |  c   | a |  c   
----+------+---+------
 -1 |      |   | 
  1 | 0001 |   | 
  3 | 0003 | 3 | 0003
  4 | 0004 | 4 | 0004
  6 | 0006 | 6 | 0006
  8 | 0008 |   | 
  9 | 0009 | 9 | 0009
(7 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Anti Join
               Hash Cond: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               ->  Seq Scan on plt1_ad_p1_null t1_1
                     Filter: (b < 10)
               ->  Hash
                     ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Nested Loop Anti Join
               Join Filter: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               ->  Seq Scan on plt1_ad_p2 t1_2
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Nested Loop Anti Join
               Join Filter: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               ->  Seq Scan on plt1_ad_p3 t1_3
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_p3_null t2_3
(19 rows)

SELECT t1.* FROM plt1_ad t1 WHERE NOT EXISTS (SELECT 1 FROM plt2_ad t2 WHERE t1.a = t2.a AND t1.c = t2.c) AND t1.b < 10 ORDER BY t1.a;
 a  | b  |  c   
----+----+------
 -1 | -1 | 
  1 |  1 | 0001
  8 |  8 | 0008
(3 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Append
         ->  Hash Full Join
               Hash Cond: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               Filter: ((COALESCE(t1_1.b, 0) < 10) AND (COALESCE(t2_1.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p1_null t1_1
               ->  Hash
                     ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Hash Full Join
               Hash Cond: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               Filter: ((COALESCE(t1_2.b, 0) < 10) AND (COALESCE(t2_2.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p2 t1_2
               ->  Hash
                     ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Hash Full Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               Filter: ((COALESCE(t1_3.b, 0) < 10) AND (COALESCE(t2_3.b, 0) < 10))
               ->  Seq Scan on plt2_ad_p3_null t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
 a  |  c   | a  |  c   
----+------+----+------
 -1 |      |    | 
  1 | 0001 |    | 
  3 | 0003 |  3 | 0003
  4 | 0004 |  4 | 0004
  6 | 0006 |  6 | 0006
  8 | 0008 |    | 
  9 | 0009 |  9 | 0009
    |      | -1 | 
    |      |  2 | 0002
    |      |  7 | 0007
(10 rows)

DROP TABLE plt1_ad_p1_null;
DROP TABLE plt2_ad_p3_null;
-- Restore plt1_ad_p1
ALTER TABLE plt1_ad ATTACH PARTITION plt1_ad_p1 FOR VALUES IN ('0001', '0003');
-- Add to plt1_ad the extra NULL partition containing only NULL values as the
-- key values
CREATE TABLE plt1_ad_extra PARTITION OF plt1_ad FOR VALUES IN (NULL);
INSERT INTO plt1_ad VALUES (-1, -1, NULL);
ANALYZE plt1_ad;
-- Restore plt2_ad_p3
ALTER TABLE plt2_ad ATTACH PARTITION plt2_ad_p3 FOR VALUES IN ('0007', '0009');
ANALYZE plt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 9 | 0009 | 9 | 0009
(4 rows)

-- Partitioned join can't be applied because there isn't any partition on the
-- plt2_ad side that matches the NULL partition of plt1_ad plt1_ad_extra
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Right Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Seq Scan on plt2_ad_p3 t2_3
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_extra t1_4
                           Filter: (b < 10)
(18 rows)

-- Partitioned join can't be applied because there isn't any partition on the
-- plt2_ad side that matches the NULL partition of plt1_ad plt1_ad_extra
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Hash Full Join
         Hash Cond: ((t1.a = t2.a) AND (t1.c = t2.c))
         Filter: ((COALESCE(t1.b, 0) < 10) AND (COALESCE(t2.b, 0) < 10))
         ->  Append
               ->  Seq Scan on plt1_ad_p1 t1_1
               ->  Seq Scan on plt1_ad_p2 t1_2
               ->  Seq Scan on plt1_ad_p3 t1_3
               ->  Seq Scan on plt1_ad_extra t1_4
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt2_ad_p1 t2_1
                     ->  Seq Scan on plt2_ad_p2 t2_2
                     ->  Seq Scan on plt2_ad_p3 t2_3
(15 rows)

-- Add to plt2_ad the extra NULL partition containing only NULL values as the
-- key values
CREATE TABLE plt2_ad_extra PARTITION OF plt2_ad FOR VALUES IN (NULL);
INSERT INTO plt2_ad VALUES (-1, -1, NULL);
ANALYZE plt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
(21 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
 9 | 0009 | 9 | 0009
(4 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t2_1.a = t1_1.a) AND (t2_1.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_1
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_2.a = t1_2.a) AND (t2_2.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_2
                           Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t2_3.a = t1_3.a) AND (t2_3.c = t1_3.c))
               ->  Seq Scan on plt2_ad_p3 t2_3
               ->  Hash
                     ->  Seq Scan on plt1_ad_p3 t1_3
                           Filter: (b < 10)
         ->  Nested Loop Left Join
               Join Filter: ((t1_4.a = t2_4.a) AND (t1_4.c = t2_4.c))
               ->  Seq Scan on plt1_ad_extra t1_4
                     Filter: (b < 10)
               ->  Seq Scan on plt2_ad_extra t2_4
(26 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a  |  c   | a |  c   
----+------+---+------
 -1 |      |   | 
  1 | 0001 |   | 
  3 | 0003 | 3 | 0003
  4 | 0004 | 4 | 0004
  6 | 0006 | 6 | 0006
  8 | 0008 |   | 
  9 | 0009 | 9 | 0009
(7 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a, t2.a
   ->  Append
         ->  Hash Full Join
               Hash Cond: ((t1_1.a = t2_1.a) AND (t1_1.c = t2_1.c))
               Filter: ((COALESCE(t1_1.b, 0) < 10) AND (COALESCE(t2_1.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p1 t1_1
               ->  Hash
                     ->  Seq Scan on plt2_ad_p1 t2_1
         ->  Hash Full Join
               Hash Cond: ((t1_2.a = t2_2.a) AND (t1_2.c = t2_2.c))
               Filter: ((COALESCE(t1_2.b, 0) < 10) AND (COALESCE(t2_2.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p2 t1_2
               ->  Hash
                     ->  Seq Scan on plt2_ad_p2 t2_2
         ->  Hash Full Join
               Hash Cond: ((t1_3.a = t2_3.a) AND (t1_3.c = t2_3.c))
               Filter: ((COALESCE(t1_3.b, 0) < 10) AND (COALESCE(t2_3.b, 0) < 10))
               ->  Seq Scan on plt1_ad_p3 t1_3
               ->  Hash
                     ->  Seq Scan on plt2_ad_p3 t2_3
         ->  Hash Full Join
               Hash Cond: ((t1_4.a = t2_4.a) AND (t1_4.c = t2_4.c))
               Filter: ((COALESCE(t1_4.b, 0) < 10) AND (COALESCE(t2_4.b, 0) < 10))
               ->  Seq Scan on plt1_ad_extra t1_4
               ->  Hash
                     ->  Seq Scan on plt2_ad_extra t2_4
(27 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 FULL JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE coalesce(t1.b, 0) < 10 AND coalesce(t2.b, 0) < 10 ORDER BY t1.a, t2.a;
 a  |  c   | a  |  c   
----+------+----+------
 -1 |      |    | 
  1 | 0001 |    | 
  3 | 0003 |  3 | 0003
  4 | 0004 |  4 | 0004
  6 | 0006 |  6 | 0006
  8 | 0008 |    | 
  9 | 0009 |  9 | 0009
    |      | -1 | 
    |      |  2 | 0002
    |      |  7 | 0007
(10 rows)

DROP TABLE plt1_ad_extra;
DROP TABLE plt2_ad_extra;
-- Test default partitions
-- Change plt1_ad_p1 to the default partition
ALTER TABLE plt1_ad DETACH PARTITION plt1_ad_p1;
ALTER TABLE plt1_ad ATTACH PARTITION plt1_ad_p1 DEFAULT;
DROP TABLE plt1_ad_p3;
ANALYZE plt1_ad;
DROP TABLE plt2_ad_p3;
ANALYZE plt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_2.a) AND (t2_1.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_1.a) AND (t2_2.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_1
                           Filter: (b < 10)
(15 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
(3 rows)

-- Change plt2_ad_p2 to contain '0005' in addition to '0004' and '0006' as
-- the key values
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p2;
CREATE TABLE plt2_ad_p2_ext PARTITION OF plt2_ad FOR VALUES IN ('0004', '0005', '0006');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 5, 6);
ANALYZE plt2_ad;
-- Partitioned join can't be applied because the default partition of plt1_ad
-- plt1_ad_p1 matches plt2_ad_p1 and plt2_ad_p2_ext
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2_ext t2_2
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p2 t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p1 t1_2
                           Filter: (b < 10)
(13 rows)

-- Change plt2_ad_p2_ext to the default partition
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p2_ext;
ALTER TABLE plt2_ad ATTACH PARTITION plt2_ad_p2_ext DEFAULT;
ANALYZE plt2_ad;
-- Partitioned join can't be applied because the default partition of plt1_ad
-- plt1_ad_p1 matches plt2_ad_p1 and plt2_ad_p2_ext
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Append
               ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Seq Scan on plt2_ad_p2_ext t2_2
         ->  Hash
               ->  Append
                     ->  Seq Scan on plt1_ad_p2 t1_1
                           Filter: (b < 10)
                     ->  Seq Scan on plt1_ad_p1 t1_2
                           Filter: (b < 10)
(13 rows)

DROP TABLE plt2_ad_p2_ext;
-- Restore plt2_ad_p2
ALTER TABLE plt2_ad ATTACH PARTITION plt2_ad_p2 FOR VALUES IN ('0004', '0006');
ANALYZE plt2_ad;
CREATE TABLE plt3_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt3_ad_p1 PARTITION OF plt3_ad FOR VALUES IN ('0004', '0006');
CREATE TABLE plt3_ad_p2 PARTITION OF plt3_ad FOR VALUES IN ('0007', '0009');
INSERT INTO plt3_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (4, 6, 7, 9);
ANALYZE plt3_ad;
-- 3-way join
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) LEFT JOIN plt3_ad t3 ON (t1.a = t3.a AND t1.c = t3.c) WHERE t1.b < 10 ORDER BY t1.a;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Right Join
               Hash Cond: ((t3_1.a = t1_1.a) AND (t3_1.c = t1_1.c))
               ->  Seq Scan on plt3_ad_p1 t3_1
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: ((t2_2.a = t1_1.a) AND (t2_2.c = t1_1.c))
                           ->  Seq Scan on plt2_ad_p2 t2_2
                           ->  Hash
                                 ->  Seq Scan on plt1_ad_p2 t1_1
                                       Filter: (b < 10)
         ->  Hash Right Join
               Hash Cond: ((t3_2.a = t1_2.a) AND (t3_2.c = t1_2.c))
               ->  Seq Scan on plt3_ad_p2 t3_2
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: ((t2_1.a = t1_2.a) AND (t2_1.c = t1_2.c))
                           ->  Seq Scan on plt2_ad_p1 t2_1
                           ->  Hash
                                 ->  Seq Scan on plt1_ad_p1 t1_2
                                       Filter: (b < 10)
(23 rows)

SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) LEFT JOIN plt3_ad t3 ON (t1.a = t3.a AND t1.c = t3.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   | a |  c   
---+------+---+------+---+------
 1 | 0001 |   |      |   | 
 3 | 0003 | 3 | 0003 |   | 
 4 | 0004 | 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006 | 6 | 0006
(4 rows)

-- Test cases where one side has the default partition while the other side
-- has the NULL partition
-- Change plt2_ad_p1 to the NULL partition
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p1;
CREATE TABLE plt2_ad_p1_null PARTITION OF plt2_ad FOR VALUES IN (NULL, '0001', '0003');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 10, 'FM0000') FROM generate_series(1, 299) i WHERE i % 10 IN (1, 3);
INSERT INTO plt2_ad VALUES (-1, -1, NULL);
ANALYZE plt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Append
         ->  Hash Join
               Hash Cond: ((t2_1.a = t1_2.a) AND (t2_1.c = t1_2.c))
               ->  Seq Scan on plt2_ad_p1_null t2_1
               ->  Hash
                     ->  Seq Scan on plt1_ad_p1 t1_2
                           Filter: (b < 10)
         ->  Hash Join
               Hash Cond: ((t2_2.a = t1_1.a) AND (t2_2.c = t1_1.c))
               ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt1_ad_p2 t1_1
                           Filter: (b < 10)
(15 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 1 | 0001 | 1 | 0001
 3 | 0003 | 3 | 0003
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
(4 rows)

-- Change the NULL partition to contain only NULL values as the key values
ALTER TABLE plt2_ad DETACH PARTITION plt2_ad_p1_null;
CREATE TABLE plt2_ad_p1_nullonly PARTITION OF plt2_ad FOR VALUES IN (NULL);
INSERT INTO plt2_ad VALUES (-1, -1, NULL);
ANALYZE plt2_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: t1.a
   ->  Hash Join
         Hash Cond: ((t2.a = t1.a) AND (t2.c = t1.c))
         ->  Seq Scan on plt2_ad_p2 t2
         ->  Hash
               ->  Seq Scan on plt1_ad_p2 t1
                     Filter: (b < 10)
(8 rows)

SELECT t1.a, t1.c, t2.a, t2.c FROM plt1_ad t1 INNER JOIN plt2_ad t2 ON (t1.a = t2.a AND t1.c = t2.c) WHERE t1.b < 10 ORDER BY t1.a;
 a |  c   | a |  c   
---+------+---+------
 4 | 0004 | 4 | 0004
 6 | 0006 | 6 | 0006
(2 rows)

DROP TABLE plt2_ad_p1_nullonly;
DROP TABLE plt2_ad_p1_null;
DROP TABLE plt2_ad_p1;
DROP TABLE plt1_ad;
DROP TABLE plt2_ad;
DROP TABLE plt3_ad;
CREATE TABLE plt1_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt1_ad_p1 PARTITION OF plt1_ad FOR VALUES IN ('0000', '0001', '0002');
CREATE TABLE plt1_ad_p2 PARTITION OF plt1_ad FOR VALUES IN ('0003', '0004');
INSERT INTO plt1_ad SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i;
ANALYZE plt1_ad;
CREATE TABLE plt2_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt2_ad_p1 PARTITION OF plt2_ad FOR VALUES IN ('0002');
CREATE TABLE plt2_ad_p2 PARTITION OF plt2_ad FOR VALUES IN ('0003', '0004');
INSERT INTO plt2_ad SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i WHERE i % 5 IN (2, 3, 4);
ANALYZE plt2_ad;
CREATE TABLE plt3_ad (a int, b int, c text) PARTITION BY LIST (c);
CREATE TABLE plt3_ad_p1 PARTITION OF plt3_ad FOR VALUES IN ('0001');
CREATE TABLE plt3_ad_p2 PARTITION OF plt3_ad FOR VALUES IN ('0003', '0004');
INSERT INTO plt3_ad SELECT i, i, to_char(i % 5, 'FM0000') FROM generate_series(0, 24) i WHERE i % 5 IN (1, 3, 4);
ANALYZE plt3_ad;
EXPLAIN (COSTS OFF)
SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM (plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.c = t2.c)) FULL JOIN plt3_ad t3 ON (t1.c = t3.c) WHERE coalesce(t1.a, 0) % 5 != 3 AND coalesce(t1.a, 0) % 5 != 4 ORDER BY t1.c, t1.a, t2.a, t3.a;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort
   Sort Key: t1.c, t1.a, t2.a, t3.a
   ->  Append
         ->  Hash Full Join
               Hash Cond: (t1_1.c = t3_1.c)
               Filter: (((COALESCE(t1_1.a, 0) % 5) <> 3) AND ((COALESCE(t1_1.a, 0) % 5) <> 4))
               ->  Hash Left Join
                     Hash Cond: (t1_1.c = t2_1.c)
                     ->  Seq Scan on plt1_ad_p1 t1_1
                     ->  Hash
                           ->  Seq Scan on plt2_ad_p1 t2_1
               ->  Hash
                     ->  Seq Scan on plt3_ad_p1 t3_1
         ->  Hash Full Join
               Hash Cond: (t1_2.c = t3_2.c)
               Filter: (((COALESCE(t1_2.a, 0) % 5) <> 3) AND ((COALESCE(t1_2.a, 0) % 5) <> 4))
               ->  Hash Left Join
                     Hash Cond: (t1_2.c = t2_2.c)
                     ->  Seq Scan on plt1_ad_p2 t1_2
                     ->  Hash
                           ->  Seq Scan on plt2_ad_p2 t2_2
               ->  Hash
                     ->  Seq Scan on plt3_ad_p2 t3_2
(23 rows)

SELECT t1.a, t1.c, t2.a, t2.c, t3.a, t3.c FROM (plt1_ad t1 LEFT JOIN plt2_ad t2 ON (t1.c = t2.c)) FULL JOIN plt3_ad t3 ON (t1.c = t3.c) WHERE coalesce(t1.a, 0) % 5 != 3 AND coalesce(t1.a, 0) % 5 != 4 ORDER BY t1.c, t1.a, t2.a, t3.a;
 a  |  c   | a  |  c   | a  |  c   
----+------+----+------+----+------
  0 | 0000 |    |      |    | 
  5 | 0000 |    |      |    | 
 10 | 0000 |    |      |    | 
 15 | 0000 |    |      |    | 
 20 | 0000 |    |      |    | 
  1 | 0001 |    |      |  1 | 0001
  1 | 0001 |    |      |  6 | 0001
  1 | 0001 |    |      | 11 | 0001
  1 | 0001 |    |      | 16 | 0001
  1 | 0001 |    |      | 21 | 0001
  6 | 0001 |    |      |  1 | 0001
  6 | 0001 |    |      |  6 | 0001
  6 | 0001 |    |      | 11 | 0001
  6 | 0001 |    |      | 16 | 0001
  6 | 0001 |    |      | 21 | 0001
 11 | 0001 |    |      |  1 | 0001
 11 | 0001 |    |      |  6 | 0001
 11 | 0001 |    |      | 11 | 0001
 11 | 0001 |    |      | 16 | 0001
 11 | 0001 |    |      | 21 | 0001
 16 | 0001 |    |      |  1 | 0001
 16 | 0001 |    |      |  6 | 0001
 16 | 0001 |    |      | 11 | 0001
 16 | 0001 |    |      | 16 | 0001
 16 | 0001 |    |      | 21 | 0001
 21 | 0001 |    |      |  1 | 0001
 21 | 0001 |    |      |  6 | 0001
 21 | 0001 |    |      | 11 | 0001
 21 | 0001 |    |      | 16 | 0001
 21 | 0001 |    |      | 21 | 0001
  2 | 0002 |  2 | 0002 |    | 
  2 | 0002 |  7 | 0002 |    | 
  2 | 0002 | 12 | 0002 |    | 
  2 | 0002 | 17 | 0002 |    | 
  2 | 0002 | 22 | 0002 |    | 
  7 | 0002 |  2 | 0002 |    | 
  7 | 0002 |  7 | 0002 |    | 
  7 | 0002 | 12 | 0002 |    | 
  7 | 0002 | 17 | 0002 |    | 
  7 | 0002 | 22 | 0002 |    | 
 12 | 0002 |  2 | 0002 |    | 
 12 | 0002 |  7 | 0002 |    | 
 12 | 0002 | 12 | 0002 |    | 
 12 | 0002 | 17 | 0002 |    | 
 12 | 0002 | 22 | 0002 |    | 
 17 | 0002 |  2 | 0002 |    | 
 17 | 0002 |  7 | 0002 |    | 
 17 | 0002 | 12 | 0002 |    | 
 17 | 0002 | 17 | 0002 |    | 
 17 | 0002 | 22 | 0002 |    | 
 22 | 0002 |  2 | 0002 |    | 
 22 | 0002 |  7 | 0002 |    | 
 22 | 0002 | 12 | 0002 |    | 
 22 | 0002 | 17 | 0002 |    | 
 22 | 0002 | 22 | 0002 |    | 
(55 rows)

CREATE TABLE raw_data (a text);
INSERT INTO raw_data (a) VALUES ('Türkiye'),
								('TÜRKIYE'),
								('bıt'),
								('BIT'),
								('äbç'),
								('ÄBÇ'),
								('aaá'),
								('coté'),
								('Götz'),
								('ὀδυσσεύς'),
								('ὈΔΥΣΣΕΎΣ'),
								('を読み取り用'),
								('にオープンできませんでした');
CREATE TABLE alpha
	(a TEXT, b TEXT)
	PARTITION BY RANGE(a, b);
CREATE TABLE alpha_a PARTITION OF alpha FOR VALUES FROM ('a','v') TO ('c','q');
CREATE TABLE alpha_b PARTITION OF alpha FOR VALUES FROM ('c','q') TO ('d','f');
CREATE TABLE alpha_c PARTITION OF alpha FOR VALUES FROM ('d','f') TO ('p','m');
CREATE TABLE alpha_d PARTITION OF alpha FOR VALUES FROM ('p','m') TO ('z','z');
CREATE TABLE alpha_e PARTITION OF alpha FOR VALUES FROM ('z','z') TO ('√','Σ');
CREATE TABLE alpha_f PARTITION OF alpha FOR VALUES FROM ('√','Σ') TO ('き','ま');
CREATE TABLE alpha_default PARTITION OF alpha DEFAULT;
CREATE TABLE beta
	(a TEXT, b TEXT)
	PARTITION BY RANGE(a, b);
CREATE TABLE beta_a PARTITION OF beta FOR VALUES FROM ('a','z') TO ('d','z');
CREATE TABLE beta_b PARTITION OF beta FOR VALUES FROM ('d','z') TO ('g','z');
CREATE TABLE beta_c PARTITION OF beta FOR VALUES FROM ('g','z') TO ('k','z');
CREATE TABLE beta_d PARTITION OF beta FOR VALUES FROM ('k','z') TO ('o','z');
CREATE TABLE beta_e PARTITION OF beta FOR VALUES FROM ('o','z') TO ('t','z');
CREATE TABLE beta_f PARTITION OF beta FOR VALUES FROM ('t','z') TO ('Δ','υ');
CREATE TABLE beta_g PARTITION OF beta FOR VALUES FROM ('Δ','υ') TO ('ὀ','√');
CREATE TABLE beta_h PARTITION OF beta FOR VALUES FROM ('ὀ','√') TO ('ん', '用');
CREATE TABLE beta_default PARTITION OF beta DEFAULT;
INSERT INTO alpha (SELECT a, a FROM raw_data);
INSERT INTO beta (SELECT a, a FROM raw_data);
ANALYZE alpha;
ANALYZE beta;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_a t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_c t2_3
         ->  Seq Scan on beta_d t2_4
         ->  Seq Scan on beta_e t2_5
         ->  Seq Scan on beta_f t2_6
         ->  Seq Scan on beta_g t2_7
         ->  Seq Scan on beta_h t2_8
         ->  Seq Scan on beta_default t2_9
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_e t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_default t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(18 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 äbç      | äbç
 ὀδυσσεύς | ὀδυσσεύς
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = 'äbç'::text)
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = 'äbç'::text)
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_f t2_1
                     Filter: (a = 'äbç'::text)
               ->  Seq Scan on beta_default t2_2
                     Filter: (a = 'äbç'::text)
(12 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop
   ->  Seq Scan on alpha_default t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_default t2
         Filter: (a = 'ὀδυσσεύς'::text)
(5 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Semi Join
   Hash Cond: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
   ->  Hash
         ->  Append
               ->  Seq Scan on beta_a t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_c t2_3
               ->  Seq Scan on beta_d t2_4
               ->  Seq Scan on beta_e t2_5
               ->  Seq Scan on beta_f t2_6
               ->  Seq Scan on beta_g t2_7
               ->  Seq Scan on beta_h t2_8
               ->  Seq Scan on beta_default t2_9
(18 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
    a     
----------
 äbç
 ὀδυσσεύς
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop Semi Join
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = 'äbç'::text)
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = 'äbç'::text)
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_f t2_1
                     Filter: (a = 'äbç'::text)
               ->  Seq Scan on beta_default t2_2
                     Filter: (a = 'äbç'::text)
(12 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
  a  
-----
 äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Semi Join
   ->  Seq Scan on alpha_default t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_default t2
         Filter: (a = 'ὀδυσσεύς'::text)
(5 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
    a     
----------
 ὀδυσσεύς
(1 row)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_a t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_c t2_3
         ->  Seq Scan on beta_d t2_4
         ->  Seq Scan on beta_e t2_5
         ->  Seq Scan on beta_f t2_6
         ->  Seq Scan on beta_g t2_7
         ->  Seq Scan on beta_h t2_8
         ->  Seq Scan on beta_default t2_9
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_e t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_default t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(18 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 äbç      | äbç
 ὀδυσσεύς | ὀδυσσεύς
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = 'äbç'::text)
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = 'äbç'::text)
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_f t2_1
                     Filter: (a = 'äbç'::text)
               ->  Seq Scan on beta_default t2_2
                     Filter: (a = 'äbç'::text)
(13 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_default t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_default t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
   ->  Hash
         ->  Append
               ->  Seq Scan on beta_a t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_c t2_3
               ->  Seq Scan on beta_d t2_4
               ->  Seq Scan on beta_e t2_5
               ->  Seq Scan on beta_f t2_6
               ->  Seq Scan on beta_g t2_7
               ->  Seq Scan on beta_h t2_8
               ->  Seq Scan on beta_default t2_9
(18 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = 'äbç'::text)
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = 'äbç'::text)
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_f t2_1
                     Filter: (a = 'äbç'::text)
               ->  Seq Scan on beta_default t2_2
                     Filter: (a = 'äbç'::text)
(13 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Anti Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_default t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_default t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
 a 
---
(0 rows)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_a t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_c t2_3
         ->  Seq Scan on beta_d t2_4
         ->  Seq Scan on beta_e t2_5
         ->  Seq Scan on beta_f t2_6
         ->  Seq Scan on beta_g t2_7
         ->  Seq Scan on beta_h t2_8
         ->  Seq Scan on beta_default t2_9
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_e t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_default t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(18 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 äbç      | äbç
 ὀδυσσεύς | ὀδυσσεύς
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
                   QUERY PLAN                    
-------------------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_e t1_1
               Filter: (a = 'äbç'::text)
         ->  Seq Scan on alpha_default t1_2
               Filter: (a = 'äbç'::text)
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_f t2_1
                     Filter: (a = 'äbç'::text)
               ->  Seq Scan on beta_default t2_2
                     Filter: (a = 'äbç'::text)
(13 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_default t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_default t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

-- Try again, this time with list partitioning
DROP TABLE alpha CASCADE;
DROP TABLE beta CASCADE;
CREATE TABLE alpha (a TEXT) PARTITION BY LIST(a);
CREATE TABLE alpha_a PARTITION OF alpha FOR VALUES IN ('Türkiye', 'TÜRKIYE');
CREATE TABLE alpha_b PARTITION OF alpha FOR VALUES IN ('bıt', 'BIT');
CREATE TABLE alpha_c PARTITION OF alpha FOR VALUES IN ('äbç', 'ÄBÇ');
CREATE TABLE alpha_d PARTITION OF alpha FOR VALUES IN ('aaá', 'coté', 'Götz');
CREATE TABLE alpha_e PARTITION OF alpha FOR VALUES IN ('ὀδυσσεύς', 'ὈΔΥΣΣΕΎΣ');
CREATE TABLE alpha_f PARTITION OF alpha FOR VALUES IN ('を読み取り用', 'にオープンできませんでした', NULL);
CREATE TABLE alpha_default PARTITION OF alpha DEFAULT;
CREATE TABLE beta (a TEXT) PARTITION BY LIST(a);
CREATE TABLE beta_a PARTITION OF beta FOR VALUES IN ('Türkiye', 'coté', 'ὈΔΥΣΣΕΎΣ');
CREATE TABLE beta_b PARTITION OF beta FOR VALUES IN ('bıt', 'TÜRKIYE');
CREATE TABLE beta_c PARTITION OF beta FOR VALUES IN ('äbç', 'を読み取り用', 'にオープンできませんでした');
CREATE TABLE beta_d PARTITION OF beta FOR VALUES IN ('aaá', 'Götz', 'BIT', 'ὀδυσσεύς', 'ÄBÇ', NULL);
CREATE TABLE beta_default PARTITION OF beta DEFAULT;
INSERT INTO alpha (SELECT a FROM raw_data);
INSERT INTO beta (SELECT a FROM raw_data);
INSERT INTO alpha VALUES (null);
INSERT INTO beta VALUES (null);
INSERT INTO alpha VALUES ('grumble');
INSERT INTO beta VALUES ('grumble');
ANALYZE alpha;
ANALYZE beta;
-- inner join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_c t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_e t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(14 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
 äbç      | äbç
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
            QUERY PLAN             
-----------------------------------
 Nested Loop
   ->  Seq Scan on alpha_c t1
         Filter: (a = 'äbç'::text)
   ->  Seq Scan on beta_c t2
         Filter: (a = 'äbç'::text)
(5 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop
   ->  Seq Scan on alpha_e t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_d t2
         Filter: (a = 'ὀδυσσεύς'::text)
(5 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
                QUERY PLAN                 
-------------------------------------------
 Hash Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Seq Scan on alpha_f t1
               Filter: (a IS NULL)
(11 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
   | 
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
                QUERY PLAN                 
-------------------------------------------
 Hash Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Seq Scan on alpha_f t1
               Filter: (a IS NULL)
(11 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a, t2.a FROM alpha t1 INNER JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
   | 
(1 row)

-- semi join
EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Semi Join
   Hash Cond: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_c t1_1
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
         ->  Seq Scan on alpha_e t1_2
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
   ->  Hash
         ->  Append
               ->  Seq Scan on beta_d t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_a t2_3
               ->  Seq Scan on beta_c t2_4
               ->  Seq Scan on beta_default t2_5
(14 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
    a     
----------
 äbç
 ὀδυσσεύς
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
            QUERY PLAN             
-----------------------------------
 Nested Loop Semi Join
   ->  Seq Scan on alpha_c t1
         Filter: (a = 'äbç'::text)
   ->  Seq Scan on beta_c t2
         Filter: (a = 'äbç'::text)
(5 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
  a  
-----
 äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Semi Join
   ->  Seq Scan on alpha_e t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_d t2
         Filter: (a = 'ὀδυσσεύς'::text)
(5 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
    a     
----------
 ὀδυσσεύς
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a IS NOT DISTINCT FROM t2.a) AND t1.a IS NULL;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Semi Join
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a IS NOT DISTINCT FROM t2.a) AND t1.a IS NULL;
 a 
---
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IS NULL;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop Semi Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a FROM alpha t1 WHERE EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IS NULL;
 a 
---
(0 rows)

-- left join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_c t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_e t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(14 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
 äbç      | äbç
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
            QUERY PLAN             
-----------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_c t1
         Filter: (a = 'äbç'::text)
   ->  Seq Scan on beta_c t2
         Filter: (a = 'äbç'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_e t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_d t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Left Join
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
   | 
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
                QUERY PLAN                 
-------------------------------------------
 Hash Right Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Seq Scan on alpha_f t1
               Filter: (a IS NULL)
(11 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
   | 
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NOT DISTINCT FROM t2.a;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Left Join
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Append
         ->  Seq Scan on alpha_b t1_1
         ->  Seq Scan on alpha_d t1_2
         ->  Seq Scan on alpha_a t1_3
         ->  Seq Scan on alpha_c t1_4
         ->  Seq Scan on alpha_f t1_5
         ->  Seq Scan on alpha_e t1_6
         ->  Seq Scan on alpha_default t1_7
   ->  Materialize
         ->  Append
               ->  Seq Scan on beta_d t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_a t2_3
               ->  Seq Scan on beta_c t2_4
               ->  Seq Scan on beta_default t2_5
(18 rows)

SELECT t1.a, t2.a FROM alpha t1 LEFT JOIN beta t2 ON (t1.a IS NOT DISTINCT FROM t2.a) WHERE t1.a IS NOT DISTINCT FROM t2.a;
             a              |             a              
----------------------------+----------------------------
 bıt                        | bıt
 BIT                        | BIT
 aaá                        | aaá
 coté                       | coté
 Götz                       | Götz
 Türkiye                    | Türkiye
 TÜRKIYE                    | TÜRKIYE
 äbç                        | äbç
 ÄBÇ                        | ÄBÇ
 を読み取り用               | を読み取り用
 にオープンできませんでした | にオープンできませんでした
                            | 
 ὀδυσσεύς                   | ὀδυσσεύς
 ὈΔΥΣΣΕΎΣ                   | ὈΔΥΣΣΕΎΣ
 grumble                    | grumble
(15 rows)

-- anti join
EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
                         QUERY PLAN                         
------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (t1.a = t2.a)
   ->  Append
         ->  Seq Scan on alpha_c t1_1
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
         ->  Seq Scan on alpha_e t1_2
               Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
   ->  Hash
         ->  Append
               ->  Seq Scan on beta_d t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_a t2_3
               ->  Seq Scan on beta_c t2_4
               ->  Seq Scan on beta_default t2_5
(14 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IN ('äbç', 'ὀδυσσεύς');
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
            QUERY PLAN             
-----------------------------------
 Nested Loop Anti Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_c t1
         Filter: (a = 'äbç'::text)
   ->  Seq Scan on beta_c t2
         Filter: (a = 'äbç'::text)
(6 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'äbç';
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Anti Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_e t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_d t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a = 'ὀδυσσεύς';
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a IS NOT DISTINCT FROM t2.a) AND t1.a IS NULL;
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (NOT (t1.a IS DISTINCT FROM t2.a))
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a IS NOT DISTINCT FROM t2.a) AND t1.a IS NULL;
 a 
---
(0 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IS NULL;
                QUERY PLAN                 
-------------------------------------------
 Nested Loop Anti Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_f t1
         Filter: (a IS NULL)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
(10 rows)

SELECT t1.a FROM alpha t1 WHERE NOT EXISTS (SELECT 1 FROM beta t2 WHERE t1.a = t2.a) AND t1.a IS NULL;
 a 
---
 
(1 row)

-- full join
EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (t2.a = t1.a)
   ->  Append
         ->  Seq Scan on beta_d t2_1
         ->  Seq Scan on beta_b t2_2
         ->  Seq Scan on beta_a t2_3
         ->  Seq Scan on beta_c t2_4
         ->  Seq Scan on beta_default t2_5
   ->  Hash
         ->  Append
               ->  Seq Scan on alpha_c t1_1
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
               ->  Seq Scan on alpha_e t1_2
                     Filter: (a = ANY ('{äbç,ὀδυσσεύς}'::text[]))
(14 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IN ('äbç', 'ὀδυσσεύς');
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
 äbç      | äbç
(2 rows)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
            QUERY PLAN             
-----------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_c t1
         Filter: (a = 'äbç'::text)
   ->  Seq Scan on beta_c t2
         Filter: (a = 'äbç'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'äbç';
  a  |  a  
-----+-----
 äbç | äbç
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
               QUERY PLAN               
----------------------------------------
 Nested Loop Left Join
   Join Filter: (t1.a = t2.a)
   ->  Seq Scan on alpha_e t1
         Filter: (a = 'ὀδυσσεύς'::text)
   ->  Seq Scan on beta_d t2
         Filter: (a = 'ὀδυσσεύς'::text)
(6 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a = 'ὀδυσσεύς';
    a     |    a     
----------+----------
 ὀδυσσεύς | ὀδυσσεύς
(1 row)

EXPLAIN (COSTS OFF)
SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
                   QUERY PLAN                    
-------------------------------------------------
 Hash Full Join
   Hash Cond: (t1.a = t2.a)
   Filter: (t1.a IS NULL)
   ->  Append
         ->  Seq Scan on alpha_b t1_1
         ->  Seq Scan on alpha_d t1_2
         ->  Seq Scan on alpha_a t1_3
         ->  Seq Scan on alpha_c t1_4
         ->  Seq Scan on alpha_f t1_5
         ->  Seq Scan on alpha_e t1_6
         ->  Seq Scan on alpha_default t1_7
   ->  Hash
         ->  Append
               ->  Seq Scan on beta_d t2_1
               ->  Seq Scan on beta_b t2_2
               ->  Seq Scan on beta_a t2_3
               ->  Seq Scan on beta_c t2_4
               ->  Seq Scan on beta_default t2_5
(18 rows)

SELECT t1.a, t2.a FROM alpha t1 FULL JOIN beta t2 ON (t1.a = t2.a) WHERE t1.a IS NULL;
 a | a 
---+---
   | 
   | 
(2 rows)

