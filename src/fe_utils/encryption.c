/*-------------------------------------------------------------------------
 *
 * encryption.c
 *	  Front-end code to handle keys for full cluster encryption. The actual
 *	  encryption is not performed here.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/fe_utils/encryption.c
 *
 *-------------------------------------------------------------------------
 */

#include <unistd.h>

#include "postgres_fe.h"

#include "common/fe_memutils.h"
#include "common/file_perm.h"
#include "common/logging.h"
#include "fe_utils/encryption.h"
#include "libpq-fe.h"
#include "libpq-int.h"
#include "libpq/pqcomm.h"

char	   *encryption_key_command = NULL;

#define KDF_PARAMS_FILE			"global/kdf_params"
#define KDF_PARAMS_FILE_SIZE	512

/*
 * Key derivation function.
 */
typedef enum KDFKind
{
	KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA = 0
} KFDKind;

typedef struct KDFParamsPBKDF2
{
	unsigned long int niter;
	unsigned char salt[ENCRYPTION_KDF_SALT_LEN];
} KDFParamsPBKDF2;

/*
 * Parameters of the key derivation function.
 *
 * The parameters are generated by initdb and stored into a file, which is
 * then read during PG startup. This is similar to storing various settings in
 * pg_control. However an existing KDF file is read only, so it does not have
 * to be stored in shared memory.
 */
typedef struct KDFParamsData
{
	KFDKind		function;

	/*
	 * Function-specific parameters.
	 */
	union
	{
		KDFParamsPBKDF2 pbkdf2;
	}			data;

	/* CRC of all above ... MUST BE LAST! */
	pg_crc32c	crc;
} KDFParamsData;

extern KDFParamsData *KDFParams;

/*
 * Pointer to the KDF parameters.
 */
KDFParamsData *KDFParams = NULL;

/* Initialize KDF file. */
void
init_kdf(void)
{
	KDFParamsPBKDF2 *params;
	struct timeval tv;
	uint64	salt;

	/*
	 * The initialization should not be repeated.
	 */
	Assert(KDFParams == NULL);

	KDFParams = palloc0(KDF_PARAMS_FILE_SIZE);
	KDFParams->function = KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA;
	params = &KDFParams->data.pbkdf2;

	/*
	 * Currently we derive the salt in the same way as system identifier,
	 * however these two values are not supposed to match. XXX Is it worth the
	 * effort if initdb derives the system identifier, passes it to this
	 * function and also sends it to the bootstrap process? Not sure.
	 */
	gettimeofday(&tv, NULL);
	salt = ((uint64) tv.tv_sec) << 32;
	salt |= ((uint64) tv.tv_usec) << 12;
	salt |= getpid() & 0xFFF;

	memcpy(params->salt, &salt, sizeof(uint64));
	params->niter = ENCRYPTION_KDF_NITER;
}

/*
 * Write KDFParamsData to file.
 */
void
write_kdf_file(char *dir)
{
	char		path[MAXPGPATH];
	int			fd;

	Assert(KDFParams != NULL);

	/* Account for both file separator and terminating NULL character. */
	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
	{
		pg_log_fatal("KDF directory is too long");
		exit(EXIT_FAILURE);
	}

	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);

	/* Contents are protected with a CRC */
	INIT_CRC32C(KDFParams->crc);
	COMP_CRC32C(KDFParams->crc,
				(char *) KDFParams,
				offsetof(KDFParamsData, crc));
	FIN_CRC32C(KDFParams->crc);

	fd = open(path, O_WRONLY | O_CREAT | PG_BINARY,
			  pg_file_create_mode);
	if (fd < 0)
	{
		pg_log_fatal("could not create key derivation file \"%s\": %m", path);
		exit(EXIT_FAILURE);
	}

	if (write(fd, KDFParams, KDF_PARAMS_FILE_SIZE) != KDF_PARAMS_FILE_SIZE)
	{
		/* if write didn't set errno, assume problem is no disk space */
		if (errno == 0)
			errno = ENOSPC;
		pg_log_fatal("could not write to key derivation file \"%s\": %m",
					 path);
		exit(EXIT_FAILURE);
	}

	if (close(fd))
	{
		pg_log_fatal("could not close key setup file: %m");
		exit(EXIT_FAILURE);
	}
}

/*
 * Read KDFParamsData from file and store it in local memory.
 *
 * If dir is NULL, assume we're in the data directory.
 *
 * postmaster should call the function early enough for any other process to
 * inherit valid pointer to the data.
 */
void
read_kdf_file(char *dir)
{
	pg_crc32c	crc;
	char		path[MAXPGPATH];
	int			fd;

	/* Account for both file separator and terminating NULL character. */
	if ((strlen(dir) + 1 + strlen(KDF_PARAMS_FILE) + 1) > MAXPGPATH)
	{
		pg_log_fatal("KDF directory is too long");
		exit(EXIT_FAILURE);
	}

	snprintf(path, MAXPGPATH, "%s/%s", dir, KDF_PARAMS_FILE);

	KDFParams = palloc0(KDF_PARAMS_FILE_SIZE);
	fd = open(path, O_RDONLY | PG_BINARY, S_IRUSR);

	if (fd < 0)
	{
		pg_log_fatal("could not open key setup file \"%s\": %m", path);
		exit(EXIT_FAILURE);
	}

	if (read(fd, KDFParams, sizeof(KDFParamsData)) != sizeof(KDFParamsData))
	{
		pg_log_fatal("could not read from key setup file \"%s\": %m", path);
		exit(EXIT_FAILURE);
	}

	close(fd);

	/* Now check the CRC. */
	INIT_CRC32C(crc);
	COMP_CRC32C(crc,
				(char *) KDFParams,
				offsetof(KDFParamsData, crc));
	FIN_CRC32C(crc);

	if (!EQ_CRC32C(crc, KDFParams->crc))
	{
		pg_log_fatal("incorrect checksum in key setup file \"%s\"", path);
		exit(EXIT_FAILURE);
	}


	if (KDFParams->function != KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA)
	{
		pg_log_fatal("unsupported KDF function");
		exit(EXIT_FAILURE);
	}
}

/*
 * Run the key derivation function and initialize encryption_key variable.
 */
void
derive_key_from_password(unsigned char *encryption_key, const char *password,
						 int len)
{
	KDFParamsPBKDF2 *params;
	int			rc;

	params = &KDFParams->data.pbkdf2;
	rc = PKCS5_PBKDF2_HMAC(password,
						   len,
						   params->salt,
						   ENCRYPTION_KDF_SALT_LEN,
						   params->niter,
						   EVP_sha1(),
						   ENCRYPTION_KEY_LENGTH,
						   encryption_key);

	if (rc != 1)
	{
		pg_log_fatal("failed to derive key from password");
		exit(EXIT_FAILURE);
	}
}

/*
 * Run the command that is supposed to generate encryption key and store it
 * where encryption_key points to. If valid string is passed for data_dir,
 * it's used to replace '%D' pattern in the command.
 */
void
run_encryption_key_command(unsigned char *encryption_key, char *data_dir)
{
	FILE	   *fp;
	char	cmd[MAXPGPATH];
	char	*sp, *dp, *endp;

	Assert(encryption_key_command != NULL &&
		   strlen(encryption_key_command) > 0);

	/*
	 * Replace %D pattern in the command with the actual data directory path.
	 */
	dp = cmd;
	endp = cmd + MAXPGPATH - 1;
	*endp = '\0';
	for (sp = encryption_key_command; *sp; sp++)
	{
		if (*sp == '%')
		{
			if (sp[1] == 'D')
			{
				if (data_dir == NULL)
				{
					pg_log_fatal("data directory is not known, %%D pattern cannot be replaced");
					exit(EXIT_FAILURE);
				}

				sp++;
				strlcpy(dp, data_dir, endp - dp);
				make_native_path(dp);
				dp += strlen(dp);
			}
			else if (dp < endp)
				*dp++ = *sp;
			else
				break;
		}
		else
		{
			if (dp < endp)
				*dp++ = *sp;
			else
				break;
		}
	}
	*dp = '\0';

	pg_log_debug("executing encryption key command \"%s\"", cmd);

	fp = popen(cmd, "r");
	if (fp == NULL)
	{
		pg_log_fatal("Failed to execute \"%s\"", cmd);
		exit(EXIT_FAILURE);
	}

	/* Read the key. */
	read_encryption_key_fe(fp);

	pclose(fp);
}

/*
 * Frontend counterpart of read_encryption_key().
 */
void
read_encryption_key_fe(FILE *f)
{
	char	   *buf;
	int		read_len, i, c;

	buf = (char *) palloc(ENCRYPTION_KEY_CHARS);

	read_len = 0;
	while ((c = fgetc(f)) != EOF && c != '\n')
	{
		if (read_len >= ENCRYPTION_KEY_CHARS)
		{
			pg_log_fatal("Encryption key is too long");
			exit(EXIT_FAILURE);
		}

		buf[read_len++] = c;
	}

	if (read_len < ENCRYPTION_KEY_CHARS)
	{
		pg_log_fatal("Encryption key is too short");
		exit(EXIT_FAILURE);
	}

	/* Turn the hexadecimal representation into an array of bytes. */
	for (i = 0; i < ENCRYPTION_KEY_LENGTH; i++)
	{
		if (sscanf(buf + 2 * i, "%2hhx", encryption_key + i) == 0)
		{
			pg_log_fatal("Invalid character in encryption key at position %d",
						 2 * i);
			exit(EXIT_FAILURE);
		}
	}

	pfree(buf);
}

/*
 * Send the contents of encryption_key in the form of special startup packet
 * to a server that is being started.
 *
 * Returns true if we could send the message and false if not, however even
 * success does not guarantee that server started up - caller should
 * eventually test server connection himself.
 *
 * TODO Windows stuff?
 */
bool
send_key_to_postmaster(const char *host, const char *port,
					   const unsigned char *encryption_Key)
{
	const char **keywords = pg_malloc0(3 * sizeof(*keywords));
	const char **values = pg_malloc0(3 * sizeof(*values));
	int	i;
	PGconn *conn = NULL;
	int	sock = -1;
	EncryptionKeyMsg	message;
	int	msg_size, packet_size;
	char	*packet = NULL;
	bool	res = true;

/* How many seconds we can wait for the postmaster to receive the key. */
#define SEND_ENCRYPT_KEY_TIMEOUT	60

	if (host)
	{
		keywords[0] = "host";
		values[0] = host;
	}
	keywords[1] = "port";
	values[1] = port;

	/* Compose the message. */
	message.encryptionKeyCode = pg_hton32(ENCRYPTION_KEY_MSG_CODE);
	message.version = 1;
	memcpy(message.data, encryption_key, ENCRYPTION_KEY_LENGTH);
	msg_size = offsetof(EncryptionKeyMsg, data) + ENCRYPTION_KEY_LENGTH;

	packet_size = msg_size + 4;
	packet = (char *) palloc(packet_size);
	*((int32 *) packet) = pg_hton32(packet_size);
	memcpy(packet + 4, &message, msg_size);

	/*
	 * Although we don't expect the server to accept regular libpq messages,
	 * we try to get at least a valid socket.
	 */
	for (i = 0; i < SEND_ENCRYPT_KEY_TIMEOUT + 1; i++)
	{
		if (i > 0)
			/* Sleep for 1 second. */
			pg_usleep(1000000L);

		if (conn)
		{
			PQfinish(conn);
			conn = NULL;
		}

		conn = PQconnectStartParams(keywords, values, false);
		if (conn == NULL)
			continue;

		sock = PQsocket(conn);
		/* Cannot send the key if there's no valid socket. */
		if (sock == -1)
			continue;

		/* Non-blocking write would only make this simple case tricky. */
		if (!pg_set_block(sock))
			continue;

	retry:
		/*
		 * Send the packet. Here we need to use low level API because the server
		 * does is not fully up so libpq cannot be used properly.
		 */
		if (send(sock, (char *) packet, packet_size, 0) != packet_size)
		{
			if (SOCK_ERRNO == EINTR)
				/* Interrupted system call - we'll just try again */
				goto retry;
			continue;
		}
		else
			/* Success */
			break;
	}

	pg_free(keywords);
	pg_free(values);
	if (conn)
		PQfinish(conn);
	pfree(packet);

	return res;
}
