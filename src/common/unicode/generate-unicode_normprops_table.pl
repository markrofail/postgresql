#!/usr/bin/perl
#
# Generate table of Unicode normalization "quick check" properties
# (see UAX #15).  Pass DerivedNormalizationProps.txt as argument.  The
# output is on stdout.
#
# Copyright (c) 2020, PostgreSQL Global Development Group

use strict;
use warnings;

use PerfectHash;

my %data;

print "/* generated by src/common/unicode/generate-unicode_normprops_table.pl, do not edit */\n\n";

print <<EOS;
typedef int (*QuickCheckHashFunc) (const void *key);

typedef struct
{
	const uint32	   *codepoints;
	QuickCheckHashFunc	hash;
	int					num_maybes;
	int					num_codepoints;
} unicode_norm_info;

EOS

foreach my $line (<ARGV>)
{
	chomp $line;
	$line =~ s/\s*#.*$//;
	next if $line eq '';
	my ($codepoint, $prop, $value) = split /\s*;\s*/, $line;
	next if $prop !~ /_QC/;

	my ($first, $last);
	if ($codepoint =~ /\.\./)
	{
		($first, $last) = split /\.\./, $codepoint;
	}
	else
	{
		$first = $last = $codepoint;
	}

	foreach my $cp (hex($first)..hex($last))
	{
		$data{$prop}{$cp} = $value;
	}
}

# We create a separate array for each normalization form rather than,
# say, a two-dimensional array, because that array would be very
# sparse and would create unnecessary overhead especially for the NFC
# lookup.
foreach my $prop (sort keys %data)
{
	# Don't build the tables for the "D" forms because they are too
	# big.  See also unicode_is_normalized_quickcheck().
	next if $prop eq "NFD_QC" || $prop eq "NFKD_QC";

	generate_qc_hash($prop);
}


sub generate_qc_hash
{
	my $prop = shift;
	my %subdata = %{$data{$prop}};

	# collect MAYBE's and NO's separately
	my @maybes = grep $subdata{$_} eq 'M', keys %subdata;
	my @noes   = grep $subdata{$_} eq 'N', keys %subdata;
	my $num_maybes = scalar @maybes;

	# Emit array of hex valus and save the bytes as a string in
	# network order.
	my @cp_packed;
	printf "static const uint32 %s_codepoints[] = {\n", $prop;
	printf "\t/* MAYBE's */\n";
	foreach my $cp (sort { $a <=> $b } @maybes)
	{
		push @cp_packed, pack('N', $cp);
		printf "\t0x%04X,\n", $cp;
	}
	printf "\t/* NO's */\n";
	foreach my $cp (sort { $a <=> $b } @noes)
	{
		push @cp_packed, pack('N', $cp);
		printf "\t0x%04X,\n", $cp;
	}
	print "};\n\n";

	my $funcname = $prop . '_hash_func';
	my $f = PerfectHash::generate_hash_function(\@cp_packed, $funcname,
		fixed_key_length => 4);
	print "static $f\n";

	printf "static const unicode_norm_info UnicodeNormInfo_%s = {\n", $prop;
	printf "\t%s_codepoints,\n",           $prop;
	printf "\t%s,\n",                      $funcname;
	printf "\t%d,\n",                      $num_maybes;
	printf "\t%d\n",                       scalar @cp_packed;
	printf "};\n\n";
}
